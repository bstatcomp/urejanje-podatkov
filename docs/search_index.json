[["nizi-kategori-ne-spremenljivke-in-datumi.html", "Poglavje 3 Nizi, kategorine spremenljivke in datumi 3.1 Priprava 3.2 Nizi 3.3 Kategorine spremenljivke 3.4 Datumi in ure 3.5 Shranjevanje in branje podatkov 3.6 Ali elite izvedeti ve? 3.7 Domaa naloga", " Poglavje 3 Nizi, kategorine spremenljivke in datumi Pri delu s podatki se pogosto sreamo s posebnimi podatkovnimi tipi, kot so nizi, kategorine spremenljivke in datumi. Z nizi smo e delali v prvih dveh poglavjih. Delali smo tudi s kategorinimi spremenljivkami, eprav tega nismo poudarili. V tem poglavju bomo spoznali napredneje operacije nad temi podatkovnimi tipi v okviru zbirke tidyverse ter predstavili praktine primere, dobre prakse in pasti pri delu z njimi. Konec poglavja pa bomo posvetili branju in pisanju podatkov v razlinih oblikah. 3.1 Priprava Nizi Najprej si poglejmo najbolj uporabne funkcije za delo z nizi. Nize lahko zdruujemo na ve nainov: crke &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) stevilke &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) str_c(crke, stevilke) ## [1] &quot;A1&quot; &quot;B2&quot; &quot;C3&quot; &quot;D4&quot; str_c(crke, stevilke, sep = &quot;-&quot;) ## [1] &quot;A-1&quot; &quot;B-2&quot; &quot;C-3&quot; &quot;D-4&quot; str_c(crke, stevilke, collapse = &quot;-&quot;) ## [1] &quot;A1-B2-C3-D4&quot; Obratno jih lahko razlenimo na ve manjih nizov: str_split(&quot;A1-B2-C3-D4&quot;, pattern = &quot;-&quot;) ## [[1]] ## [1] &quot;A1&quot; &quot;B2&quot; &quot;C3&quot; &quot;D4&quot; Zelo uporabna je tudi funkcija za zamenjavo podnizov. str_replace(&quot;A1-B1-A2-B2&quot;, pattern = &quot;1&quot;, &quot;(ena)&quot;) ## [1] &quot;A(ena)-B1-A2-B2&quot; str_replace_all(&quot;A1-B1-A2-B2&quot;, pattern = &quot;1&quot;, &quot;(ena)&quot;) ## [1] &quot;A(ena)-B(ena)-A2-B2&quot; str_replace_all(&quot;A1-B1-A2-B2&quot;, c(&quot;1&quot; = &quot;(ena)&quot;, &quot;2&quot; = &quot;(dva)&quot;)) ## [1] &quot;A(ena)-B(ena)-A(dva)-B(dva)&quot; Poglejmo, kako bi iz zbirke sadeev v e vgrajenem nizu fruit poiskali vse nize, ki vsebujejo berry. length(fruit) ## [1] 80 str_subset(fruit, &quot;berry&quot;) ## [1] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blueberry&quot; &quot;boysenberry&quot; &quot;cloudberry&quot; ## [6] &quot;cranberry&quot; &quot;elderberry&quot; &quot;goji berry&quot; &quot;gooseberry&quot; &quot;huckleberry&quot; ## [11] &quot;mulberry&quot; &quot;raspberry&quot; &quot;salal berry&quot; &quot;strawberry&quot; Podobno lahko vrnemo logini vektor nizov, ki vsebujejo berry. str_detect(fruit, &quot;berry&quot;) ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE TRUE TRUE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE ## [25] FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE FALSE FALSE FALSE ## [37] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [49] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [73] TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE Funkcija str_detect() je zelo uporabna pri izbiranju vrstic glede na nize. Obiajno jo uporabljamo v kombinaciji z regularnimi izrazi, ki jih bomo spoznali v jedru tega poglavja. Kategorine spremenljivke Pri pripravi na kategorine spremenljivke bomo uporabili podatke o uspehu tudentov na izpitu: tib &lt;- tibble( ime = c(&quot;Maja&quot;, &quot;Ales&quot;, &quot;Tom&quot;, &quot;Barbara&quot;, &quot;Simon&quot;, &quot;Tina&quot;), spol = c(&quot;z&quot;, &quot;m&quot;, &quot;m&quot;, &quot;z&quot;, &quot;m&quot;, &quot;z&quot;), ocena = c(10, 10, 6, 8, 8, 7), dan_izpita = c(8, 8, 16, 16, 8, 23), mesec_izpita = rep(6, 6), leto_izpita = rep(2021, 6), opravljene_vaje = c(1, 1, 1, 1, 0, 1), procenti_vaje = c(70, 65, 80, 90, 30, 75) ) tib ## # A tibble: 6 x 8 ## ime spol ocena dan_izpita mesec_izpita leto_izpita opravljene_vaje ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maja z 10 8 6 2021 1 ## 2 Ales m 10 8 6 2021 1 ## 3 Tom m 6 16 6 2021 1 ## 4 Barbara z 8 16 6 2021 1 ## 5 Simon m 8 8 6 2021 0 ## 6 Tina z 7 23 6 2021 1 ## # ... with 1 more variable: procenti_vaje &lt;dbl&gt; Spremenimo spol v nominalno spremenljivko (brez ureditve) in oceno v ordinalno spremenljivko (obstaja vrsti red vrednosti): tib &lt;- tib %&gt;% mutate(spol = factor(spol), ocena = factor(ocena, ordered = TRUE)) tib$spol ## [1] z m m z m z ## Levels: m z tib$ocena ## [1] 10 10 6 8 8 7 ## Levels: 6 &lt; 7 &lt; 8 &lt; 10 Nivoje faktorja (levels) lahko uredimo tudi glede na vrednosti v nekem drugem stolpcu. To obiajno pride prav pri vizualizaciji. tib &lt;- tib %&gt;% mutate(spol = fct_reorder(spol, procenti_vaje, .desc = TRUE)) tib$spol ## [1] z m m z m z ## Levels: z m Datumi Za delo z datumi bomo uporabljali paket lubridate. Datume lahko z lubridate shranimo na ve nainov. Preprosto lahko sestavimo datum s posameznimi komponentami: library(lubridate) make_date(year = 2021, month = 6, day = 11) ## [1] &quot;2021-06-11&quot; Ali iz niza: ymd(&quot;2021-06-11&quot;) ## [1] &quot;2021-06-11&quot; Lahko dodamo tudi as: make_datetime(year = 2021, month = 6, day = 11, hour = 11, min = 30, tz = &quot;CET&quot;) ## [1] &quot;2021-06-11 11:30:00 CEST&quot; Z datumi lahko tudi raunamo: my_date &lt;- make_date(year = 2021, month = 6, day = 11) my_date ## [1] &quot;2021-06-11&quot; my_date + days(2) ## [1] &quot;2021-06-13&quot; my_date + months(3) ## [1] &quot;2021-09-11&quot; Shranjevanje podatkov v csv V pripravi v 2. poglavju smo e spoznali funkcijo rear_csv2() za branje podatkov iz tekstovnih datotek. Podatke lahko tudi shranimo v tekstovno datoteko s funkcijo write_csv2(): write_csv2(tib, &quot;./data-raw/studenti.csv&quot;) Naloga 1: Datoteko ocene.csv v mapi data-raw preberite s funkcijami paketa readr (read_csv2() in write_csv2()). Shranite jo kot ocene2.csv in to datoteko preberite nazaj. Nato naredite enako z baznimi funkcijami v R (read.csv2() in write.csv2()). Kaj opazite? Z readr: ## # A tibble: 6 x 7 ## ime spol ocena dan_izpita mesec_izpita leto_izpita opravljene_vaje ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maja z 7 8 6 2021 1 ## 2 Ales m 10 8 6 2021 1 ## 3 Tom m 6 16 6 2021 1 ## 4 Barbara z 8 16 6 2021 1 ## 5 Simon m 8 8 6 2021 0 ## 6 Tina z 7 23 6 2021 1 Z R: ## X ime spol ocena dan_izpita mesec_izpita leto_izpita opravljene_vaje ## 1 1 Maja z 7 8 6 2021 1 ## 2 2 Ales m 10 8 6 2021 1 ## 3 3 Tom m 6 16 6 2021 1 ## 4 4 Barbara z 8 16 6 2021 1 ## 5 5 Simon m 8 8 6 2021 0 ## 6 6 Tina z 7 23 6 2021 1 Naloga 2: Ponovno preberite ocene.csv ter: spremenite stolpec opravljene_vaje v kategorine vrednosti, zamenjajte stolpce leto_izpita, mesec_izpita, dan_izpita z datum_izpita, ki vsebuje vse te podatke, izberite samo imena, ki se zanejo na T in podatke shranite v datoteko oceneT.csv. ## ime spol ocena opravljene_vaje datum_izpita ## 1 Tom m 6 1 2021-06-16 ## 2 Tina z 7 1 2021-06-23 Delo s umniki Pri delu z nizi RStudio uporablja privzeto kodiranje vaega operacijskega sistema. Preprost nain, da preverite, ali R uporablja pravilno kodiranje, je, da v konzolo napiete ebula. Nazaj morate dobiti enak niz in ne cebula ali celo bula. &quot;ebula&quot; ## [1] &quot;ebula&quot; e R ne vrne istega niza, je potrebno nastaviti privzeto kodiranje na svojem operacijskem sistemu. Da vidimo, katero kodiranje je trenutno uporabljeno, lahko napiemo: Sys.getlocale() ## [1] &quot;LC_COLLATE=Slovenian_Slovenia.1250;LC_CTYPE=Slovenian_Slovenia.1250;LC_MONETARY=Slovenian_Slovenia.1250;LC_NUMERIC=C;LC_TIME=Slovenian_Slovenia.1250&quot; Pri tem izpisu vidimo, da uporabljamo sloveski nabor znakov CP1250. e imate teave, lahko to zaasno spremenite z ukazom: Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;Slovenian_Slovenia.1250&quot;) ## [1] &quot;LC_COLLATE=Slovenian_Slovenia.1250;LC_CTYPE=Slovenian_Slovenia.1250;LC_MONETARY=Slovenian_Slovenia.1250;LC_NUMERIC=C;LC_TIME=Slovenian_Slovenia.1250&quot; Oziroma lahko na primer v OS Windows nastavite privzeto kodiranje pod Settings -&gt; Time &amp; Language -&gt; Region -&gt; Regional Format. Tukaj izberite Slovenian (Slovenia). Za slovenski OS Windows: Nastavitve -&gt; Ura in Jezik -&gt; Regija -&gt; Obmone nastavitve in izberite Slovenina (Slovenija). 3.2 Nizi Zbirka paketov tidyverse vsebuje paket stringr, ki je namenjen delu z nizi. Vsi ukazi v paketu se zanejo s str_, kar v kombinaciji s funkcionalnostjo avtomatskega dopolnjevanja omogoa hitro izbiro in pregled vseh funkcij. V jeziku R lahko za definiranje niza uporabimo enojne () ali dvojne navednice (\"). R bo rezultat sicer vedno vrnil v dvojnih navednicah. niz_dvojne_navednice &lt;- &quot;urejanje podatkov&quot; niz_enojne_navednice &lt;- &#39;urejanje podatkov&#39; niz_dvojne_navednice ## [1] &quot;urejanje podatkov&quot; niz_enojne_navednice ## [1] &quot;urejanje podatkov&quot; e elimo znotraj niza uporabiti dvojne navednice, lahko za definicijo uporabljamo enojne in obratno: citat1 &lt;- &quot;Jure je rekel: &#39;Citiram Janeza&#39;.&quot; citat2 &lt;- &#39;In Janez je rekel: &quot;Citiram Jureta&quot;.&#39; citat1 ## [1] &quot;Jure je rekel: &#39;Citiram Janeza&#39;.&quot; citat2 ## [1] &quot;In Janez je rekel: \\&quot;Citiram Jureta\\&quot;.&quot; Izpis v drugem primeru uporablja tako imenovan escape character (\\), ki omogoa tudi vpis tabulaterjev (\\t), znakov za novo vrstico (\\n) in podobno. Vse znake, ki jih je tako mono zapisati, si lahko ogledate z ukazom ?\"'\". Niz lahko vkljuuje tudi vse posebne znake, ki jih podpira Unicode. To je standard za konsistentno kodiranje teksta, ki vsebuje preko 100000 znakov. Za vnos znakov unicode uporabite \\uxxxx, kjer je xxxx koda znaka, ki ga lahko poiete na strani https://unicode.org/charts/. normalna_porazdelitev &lt;- &quot;Normal(\\u03BC, 1)&quot; normalna_porazdelitev ## [1] &quot;Normal(Âµ, 1)&quot; Dolino nizov poiemo s funkcijo str_length(): str_length(c(&quot;tri&quot;, &quot;tiri&quot;, &quot;&quot;, citat1, normalna_porazdelitev)) ## [1] 3 5 0 32 12 Za zdruevanje nizov se uporablja str_c(), ki mu lahko dodamo tudi niz sep, ki ga vrine med vse podane nize: str_c(&quot;paradinik&quot;, &quot;buke&quot;, &quot;jabolka&quot;, &quot;paprika&quot;, &quot;jagode&quot;, sep = &quot;, &quot;) ## [1] &quot;paradinik, buke, jabolka, paprika, jagode&quot; e funkciji podamo vektorje lahko zdruimo tudi ve nizov naenkrat. Pri tem bo tevilo dobljenih nizov enako najvejemu vektorju, manji pa se bodo reciklirali, kar pomeni, da se bodo njihove vrednosti ponavljale, dokler ne doseejo doline najdaljega vektorja. str_c(&quot;Podpoglavje &quot;, c(1, 2, 3, 4), &quot;: &quot;, c(&quot;Nizi&quot;, &quot;Faktorji&quot;, &quot;Datumi&quot;, &quot;Branje podatkov&quot;)) ## [1] &quot;Podpoglavje 1: Nizi&quot; &quot;Podpoglavje 2: Faktorji&quot; ## [3] &quot;Podpoglavje 3: Datumi&quot; &quot;Podpoglavje 4: Branje podatkov&quot; e elimo nize zdruiti zaporedno uporabimo collapse. Za izpis nizov brez escape znakov uporabite funkcijo cat(): poglavja &lt;- str_c(&quot;Podpoglavje &quot;, c(1, 2, 3, 4), &quot;: &quot;, c(&quot;Nizi&quot;, &quot;Faktorji&quot;, &quot;Datumi&quot;, &quot;Branje podatkov&quot;), collapse = &quot;\\n&quot;) poglavja ## [1] &quot;Podpoglavje 1: Nizi\\nPodpoglavje 2: Faktorji\\nPodpoglavje 3: Datumi\\nPodpoglavje 4: Branje podatkov&quot; cat(poglavja) ## Podpoglavje 1: Nizi ## Podpoglavje 2: Faktorji ## Podpoglavje 3: Datumi ## Podpoglavje 4: Branje podatkov Manjkajoe vrednosti lahko zamenjamo s str_replace_na(). str_replace_na(c(&quot;ena&quot;, &quot;dva&quot;, NA, &quot;tiri&quot;), replacement = &quot;tri!&quot;) ## [1] &quot;ena&quot; &quot;dva&quot; &quot;tri!&quot; &quot;tiri&quot; 3.2.1 Podnizi Velikokrat pri delu z nizi potrebujemo le del niza ali pa elimo niz razdeliti na ve manjih nizov. Poglejmo si na primeru niza \" KUPI: paradinik, buke, jabolka, paprika, jagode. \", iz katerega elimo dobiti vektor sadja in zelenjave: listek &lt;- &quot; KUPI: paradinik, buke, jabolka, paprika, jagode. &quot; Najprej odstranimo odvene zaetne in konne presledke. To storimo s str_trim(): listek &lt;- str_trim(listek) listek ## [1] &quot;KUPI: paradinik, buke, jabolka, paprika, jagode.&quot; Funkcija str_sub() vrne podniz glede na indekse znakov: str_sub(listek, 7, 16) # Vrne znake med indeksom 7 do 16. ## [1] &quot;paradinik&quot; str_sub(listek, 7) # Vrne znake od sedmega naprej. ## [1] &quot;paradinik, buke, jabolka, paprika, jagode.&quot; str_sub(listek, -7) # Vrne zadnjih sedem znakov. ## [1] &quot;jagode.&quot; str_sub(listek, -7, -2) # Vrne predzadnjih est znakov. ## [1] &quot;jagode&quot; S tem znanjem lahko odstranimo prvih est znakov in zadnjega: listek &lt;- str_sub(listek, 7, -2) listek ## [1] &quot;paradinik, buke, jabolka, paprika, jagode&quot; Sedaj, ko imamo elemente samo natete in loene z vejico, jih lahko preprosto razdelimo s funkcijo str_split(), ki ji podamo vzorec za loevanje: str_split(listek, pattern = &quot;, &quot;) ## [[1]] ## [1] &quot;paradinik&quot; &quot;buke&quot; &quot;jabolka&quot; &quot;paprika&quot; &quot;jagode&quot; 3.2.2 Iskanje vzorcev z regularnimi izrazi Regularni izrazi so mono orodje za iskanje poljubnega vzorca v nizih. V tem poglavju bo predstavljena le osnovna funkcionalnost regularnih izrazov, saj gre za zelo obirno orodje. Za prikaz delovanja bomo uporabljali funkciji str_view() in str_view_all(), ki uporabljata paket htmlwidgets za prikaz rezultatov. Prva oznai samo prvo ujemanje, druga pa vsa ujemanja. Regularni izrazi so nizi, ki doloijo iskalni vzorec. Z njimi lahko, na primer, iemo nize, ki se zanejo na doloen podniz, konajo na doloen podniz, vsebujejo posebne simbole in podobno. Uporabljamo jih lahko v vseh funkcijah paketa stringr, ki imajo kot vhod pattern. Sestavimo dva seznama v katerih bomo iskali vzorce. Za zaetek poiimo vse vejice. library(htmlwidgets) listek1 &lt;- &quot;KUPI: paradinik, buke, jabolka, paprika, jagode. Aja, pa banane.&quot; listek2 &lt;- &quot;KUPI: sok(3x), kruh, pikote, pato(2x), sol in poper.&quot; str_view_all(c(listek1, listek2), &quot;,&quot;) Kaj pa pike? str_view_all(c(listek1, listek2), &quot;.&quot;) Pika je poseben znak pri regularnih izrazih, ki predstavlja poljuben znak. Zato smo dobili ujemanja z vsemi rkami. Da lahko dejansko poiemo pike in druge posebne znake moramo uporabiti znak escape \\, s katerim programu sporoimo, naj simbola za tem ne prebere kot regularni izraz. Tukaj se nam nekoliko zaplete, ker je znak \\ e znak escape v R za tabulatorje (\\t), nove vrstice (\\n) itd. Zato, da vzorcu dejansko podamo \\. moramo zapisati \\\\.. Tukaj si ponovno lahko pomagamo s funkcijo cat(), ki nam bo pokazala dejanski niz podan funkciji. cat(&quot;\\\\.&quot;) # Poglejmo kaken niz bo dejansko sprejela funkcija str_view_all(). ## \\. str_view_all(c(listek1, listek2), &quot;\\\\.&quot;) Regularni izrazi uporabljajo tudi dva posebna znaka, ki oznaujeta zaetek ^ in konec $ niza. Poiimo samo pike, ki zakljuujejo nize: str_view_all(c(listek1, listek2), &quot;\\\\.$&quot;) V regularnih izrazih so zelo uporabne tudi naslednje sekvence. \\d: Ujemanje s poljubno tevko; \\s: Ujemanje s poljubnim presledkom (presledek, tabulator, nova vrstica); [xyz]: Ujemanje z x, y ali z; [^xyz]: Ujemanje z vsem razen x, y in z. Streica znotraj oglatih oklepajev pomeni negacijo; [[:digit:]]: Ujemanje s poljubnim tevilom; [[:alpha:]]: Ujemanje s poljubno rko, uporabite lahko tudi [[a-z]] in [[:lower:]] za vse male rke ali [[A-Z]] in [[:upper:]] za vse velike rke; [[:punct:]]: Ujemanje z loili. Poglejmo si uporabo nekaterih: str_view_all(c(listek1, listek2), &quot;\\\\dx&quot;) # Poiemo vse tevilke, ki jim sledi x. str_view_all(c(listek1, listek2), &quot;[]&quot;) # Vse umnike. str_view_all(c(listek1, listek2), &quot;[aA].[aA]&quot;) # Dva a-ja s poljubnim znakom vmes. str_view_all(c(listek1, listek2), &quot;.[\\\\s,.]&quot;) # Vse konce besed. str_view_all(c(listek1, listek2), &quot;[a-f]&quot;) # Vse rke od a do f. str_view_all(c(listek1, listek2), &quot;[[:punct:]]&quot;) # Vsa loila. Znotraj oglatih oklepajev je pomen pike dobeseden znak pika. Tako, da ga ni potrebno zapisati kot \\\\. Priporoamo, da sami preizkuate e druge sekvence. Navpina rta | pomeni ali: str_view_all(c(listek1, listek2), &quot;sol|sok&quot;) 3.2.3 Ponovitve Zelo uporabni so tudi ukazi za ponovitve znakov ali sekvenc, ki nam omogoajo iskanje nizov doloenih dolin. Ukazi za delo s ponovitvami so: ?: ponovi 0 ali 1 krat, *: ponovi 0 ali ve krat, +: ponovi 1 ali ve krat, {n}: ponovi natanko n krat, {n,}: ponovi n ali ve krat, {,m}: ponovi m ali manj krat, {n,m}: ponovi med n in m krat. e znak za ponovitev uporabimo za enim znakom pomeni to ponovitev prejnjega znaka. Lahko pa ga uporabimo tudi za oglatimi ali navadnimi oklepaji. Navadni oklepaji doloajo skupino (ve o skupinah v nadalje), ki se mora ponoviti. Oglati oklepaji pa izbiro, se pravi ponoviti se mora vsaj en od natetih znakov. Ko zanemo uporabljati ponovitve se pojavijo prve veje teave. Poiimo vse besede doline 3. Besede sledijo presledku, torej zanemo regularni izraz z \\\\s (pri tem ignoriramo prvo besedo v odstavku). Nato morajo slediti 3 rke, torej [:alpha:]{3}. Temu mora slediti nov presledek ali loilo, [[:punct:]]|\\\\s: str_view_all(c(listek1, listek2), &quot;\\\\s[[:alpha:]]{3}([[:punct:]]|\\\\s)&quot;) Poskuajmo poiskati besede, ki se zanejo na p in konajo na k ali e. str_view_all(c(listek1, listek2), &quot;p.*[ke]&quot;) Opazimo, da je ujemanje poreno. To pomeni, da je ujemanje najdalje mono, ki ustreza ponovitvam. e elimo najkrajega lahko uporabimo e dodaten ? za znakom za ponovitve. str_view_all(c(listek1, listek2), &quot;p.*?[ke]&quot;) e vedno ni OK. V dobljenih nizih ne elimo presledkov in ne elimo, da se ujemanje kona prehitro, kot pri besedi pikote. Poskusimo tako, da vzamemo ponovitve, ki ne vsebujejo presledkov. str_view_all(c(listek1, listek2), &quot;p[^\\\\s]*[ke]&quot;) Da zagotovimo zajem konca besede, doloimo e, da naj bo na koncu vejica ali presledek. str_view_all(c(listek1, listek2), &quot;p[[:alpha:]]*[ke]([, ])&quot;) 3.2.4 Skupine Kot smo e videli lahko uporabimo tudi oklepaje, da loimo del regularnega izraza od ostalih simbolov. Oklepaji pa definirajo tudi skupino, na katero se lahko sklicujemo z \\x, kjer je x zaporedna tevilka skupine. Poglejmo si uporabo le tega na e vgrajenem vektorju sadja. Parameter match = TRUE nam vrne le nize, pri katerih je prilo do ujemanja. str_view(fruit, &quot;(..)\\\\1&quot;, match = TRUE) Zgornji regularni izraz z .. poie dva poljubna znaka. Z (..) definiramo skupino. Z \\1 oziroma \\\\1, pa zahtevamo, da se na tem mestu e enkrat nahaja tono to kar je bilo med oklepaji. Poiimo imena sadeev, ki imajo vsaj dve (lahko razlini) ponavljajoi si rki: str_view(fruit, &quot;(.)\\\\1.*(.)\\\\2&quot;, match = TRUE) 3.2.5 Uporaba regularnih izrazov Uporabo regularnih izrazov si najprej pogljemo na preprostih podatkih, nato pa e na podatkih iz ankete. Poiimo sadje in zelenjavo, ki vsebuje umnike: seznam &lt;- c(&quot;paradinik&quot;, &quot;buke&quot;, &quot;jabolka&quot;, &quot;paprika&quot;, &quot;jagode&quot;); str_detect(seznam, &quot;[]&quot;) ## [1] TRUE TRUE FALSE FALSE FALSE e elimo namesto loginega vektorja dobiti dejanska imena elementov, uporabimo str_subset(): str_subset(seznam, &quot;[]&quot;) ## [1] &quot;paradinik&quot; &quot;buke&quot; Poglejmo, koliko samoglasnikov vsebuje vsaka beseda v seznamu. Pozor, funkcija str_count() ne zazna ponovitev, e se le-te prekrivajo: str_count(seznam, &quot;[aeiou]&quot;) ## [1] 4 2 3 3 3 str_count(&quot;ababa&quot;, &quot;aba&quot;) # Ne zazna dveh ponovitev, ker se prekrivata. ## [1] 1 S funkcijo str_locate() vrnemo indekse lokacij najdenih vzorcev, s str_extract() pa dobimo ta vzorec oziroma podniz. S str_match() dobimo podskupine. Poiimo podnize do prvega umnika. str_locate(seznam, &quot;^.*[]&quot;) ## start end ## [1,] 1 7 ## [2,] 1 3 ## [3,] NA NA ## [4,] NA NA ## [5,] NA NA str_extract(seznam, &quot;^.*[]&quot;) ## [1] &quot;paradi&quot; &quot;bu&quot; NA NA NA str_match(seznam, &quot;(^.*)([])&quot;) ## [,1] [,2] [,3] ## [1,] &quot;paradi&quot; &quot;paradi&quot; &quot;&quot; ## [2,] &quot;bu&quot; &quot;bu&quot; &quot;&quot; ## [3,] NA NA NA ## [4,] NA NA NA ## [5,] NA NA NA V zadnjem primeru funkcija str_match() v prvem stolpcu vrne enako kot str_extract(), nato pa v naslednjih stolpcih vrne e vsako skupino posebej. Preprosta in zelo uporabna pa je funkcija str_replace() oziroma str_replace_all(), s katero lahko zamenjamo dele nizov. Prekrijmo umnike z znaki x: str_replace(seznam, &quot;[]&quot;, &quot;x&quot;) ## [1] &quot;paradixnik&quot; &quot;buxke&quot; &quot;jabolka&quot; &quot;paprika&quot; &quot;jagode&quot; Podamo lahko tudi zamenjavo za ve ujemanj: str_replace_all(seznam, c(&quot;&quot; = &quot;c&quot;, &quot;&quot; = &quot;s&quot;, &quot;&quot;= &quot;z&quot;)) ## [1] &quot;paradiznik&quot; &quot;bucke&quot; &quot;jabolka&quot; &quot;paprika&quot; &quot;jagode&quot; Poglejmo si sedaj e uporabo na realnih podatkih. Najprej naloimo podatke: ds_jobs &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs &lt;- tibble(ds_jobs) ds_jobs ## # A tibble: 4,523 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Netherl~ 51 Employed full-time Engineer R ## 9 Male Colombia 34 Employed full-time Data Scientist Python ## 10 Male Germany 41 Independent contrac~ Data Scientist Python ## # ... with 4,513 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Najbolj uporabna funkcija pri delu z nizi v podatkih je str_detect(), ki nam omogoa izbiro podmnoice vrstic. Pogosto jo kombiniramo z regularnimi izrazi. Poiimo tiste vrstice, kjer imajo anketiranci ve slubenih nazivov. Ti so loeni z znakom /: ds_jobs %&gt;% select(CurrentJobTitle) %&gt;% filter(str_detect(CurrentJobTitle, &quot;/&quot;)) ## # A tibble: 946 x 1 ## CurrentJobTitle ## &lt;chr&gt; ## 1 Software Developer/Software Engineer ## 2 Software Developer/Software Engineer ## 3 Scientist/Researcher ## 4 Software Developer/Software Engineer ## 5 Scientist/Researcher ## 6 Scientist/Researcher ## 7 Scientist/Researcher ## 8 Scientist/Researcher ## 9 Software Developer/Software Engineer ## 10 Scientist/Researcher ## # ... with 936 more rows Izberimo samo tiste vrstice, kjer se CurrentJobTitle zane z Data in se EmploymentStatus kona s full-time: ds_jobs %&gt;% select(EmploymentStatus, CurrentJobTitle) %&gt;% filter(str_detect(CurrentJobTitle, &quot;^Data&quot;), str_detect(EmploymentStatus, &quot;full-time$&quot;)) ## # A tibble: 1,679 x 2 ## EmploymentStatus CurrentJobTitle ## &lt;chr&gt; &lt;chr&gt; ## 1 Employed full-time Data Analyst ## 2 Employed full-time Data Scientist ## 3 Employed full-time Data Scientist ## 4 Employed full-time Data Scientist ## 5 Employed full-time Data Analyst ## 6 Employed full-time Data Scientist ## 7 Employed full-time Data Scientist ## 8 Employed full-time Data Analyst ## 9 Employed full-time Data Analyst ## 10 Employed full-time Data Scientist ## # ... with 1,669 more rows Vasih so nizi v podatkih predolgi, oziroma lahko brez kode za pomen izbriemo del niza. Najlaje to naredimo tako, da ga zamenjamo s praznim nizom. Izbriimo podnize Employed: ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = str_replace(EmploymentStatus, &quot;Employed &quot;, &quot;&quot;)) ds_jobs %&gt;% select(EmploymentStatus, CurrentJobTitle) ## # A tibble: 4,523 x 2 ## EmploymentStatus CurrentJobTitle ## &lt;chr&gt; &lt;chr&gt; ## 1 full-time Business Analyst ## 2 full-time Software Developer/Software En~ ## 3 full-time Software Developer/Software En~ ## 4 part-time Researcher ## 5 full-time Scientist/Researcher ## 6 part-time Other ## 7 full-time Data Analyst ## 8 full-time Engineer ## 9 full-time Data Scientist ## 10 Independent contractor, freelancer, or self-~ Data Scientist ## # ... with 4,513 more rows Sedaj imamo eno manjo nekonsistentnost v podatkih. Nekateri nizi se zanejo z veliko zaetnico, nekateri pa z malo. Spremenimo vse na malo zaetnico: ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = str_to_lower(EmploymentStatus)) ds_jobs %&gt;% select(EmploymentStatus, CurrentJobTitle) ## # A tibble: 4,523 x 2 ## EmploymentStatus CurrentJobTitle ## &lt;chr&gt; &lt;chr&gt; ## 1 full-time Business Analyst ## 2 full-time Software Developer/Software En~ ## 3 full-time Software Developer/Software En~ ## 4 part-time Researcher ## 5 full-time Scientist/Researcher ## 6 part-time Other ## 7 full-time Data Analyst ## 8 full-time Engineer ## 9 full-time Data Scientist ## 10 independent contractor, freelancer, or self-~ Data Scientist ## # ... with 4,513 more rows Funkcijo str_count() lahko uporabimo, da anketirancem dodamo stolpec s tevilom slubenih nazivov: ds_jobs %&gt;% select(CurrentJobTitle) %&gt;% mutate(NumberOfJobTitles = str_count(CurrentJobTitle, &quot;/&quot;) + 1) ## # A tibble: 4,523 x 2 ## CurrentJobTitle NumberOfJobTitles ## &lt;chr&gt; &lt;dbl&gt; ## 1 Business Analyst 1 ## 2 Software Developer/Software Engineer 2 ## 3 Software Developer/Software Engineer 2 ## 4 Researcher 1 ## 5 Scientist/Researcher 2 ## 6 Other 1 ## 7 Data Analyst 1 ## 8 Engineer 1 ## 9 Data Scientist 1 ## 10 Data Scientist 1 ## # ... with 4,513 more rows Poskuajmo razdeliti CurrentJobTitle na FirstTitle in SecondTitle, pri tem naj se naziva ponovita, e ima anketiranec samo enega. ds_jobs %&gt;% select(CurrentJobTitle) %&gt;% mutate(FirstTitle = str_extract(CurrentJobTitle, &quot;^[^/]*&quot;), SecondTitle = str_extract(CurrentJobTitle, &quot;[^/]*$&quot;)) ## # A tibble: 4,523 x 3 ## CurrentJobTitle FirstTitle SecondTitle ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Business Analyst Business Analyst Business Analyst ## 2 Software Developer/Software Engineer Software Developer Software Engineer ## 3 Software Developer/Software Engineer Software Developer Software Engineer ## 4 Researcher Researcher Researcher ## 5 Scientist/Researcher Scientist Researcher ## 6 Other Other Other ## 7 Data Analyst Data Analyst Data Analyst ## 8 Engineer Engineer Engineer ## 9 Data Scientist Data Scientist Data Scientist ## 10 Data Scientist Data Scientist Data Scientist ## # ... with 4,513 more rows 3.3 Kategorine spremenljivke Kategorine spremenljivke so spremenljivke, ki lahko zavzamejo samo konno mnogo vnaprej doloenih vrednosti. Najbolj pogoste so: Nominalne spremenljivke. To so spremenljivke brez ureditve: tip izdelka ali znamka avtomobila. Ordinalne spremenljivke. To so spremenljivke, ki imajo smiselno ureditev: stopnja izobrazbe ali olski uspeh. V R uporabljamo za delo s kategorinimi spremenljivkami t. i. faktorje (ang. factor). Ti se od spremenljivk tipa niz razlikujejo v tem, da se v spremenljivki hrani informacija o vseh monih vrednostih. Faktorju ni mogoe dodati vrednosti, ki je ni v mnoici monih vrednosti, kar slui kot varovalka pred napakami pri vnosu podatkov. Poglejmo si uporabo faktorja na dveh preprostih primerih, kjer bomo sami ustvarili spremenljivki. Kasneje si bomo pogledali e delo s faktorji na primeru realnih podatkov, kjer bomo ponovno uporabili podatke o zaposlitvah na podroju podatkovnih ved. Kot primer nominalne spremenljivke si oglejmo krvne skupine. Obstajajo 4 mone vrednosti. Ustvarimo vektor krvnih skupin za pet razlinih oseb: krvne_skupine &lt;- c(&quot;B&quot;, &quot;B&quot;, &quot;O&quot;, &quot;AB&quot;, &quot;BA&quot;) Sedaj je ta vektor shranjen kot niz. Kaj so slabosti taknega shranjevanja kategorinih podatkov? Prvi, nimamo nobenega varovala pred tipkarskimi napakami  R je zadnji vnos prebral kot BA in ga tako tudi shranil, eprav ta krvna skupina ne obstaja: krvne_skupine ## [1] &quot;B&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;BA&quot; Pri ronem vnosu podatkov hitro pride do tipkarskih napak in naeloma ne vemo, ali je avtor podatkov v tem primeru elel vnesti A, B ali AB. Drugi, e elimo urediti to spremenljivko, se bodo vrednosti razvrstile po abecedi: sort(krvne_skupine) ## [1] &quot;AB&quot; &quot;B&quot; &quot;B&quot; &quot;BA&quot; &quot;O&quot; Morda pa bi bilo bolj smiselno urediti po standardni ureditvi, torej A, B, AB, O. Da se izognemo tem teavam, je bolje, e spremenljivko, za katero vemo, da bo zasedla eno od vnaprej doloenih vrednosti, shranimo kot faktor. V R za to uporabimo funkcijo factor(). Naredimo faktor iz spremenljivke krvne_skupine: krvne_skupine_fac &lt;- factor(krvne_skupine) krvne_skupine_fac ## [1] B B O AB BA ## Levels: AB B BA O Opazimo, da je sedaj spremenljivka druganega tipa, saj hrani tudi informacijo o monih vrednostih oziroma ravneh (ang. levels). Ampak v tem primeru so te ravni napane (ne zajame vseh 4 krvnih skupin, poleg tega pa vsebuje tudi eno napano vrednost). Funkcija factor() privzeto kot ravni nastavi vse vrednosti v podani spremenljivki. e elimo, ji lahko podamo dodaten argument levels, kjer rono doloimo, katere ravni bodo v spremenljivki. V kolikor to vemo vnaprej, je dobra praksa, da podamo tudi ta argument: krvne_skupine_fac &lt;- factor(krvne_skupine, levels = c(&quot;A&quot;, &quot;B&quot;, &quot;AB&quot;, &quot;O&quot;)) krvne_skupine_fac ## [1] B B O AB &lt;NA&gt; ## Levels: A B AB O sort(krvne_skupine_fac) ## [1] B B AB O ## Levels: A B AB O Opazimo dvoje: sedaj lahko spremenljivko uredimo glede na standardno notacijo in nesmiselne vrednosti se spremenijo v NA. Faktorju torej ne moremo prirediti vrednosti, ki ni enaka eni izmed vrednosti v ravneh. Da dostopamo do vseh ravni faktorja, uporabimo funkcijo levels(): levels(krvne_skupine_fac) ## [1] &quot;A&quot; &quot;B&quot; &quot;AB&quot; &quot;O&quot; Vasih imajo kategorine spremenljivke tudi smiselno razvrstitev po velikosti, ki pa se obiajno ne da numerino izmeriti. Kot primer si poglejmo olski uspeh, ki lahko zavzame 5 vrednosti. V kolikor elimo, da faktor hrani tudi informacijo o tem, da obstaja smiselna razvrstitev po velikosti, dodamo argument ordered = TRUE. uspeh &lt;- factor(c(&quot;odlino&quot;, &quot;dobro&quot;, &quot;dobro&quot;, &quot;prav dobro&quot;), levels = c(&quot;nezadostno&quot;, &quot;zadostno&quot;, &quot;dobro&quot;, &quot;prav dobro&quot;, &quot;odlino&quot;), ordered = TRUE) uspeh ## [1] odlino dobro dobro prav dobro ## Levels: nezadostno &lt; zadostno &lt; dobro &lt; prav dobro &lt; odlino Opazimo, da imamo sedaj pri izpisu nivojev dodatno informacijo o razvrstitvi uspeha. V praksi nam to omogoa primerjavo, medtem ko tega pri faktorjih, ki nimajo razvrstitve po velikosti, ne moremo narediti. uspeh[2] &gt; uspeh[1] ## [1] FALSE krvne_skupine_fac[2] &gt; krvne_skupine_fac[1] ## Warning in Ops.factor(krvne_skupine_fac[2], krvne_skupine_fac[1]): &#39;&gt;&#39; not ## meaningful for factors ## [1] NA Poleg prednosti, ki smo jih e omenili, imajo faktorji posebno vlogo pri raznih statistinih modelih in modelih strojnega uenja. Nekatere metode eksplicitno zahtevajo faktorje. Prav tako razlikujejo med nominalnimi in ordinalnimi faktorji, kar se pozna na rezultatih. Ravno tako so faktorji pomembni v primeru, ko poznamo nabor monih vrednosti a nekaterih pri meritvah e nismo opazili. Pri izrisu elimo take vrednosti izpisati z vrednostjo 0 ali NA. Poglejmo si uporabo faktorjev na realni podatkovni mnoici. Ponovno bomo delali s podatki o zaposlitvah na podroju podatkovnih ved. Preberimo podatke in ponovimo nekaj operacij, ki smo jih spoznali na prvem predavanju. Prav tako bomo izbrali samo podmnoico stolpcev za bolj jasen prikaz. library(tidyverse) ds_jobs &lt;- read_csv2(&quot;./data-raw/DS-jobs.csv&quot;) %&gt;% select(Country, Age, EmploymentStatus, FormalEducation, CompensationAmount, ExchangeRate) %&gt;% filter(!is.na(ExchangeRate)) %&gt;% mutate(CompensationUSD = CompensationAmount * ExchangeRate) %&gt;% filter(CompensationUSD &lt;= 2500000, CompensationUSD &gt;= 10000) ds_jobs ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; Imamo 3 spremenljivke, ki bi jih bilo smiselno shraniti kot faktorje  Country, EmploymentStatus in FormalEducation. Pretvorimo jih v faktorje. Pri tem pustimo kar privzeto nastavitev, da se kot nivoji uporabijo vse vrednosti v stolpcih. library(tidyverse) ds_jobs &lt;- ds_jobs %&gt;% mutate(Country = factor(Country), EmploymentStatus = factor(EmploymentStatus), FormalEducation = factor(FormalEducation)) ds_jobs ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; levels(ds_jobs$Country) ## [1] &quot;Argentina&quot; &quot;Australia&quot; ## [3] &quot;Belarus&quot; &quot;Belgium&quot; ## [5] &quot;Brazil&quot; &quot;Canada&quot; ## [7] &quot;Chile&quot; &quot;Colombia&quot; ## [9] &quot;Czech Republic&quot; &quot;Denmark&quot; ## [11] &quot;Egypt&quot; &quot;Finland&quot; ## [13] &quot;France&quot; &quot;Germany&quot; ## [15] &quot;Greece&quot; &quot;Hong Kong&quot; ## [17] &quot;Hungary&quot; &quot;India&quot; ## [19] &quot;Indonesia&quot; &quot;Iran&quot; ## [21] &quot;Ireland&quot; &quot;Israel&quot; ## [23] &quot;Italy&quot; &quot;Japan&quot; ## [25] &quot;Kenya&quot; &quot;Malaysia&quot; ## [27] &quot;Mexico&quot; &quot;Netherlands&quot; ## [29] &quot;New Zealand&quot; &quot;Nigeria&quot; ## [31] &quot;Norway&quot; &quot;Other&quot; ## [33] &quot;Pakistan&quot; &quot;People &#39;s Republic of China&quot; ## [35] &quot;Philippines&quot; &quot;Poland&quot; ## [37] &quot;Portugal&quot; &quot;Republic of China&quot; ## [39] &quot;Romania&quot; &quot;Russia&quot; ## [41] &quot;Singapore&quot; &quot;South Africa&quot; ## [43] &quot;South Korea&quot; &quot;Spain&quot; ## [45] &quot;Sweden&quot; &quot;Switzerland&quot; ## [47] &quot;Taiwan&quot; &quot;Turkey&quot; ## [49] &quot;Ukraine&quot; &quot;United Kingdom&quot; ## [51] &quot;United States&quot; &quot;Vietnam&quot; levels(ds_jobs$EmploymentStatus) ## [1] &quot;Employed full-time&quot; ## [2] &quot;Employed part-time&quot; ## [3] &quot;Independent contractor, freelancer, or self-employed&quot; levels(ds_jobs$FormalEducation) ## [1] &quot;Bachelor&#39;s degree&quot; ## [2] &quot;Doctoral degree&quot; ## [3] &quot;I did not complete any formal education past high school&quot; ## [4] &quot;I prefer not to answer&quot; ## [5] &quot;Master&#39;s degree&quot; ## [6] &quot;Professional degree&quot; ## [7] &quot;Some college/university study without earning a bachelor&#39;s degree&quot; Kaj se zgodi, e elimo v tibblu spremeniti vrednost faktorja v neko vrednost, ki je ni v tem faktorju? Recimo, da elimo v 2. vrstici spremeniti dravo v Narnia: ds_jobs2 &lt;- ds_jobs ds_jobs2$Country[2] &lt;- &quot;Narnia&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 2, value = structure(c(2L, NA, 47L, 51L, : ## invalid factor level, NA generated ds_jobs2 ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 &lt;NA&gt; 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; Ker Narnia ni nivo v faktorju, se nadomesti z NA. e elimo dodati nov nivo temu faktorju, uporabimo fct_expand(): ds_jobs2 &lt;- ds_jobs %&gt;% mutate(Country = fct_expand(Country, &quot;Narnia&quot;)) ds_jobs2$Country[2] &lt;- &quot;Narnia&quot; ds_jobs2 ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Narnia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; 3.3.1 Sprememba razvrstitve faktorja Kot smo omenili e pri krvnih skupinah, imajo velikokrat tudi faktorji, ki niso razvreni po velikosti, neko ustaljeno ureditev. Ureditev pa lahko tudi kasneje spremenimo. Ta operacija je obiajno uporabna pri vizualizaciji. Poglejmo si, na primer, kako so plae povezane z izobrazbo. Za vizualizacijo rezultatov bomo uporabili razsevni diagram: ds_jobs_agg &lt;- ds_jobs %&gt;% group_by(FormalEducation) %&gt;% summarise(MeanCompensationUSD = mean(CompensationUSD)) ds_jobs_agg ## # A tibble: 8 x 2 ## FormalEducation MeanCompensationU~ ## &lt;fct&gt; &lt;dbl&gt; ## 1 Bachelor&#39;s degree 71665. ## 2 Doctoral degree 90856. ## 3 I did not complete any formal education past high school 78470. ## 4 I prefer not to answer 90023. ## 5 Master&#39;s degree 78411. ## 6 Professional degree 64614. ## 7 Some college/university study without earning a bachelor&#39;s~ 105675. ## 8 &lt;NA&gt; 47833. ggplot(ds_jobs_agg, aes(x = FormalEducation, y = MeanCompensationUSD)) + geom_point() + coord_flip() + xlab(&quot;&quot;) Ta graf je sicer zelo informativen, ampak bi s teavo hitro ugotovili, kako so nivoji faktorja razvreni glede na plao. ggplot razvrsti vrednosti glede na to, kako so razvrene v faktorju: levels(ds_jobs$FormalEducation) ## [1] &quot;Bachelor&#39;s degree&quot; ## [2] &quot;Doctoral degree&quot; ## [3] &quot;I did not complete any formal education past high school&quot; ## [4] &quot;I prefer not to answer&quot; ## [5] &quot;Master&#39;s degree&quot; ## [6] &quot;Professional degree&quot; ## [7] &quot;Some college/university study without earning a bachelor&#39;s degree&quot; Morda bi bilo bolje tak graf urediti glede na vrednosti spremenljivke MeanCompensationUSD, za kar moramo doloiti novo razvrstitev te spremenljivke. Za to obstaja v paketu forcats, ki je del tidyverse, funkcija fct_reorder(). ggplot(ds_jobs_agg, aes(x = fct_reorder(FormalEducation, MeanCompensationUSD), y = MeanCompensationUSD)) + geom_point() + coord_flip() + xlab(&quot;&quot;) Razvrstitev lahko uredimo tudi rono s funkcijo fct_relevel(), ki ohrani privzeto razvrstitev tako, da podane nivoje premakne na zaetek, oziroma lahko podamo argument after. ggplot(ds_jobs_agg, aes(x = fct_relevel(FormalEducation, &quot;I prefer not to answer&quot;, &quot;I did not complete any formal education past high school&quot;, after = 0), y = MeanCompensationUSD)) + geom_point() + coord_flip() + xlab(&quot;&quot;) 3.3.2 Preimenivanje obstojeih nivojev Nivoje faktorjev lahko preimenujemo s funkcijo fct_recode(). ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = fct_recode(EmploymentStatus, &quot;full-time&quot; = &quot;Employed full-time&quot;, &quot;part-time&quot; = &quot;Employed part-time&quot;, &quot;other&quot; = &quot;Independent contractor, freelancer, or self-employed&quot;)) head(ds_jobs$EmploymentStatus) ## [1] full-time full-time full-time part-time full-time full-time ## Levels: full-time part-time other Sorodno lahko zgornjo funkcijo zamenjamo s fct_collapse(), ki lahko zdrui ve nivojev v enega. 3.3.3 Razbitje numerine spremenljivke na intervale Pogosto elimo numerino spremenljivko segmentirati na doloene intervale. Na primer, pri doloanju avtomobilskih zavarovalnih premij lahko zavarovance segmentiramo glede na starost. V R za to uporabimo funkcijo cut(). Razdelimo spremenljivko Age na intervale, kjer bodo osebe razdeljene do 25 let, nad 25 in to 35 let, nad 35 do 50 let, in nad 50 let. ds_jobs &lt;- ds_jobs %&gt;% mutate(AgeInterval = cut(Age, breaks = c(0, 25, 35, 50, 100))) ds_jobs_agg &lt;- ds_jobs %&gt;% group_by(AgeInterval) %&gt;% summarise(CompensationByAge = mean(CompensationUSD)) ggplot(ds_jobs_agg, aes(x = AgeInterval, y = CompensationByAge)) + geom_point() 3.4 Datumi in ure Delo z datumi in urami na prvi pogled morda deluje enostavno. Vendar pa zaradi razlinih fizikalnih zakonitosti ali lovekih konstruktov lahko pride do teav. Na primer, vsako leto nima 365 dni. Prav tako v nekaterih asovnih conah 3. ura zjutraj ne sledi vedno 2. uri, saj pride do premika ure. Za delo z datumi bomo uporabljali paket lubridate. Glavni komponenti v tem paketu sta datum (date) in as (time) ter zdruena komponenta datum in as (datetime). S tem paketom lahko datume ustvarimo na 2 naina: Z nizom: library(lubridate) ymd(&quot;2021-04-02&quot;) ## [1] &quot;2021-04-02&quot; ymd(&quot;2021/04/02&quot;) ## [1] &quot;2021-04-02&quot; ymd(20210402) ## [1] &quot;2021-04-02&quot; dmy(&quot;02.04.2021&quot;) ## [1] &quot;2021-04-02&quot; ymd_hms(&quot;2021-04-02 12:01:00&quot;) # Tipa datetime. ## [1] &quot;2021-04-02 12:01:00 UTC&quot; ymd(20210402, 20210403) ## [1] &quot;2021-04-02&quot; &quot;2021-04-03&quot; mdy(&quot;April 2nd, 2021&quot;) # Deluje za angleka imena mesecev. ## [1] &quot;2021-04-02&quot; S posameznimi komponentami: make_date(2021, 4, 2) ## [1] &quot;2021-04-02&quot; make_datetime(2021, 4, 2, 12, 1, 0) ## [1] &quot;2021-04-02 12:01:00 UTC&quot; Opazimo, da pri datumu in asu spremenljivka hrani tudi informacijo o asovnem pasu. Privzeto lubridate dela s asovnim pasom UTC (Coordinated Universal Time), ki je naslednik GMT (Greenwich Mean Time). Prednost tega asovnega pasu je , da se ne prilagaja spremembi ure v pomladnih in jesenskih mesecih. Te spremembe lahko privedejo do napak pri raunanju z datumi in asi, tako da je raunanje v UTC bolj varno. Seveda pa lahko rono nastavimo drugi asovni pas z argumentom tz. Paket lubridate uporablja IANA asovne pasove (https://www.iana.org/time-zones), ki so definirani s kombinacijo celine in drave. Za Ljubljano bi asovni pas nastavili tako: ymd_hms(&quot;2021-04-02 12:01:00&quot;, tz = &quot;Europe/Ljubljana&quot;) ## [1] &quot;2021-04-02 12:01:00 CEST&quot; Pomembno je , da vemo, v katerem asovnem pasu so bile opravljene meritve v naih podatkih, da lahko potem ustrezno pretvorimo spremenljivko v asovno. Seveda pa lahko tudi pretvarjamo asovne spremenljivke med asovnimi pasovi. Za to uporabimo funkcijo with_tz(). Vsakemu asu v doloenem asovnem pasu lahko priredimo nek as v drugem asovnem pasu. V kolikor elimo bolj robustno raunati z datumi in urami, lahko vedno datume pretvorimo v UTC as, naredimo izraune in potem pretvorimo nazaj v lokalni asovni pas. my_datetime &lt;- ymd_hms(&quot;2021-04-02 12:01:00&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime ## [1] &quot;2021-04-02 12:01:00 CEST&quot; my_datetime_UTC &lt;- with_tz(my_datetime, tz = &quot;UTC&quot;) my_datetime_UTC ## [1] &quot;2021-04-02 10:01:00 UTC&quot; V ozdaju pa spremenljivki hranita isti as. To lahko preverimo z: my_datetime == my_datetime_UTC ## [1] TRUE V R je asovni pas namenjen samo izpisu datumov in asov. Vrednost spremenljivke ostane nespremenjena. To lahko preverimo tako, da odtejemo en datum od drugega, kar nam vrne razliko v asu: my_datetime - my_datetime_UTC ## Time difference of 0 secs V kolikor smo narobe prebrali datum v zaetku (na primer, v podatkih je bil datum v UTC, prebrali pa smo v lokalnem asu) zgornja pretvorba med asovnimi pasovi ni ustrezna, saj bomo s tem zajeli napaen as. V tem primeru moramo uporabiti funkcijo force_tz(). Poizkusite kaj naredi ta funkcija, tako da z njo pretvorijo my_datetime v UTC in potem izraunajte razliko, podobno kot smo to naredili zgoraj. Kadar delamo sekvence datumov in asov, te upotevajo premik ure in prehodov v naslednje dni. Poglejmo si prehod na poletni as v letu 2021: datetime_dst &lt;- seq(ymd_hms(&quot;2021-03-28 00:00:00&quot;, tz = &quot;Europe/Ljubljana&quot;), ymd_hms(&quot;2021-03-28 04:00:00&quot;, tz = &quot;Europe/Ljubljana&quot;), by = &quot;30 min&quot;) datetime_dst ## [1] &quot;2021-03-28 00:00:00 CET&quot; &quot;2021-03-28 00:30:00 CET&quot; ## [3] &quot;2021-03-28 01:00:00 CET&quot; &quot;2021-03-28 01:30:00 CET&quot; ## [5] &quot;2021-03-28 03:00:00 CEST&quot; &quot;2021-03-28 03:30:00 CEST&quot; ## [7] &quot;2021-03-28 04:00:00 CEST&quot; with_tz(datetime_dst, tz = &quot;UTC&quot;) ## [1] &quot;2021-03-27 23:00:00 UTC&quot; &quot;2021-03-27 23:30:00 UTC&quot; ## [3] &quot;2021-03-28 00:00:00 UTC&quot; &quot;2021-03-28 00:30:00 UTC&quot; ## [5] &quot;2021-03-28 01:00:00 UTC&quot; &quot;2021-03-28 01:30:00 UTC&quot; ## [7] &quot;2021-03-28 02:00:00 UTC&quot; Pozorni moramo biti tudi na kombiniranje datumov. V kolikor uporabimo funkcijo c(), vedno preverimo, v katerem asovnem pasu je rezultat. 3.4.1 Raunanje z datumi in asi Vsaka asovna spremenljivka, ki vsebuje datum in as, je sestavljena iz komponent. Te so leto, mesec, dan, ura, minuta in sekunda. Za dostop do posameznih komponent imamo na voljo ve funkcij: year() month() mday() Dan v mesecu. wday() Dan v tednu. Privzeto se zane z nedeljo. To lahko spremenimo z argumentom week_start. hour() minute() second() Poglejmo sedaj kaj vraajo te funkcije: x &lt;- now() x ## [1] &quot;2021-06-14 12:27:54 CEST&quot; year(x) ## [1] 2021 month(x) ## [1] 6 mday(x) ## [1] 14 wday(x) ## [1] 2 wday(x, week_start = 1) ## [1] 1 hour(x) ## [1] 12 minute(x) ## [1] 27 second(x) ## [1] 54.38038 S komponentami lahko tudi spreminjamo dele asovne spremenljivke: mday(x) &lt;- 5 x ## [1] &quot;2021-06-05 12:27:54 CEST&quot; Pri raunanju s asovnimi enotami v lubridate poznamo tri razrede: trajanja (ang. duration). as v sekundah. Funkcije dseconds(), dminutes(), ddays(), dweeks() in dyears(). Pri trajanjih se vedno uporabi pretvorba, da ima vsak dan 24 ur in vsako leto 365.25 dni. Slednje predstavlja povpreno teilo dni v letu. Tako da bo funkcija dyears(4) vedno vrnila tevilo sekund, ki ustreza 4x365.25 dnem, ki imajo vsak po 24 ur. obdobja (ang. period). as v lovekih enotah kot je na primer teden. Funkcije seconds(), minutes(), days(), weeks(), months() in years(). intervali (ang. interval). asovni interval med dvema tokama. Pozoren bralec je opazil, da pri trajanjih nismo navedli funkcije za mesece. To pa zato, ker imajo meseci lahko 28, 29, 30 ali 31 dni. Vsekakor bi pri izbiri osnovne enote za trajanja prilo do neke arbitrarne odloitve, koliko dni vzamemo privzeto. 30 ali 31? V vsakem primeru bo vsaj polovica mesecev imela napano trajanje. Pri dnevih in letih si laje privoimo posploitev. ddays(1) ## [1] &quot;86400s (~1 days)&quot; days(1) ## [1] &quot;1d 0H 0M 0S&quot; Poglejmo si preprost primer, kako dodati doloena obdobja: my_datetime &lt;- ymd_hms(&quot;2021/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + dminutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + minutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + months(2) ## [1] &quot;2021-08-08 11:05:30 CEST&quot; Trajanja in obdobja so si oitno zelo podobni, ampak imajo eno veliko razliko, kadar raunamo z dnevi, tedni in leti. Prvi, kadar bomo uporabljali dyears() lahko hitro pride do teave, saj bomo priteli 0.25 dneva. Poglejmo si to na primeru: my_datetime + years(1) ## [1] &quot;2022-06-08 11:05:30 CEST&quot; my_datetime + dyears(1) ## [1] &quot;2022-06-08 17:05:30 CEST&quot; Opazimo, da smo priteli 6 dodatnih ur. Drugi, kaj se zgodi, kadar pritejemo teden ali dan v asu, ko pride do premika ure. Premik ure se je po lokalnem asu zgodil 28. 3. 2021 ob 2 zjutraj. my_datetime &lt;- ymd_hms(&quot;2021/03/27 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-03-28 12:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-03-28 11:05:30 CEST&quot; my_datetime + dweeks(1) ## [1] &quot;2021-04-03 12:05:30 CEST&quot; my_datetime + weeks(1) ## [1] &quot;2021-04-03 11:05:30 CEST&quot; Funkcija years() deluje, kot bi priakovali tudi na prestopnem letu: my_datetime &lt;- ymd_hms(&quot;2020/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + years(1) ## [1] &quot;2021-06-08 11:05:30 CEST&quot; S funkcijami trajanja in obdobji lahko tudi raunamo, na primer: dyears(2) + ddays(4) + dseconds(20) ## [1] &quot;63460820s (~2.01 years)&quot; days(2) + minutes(20) + seconds(120) ## [1] &quot;2d 0H 20M 120S&quot; 5 * dminutes(20) ## [1] &quot;6000s (~1.67 hours)&quot; 5 * minutes(20) ## [1] &quot;100M 0S&quot; Najbolje, da jo prikaemo na dveh primerih  premik ure in prestopno leto. Obdobja so bolj naraven prikaz za loveka. my_datetime &lt;- ymd_hms(&quot;2021/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + dminutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + minutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + dyears(1) ## [1] &quot;2022-06-08 17:05:30 CEST&quot; my_datetime + years(1) ## [1] &quot;2022-06-08 11:05:30 CEST&quot; my_datetime + months(2) ## [1] &quot;2021-08-08 11:05:30 CEST&quot; V bazi letalskih letov posodobimo podatke tako, da izraunamo niz, ki predstavlja odhod letala. library(nycflights13) head(flights) ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## # ... with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flights_datetime &lt;- flights %&gt;% select(year, month, day, hour, minute) %&gt;% mutate(DepartureTime = make_datetime(year, month, day, hour, minute)) flights_datetime ## # A tibble: 336,776 x 6 ## year month day hour minute DepartureTime ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 2013 1 1 5 15 2013-01-01 05:15:00 ## 2 2013 1 1 5 29 2013-01-01 05:29:00 ## 3 2013 1 1 5 40 2013-01-01 05:40:00 ## 4 2013 1 1 5 45 2013-01-01 05:45:00 ## 5 2013 1 1 6 0 2013-01-01 06:00:00 ## 6 2013 1 1 5 58 2013-01-01 05:58:00 ## 7 2013 1 1 6 0 2013-01-01 06:00:00 ## 8 2013 1 1 6 0 2013-01-01 06:00:00 ## 9 2013 1 1 6 0 2013-01-01 06:00:00 ## 10 2013 1 1 6 0 2013-01-01 06:00:00 ## # ... with 336,766 more rows head(flights_datetime$DepartureTime) ## [1] &quot;2013-01-01 05:15:00 UTC&quot; &quot;2013-01-01 05:29:00 UTC&quot; ## [3] &quot;2013-01-01 05:40:00 UTC&quot; &quot;2013-01-01 05:45:00 UTC&quot; ## [5] &quot;2013-01-01 06:00:00 UTC&quot; &quot;2013-01-01 05:58:00 UTC&quot; Ali opazimo kakno teavo? Datume smo prebrali v asovni coni UTC, podani pa so v lokalni asovni coni. Podatkov torej nismo pravilno pretvorili! Poizkusimo e enkrat: flights_datetime &lt;- flights %&gt;% select(year, month, day, hour, minute) %&gt;% mutate(DepartureTime = make_datetime(year, month, day, hour, minute, tz = &quot;America/New_York&quot;)) flights_datetime ## # A tibble: 336,776 x 6 ## year month day hour minute DepartureTime ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 2013 1 1 5 15 2013-01-01 05:15:00 ## 2 2013 1 1 5 29 2013-01-01 05:29:00 ## 3 2013 1 1 5 40 2013-01-01 05:40:00 ## 4 2013 1 1 5 45 2013-01-01 05:45:00 ## 5 2013 1 1 6 0 2013-01-01 06:00:00 ## 6 2013 1 1 5 58 2013-01-01 05:58:00 ## 7 2013 1 1 6 0 2013-01-01 06:00:00 ## 8 2013 1 1 6 0 2013-01-01 06:00:00 ## 9 2013 1 1 6 0 2013-01-01 06:00:00 ## 10 2013 1 1 6 0 2013-01-01 06:00:00 ## # ... with 336,766 more rows head(flights_datetime$DepartureTime) ## [1] &quot;2013-01-01 05:15:00 EST&quot; &quot;2013-01-01 05:29:00 EST&quot; ## [3] &quot;2013-01-01 05:40:00 EST&quot; &quot;2013-01-01 05:45:00 EST&quot; ## [5] &quot;2013-01-01 06:00:00 EST&quot; &quot;2013-01-01 05:58:00 EST&quot; 3.5 Shranjevanje in branje podatkov 3.5.1 Delo z binarnimi datotekami V programskem jeziku R lahko spremenljivke shranjujemo in beremo (v trenutno sejo R) kot binarne objekte. Prednost tega shranjevanja pred shranjevanjem v csv ali excelove razpredelnice je, da se ohranijo tudi meta informacije, kot so recimo nivoji pri faktorjih. Shranjujemo na dva prevladujoa naina: S kombinacijo funkcij save() in load(). S kombinacijo funkcij saveRDS() in readRDS(). Pomembna razlika med prvim in drugim pristopom je, da lahko s prvim shranimo ve spremenljivk naenkrat, z drugim pa samo eno. Na prvi pogled bi torej priakovali, da je prvi pristop bolji, oziroma bolj zaelen. Ampak ima eno pomembno slabost, zaradi katere predlagamo uporabo drugega pristopa. Funkcija save() shrani spremenljivke v trenutni seji R v datoteko s konnico rda ali RData. To naredi tako, da shrani tako vrednost spremenljivke kot tudi ime spremenljivke. To pomeni, da ko bomo takno datoteko prebrali v novo sejo R, bomo ustvarili spremenljivke z enakimi imeni, kot smo jih shranili. Pri tem pa lahko pride do teav. Recimo, da imamo v trenutni seji R e nek nabor spremenljivk nato pa elimo vanjo prenesti e neke druge spremenljivke, ki smo jih pred asom shranili s funkcijo save() v datoteko saved-data.rda. Kaj se bo zgodilo, e bo katera od spremenljivk v nai trenutni seji imela enako ime kot ena od spremenljivk shranjenih v saved-data.rda? R bo enostavno to spremenljivko prepisal s spremenljivko, ki se je nahajala v tej rda datoteki. Taken postopek dela je lahko torej nevaren, saj lahko nevede izbriemo obstojee spremenljivke. Predlagamo torej uporabo kombinacije funkcij saveRDS() in readRDS(). Funkcija saveRDS() shrani samo vrednost spremenljivke, ne pa tudi njenega imena, tako da ne pride do podobnih teav kot pri prvem pristopu. Konnica tako shranjenih datotek je rds. Poglejmo si uporabo teh funkcij: x &lt;- c(3, 6, 3, 7) x ## [1] 3 6 3 7 saveRDS(x, &quot;./my-saved-files/my-x.rds&quot;) x2 &lt;- readRDS(&quot;./my-saved-files/my-x.rds&quot;) x2 ## [1] 3 6 3 7 Vedno ko preberemo podatke v sejo R s funkcijo readRDS(), ji moramo prirediti ime, saj je v rds datoteki shrnajena samo njena vrednost. S tem se tudi izognemo podobnim teavam kot pri funkcijah save() in load(). Pomanjkljivost shranjevanja datotek rds je v tem, da lahko naenkrat shranimo samo 1 spremenljivko. Ampak to pomanjkljivost lahko zaobidemo tako, da ve spremenljivk enostavno shranimov v seznam (list()). Poglejmo si sedaj na primer, kako bi shranili ve spremenljivk. tmp_list &lt;- list( &quot;x&quot; = x, &quot;some_datetime&quot; = my_datetime, &quot;ds_jobs&quot; = ds_jobs ) saveRDS(tmp_list, &quot;./my-saved-files/my-list.rds&quot;) read_list &lt;- readRDS(&quot;./my-saved-files/my-list.rds&quot;) names(read_list) ## [1] &quot;x&quot; &quot;some_datetime&quot; &quot;ds_jobs&quot; x2 &lt;- read_list[[&quot;x&quot;]] x2 ## [1] 3 6 3 7 my_datetime2 &lt;- read_list[[&quot;some_datetime&quot;]] my_datetime2 ## [1] &quot;2021-06-08 11:05:30 CEST&quot; ds_jobs2 &lt;- read_list[[&quot;ds_jobs&quot;]] ds_jobs2 ## # A tibble: 3,186 x 8 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 full-time Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 full-time Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 full-time Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 part-time Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 full-time Doctoral degree 100000 1 ## 6 Russia 22 full-time Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 full-time Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 other I did not comp~ 150000 1.20 ## 9 Poland 29 full-time Master&#39;s degree 126000 0.281 ## 10 United ~ 35 full-time Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 2 more variables: CompensationUSD &lt;dbl&gt;, ## # AgeInterval &lt;fct&gt; 3.5.2 Branje in shranjevanje z ostalimi datotekami 3.5.2.1 Excel Paket openxlsx omogoa delo z exelovimi razpredelnicami. Poglejmo si preproste a uporabne ukaze. Za branje podatkov s tem paketom uprabljamo read.xlsx(), za shranjevanje datotek pa write.xlsx(). Preberimo podatke ocen, ki smo jih imeli v testni skripti, in jo pretvorimo v tibble: library(openxlsx) ocene &lt;- tibble(openxlsx::read.xlsx(&quot;./test-script/data-raw/student-performance.xlsx&quot;)) ocene ## # A tibble: 649 x 12 ## school sex famsize Pstatus traveltime studytime internet absences G1 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP F GT3 A 2 2 no 4 0 ## 2 GP F GT3 T 1 2 yes 2 9 ## 3 GP F LE3 T 1 2 yes 6 12 ## 4 GP F GT3 T 1 3 yes 0 14 ## 5 GP F GT3 T 1 2 no 0 11 ## 6 GP M LE3 T 1 2 yes 6 12 ## 7 GP M LE3 T 1 2 yes 0 13 ## 8 GP F GT3 A 2 2 no 2 10 ## 9 GP M LE3 A 1 2 yes 0 15 ## 10 GP M GT3 T 1 2 yes 0 12 ## # ... with 639 more rows, and 3 more variables: G2 &lt;dbl&gt;, G3 &lt;dbl&gt;, ## # averageScore &lt;dbl&gt; Privzeto funkcija read.xlsx() odpre prvi list v datoteki in poie glavo razpredelnice. e elimo druge liste moramo podati ime lista ali tevilko lista s parametrom sheet: library(openxlsx) ocene_portugalscina &lt;- tibble(read.xlsx(&quot;./test-script/data-raw/student-performance.xlsx&quot;, sheet = 1)) ocene_matematika &lt;- tibble(read.xlsx(&quot;./test-script/data-raw/student-performance.xlsx&quot;, sheet = &quot;Math scores&quot;)) ocene_portugalscina %&gt;% select(school, G1, G2, G3, averageScore) ## # A tibble: 649 x 5 ## school G1 G2 G3 averageScore ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP 0 11 11 7.33 ## 2 GP 9 11 11 10.3 ## 3 GP 12 13 12 12.3 ## 4 GP 14 14 14 14 ## 5 GP 11 13 13 12.3 ## 6 GP 12 12 13 12.3 ## 7 GP 13 12 13 12.7 ## 8 GP 10 13 13 12 ## 9 GP 15 16 17 16 ## 10 GP 12 12 13 12.3 ## # ... with 639 more rows ocene_matematika %&gt;% select(school, G1, G2, G3, averageScore) ## # A tibble: 395 x 5 ## school G1 G2 G3 averageScore ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP 5 6 6 5.67 ## 2 GP 5 5 6 5.33 ## 3 GP 7 8 10 8.33 ## 4 GP 15 14 15 14.7 ## 5 GP 6 10 10 8.67 ## 6 GP 15 15 15 15 ## 7 GP 12 12 11 11.7 ## 8 GP 6 5 6 5.67 ## 9 GP 16 18 19 17.7 ## 10 GP 14 15 15 14.7 ## # ... with 385 more rows e ima datoteka veliko tevilo listov, jih lahko shranimo v R-jev list: library(openxlsx) path &lt;- &quot;./test-script/data-raw/student-performance.xlsx&quot; imenaListov &lt;- getSheetNames(path) ocene_s &lt;- list() for(i in 1:length(imenaListov)) { ocene_s[[i]] &lt;- tibble(read.xlsx(path)) } ocene_s ## [[1]] ## # A tibble: 649 x 12 ## school sex famsize Pstatus traveltime studytime internet absences G1 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP F GT3 A 2 2 no 4 0 ## 2 GP F GT3 T 1 2 yes 2 9 ## 3 GP F LE3 T 1 2 yes 6 12 ## 4 GP F GT3 T 1 3 yes 0 14 ## 5 GP F GT3 T 1 2 no 0 11 ## 6 GP M LE3 T 1 2 yes 6 12 ## 7 GP M LE3 T 1 2 yes 0 13 ## 8 GP F GT3 A 2 2 no 2 10 ## 9 GP M LE3 A 1 2 yes 0 15 ## 10 GP M GT3 T 1 2 yes 0 12 ## # ... with 639 more rows, and 3 more variables: G2 &lt;dbl&gt;, G3 &lt;dbl&gt;, ## # averageScore &lt;dbl&gt; ## ## [[2]] ## # A tibble: 649 x 12 ## school sex famsize Pstatus traveltime studytime internet absences G1 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP F GT3 A 2 2 no 4 0 ## 2 GP F GT3 T 1 2 yes 2 9 ## 3 GP F LE3 T 1 2 yes 6 12 ## 4 GP F GT3 T 1 3 yes 0 14 ## 5 GP F GT3 T 1 2 no 0 11 ## 6 GP M LE3 T 1 2 yes 6 12 ## 7 GP M LE3 T 1 2 yes 0 13 ## 8 GP F GT3 A 2 2 no 2 10 ## 9 GP M LE3 A 1 2 yes 0 15 ## 10 GP M GT3 T 1 2 yes 0 12 ## # ... with 639 more rows, and 3 more variables: G2 &lt;dbl&gt;, G3 &lt;dbl&gt;, ## # averageScore &lt;dbl&gt; V primeru, da je razpredelnica v excelovem listu premaknjena ali pa elimo prebrati le del podatkov, lahko uporabimo parametra startRow in cols. Preberimo samo ocene za matematiko: path &lt;- &quot;./test-script/data-raw/student-performance.xlsx&quot; ocene_math &lt;- tibble(read.xlsx(path, sheet = &quot;Math scores&quot;, startRow = 1, cols = 9:12)) ocene_math ## # A tibble: 395 x 4 ## G1 G2 G3 averageScore ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5 6 6 5.67 ## 2 5 5 6 5.33 ## 3 7 8 10 8.33 ## 4 15 14 15 14.7 ## 5 6 10 10 8.67 ## 6 15 15 15 15 ## 7 12 12 11 11.7 ## 8 6 5 6 5.67 ## 9 16 18 19 17.7 ## 10 14 15 15 14.7 ## # ... with 385 more rows Da podatke shranimo, uporabimo write.xlsx(). path &lt;- &quot;./test-script/data-raw/samo-ocene-math.xlsx&quot; write.xlsx(ocene_math, path) 3.5.2.2 SPSS SPSS je program za statistino analizo. Datoteke povezane z SPSS imajo obiajno konnico .sav. Za branje iz in uvaanje v SPSS lahko uporabimo paket haven. V mapi data_raw imamo podatke o osebah osebe.sav. Za uvoz teh podatkov v R uporabimo funkcijo read_sav. library(haven) podatki &lt;- read_sav(&quot;./data-raw/osebe.sav&quot;) podatki ## # A tibble: 5 x 5 ## Ime Visina Teza Spol Starost ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Alen 171 70 m 41 ## 2 Bojan 185 78 m 35 ## 3 Cvetka 165 64 z 28 ## 4 Dejan 190 95 m 52 ## 5 Eva 152 67 z 22 Da shranimo data frame v sav datoteko, uporabimo funkcijo write_sav(). Shranimo sedaj data frame iris v sav datoteko: write_sav(iris, &quot;./data-clean/iris.sav&quot;) Paket haven ima tudi funkcijo read_por() ki podpira stareje verzije datotek iz SPSS. 3.6 Ali elite izvedeti ve? V tem poglavju smo si ogledali operacije treh paketov tidyversa. e elite hiter in dokaj celovit pregled nad vsemi ukazi priporoamo, da si za vsak paket ogledate tako imenovan cheat sheet: stringr: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf forcats: http://www.flutterbys.com.au/stats/downloads/slides/figure/factors.pdf lubridate: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_lubridate.pdf Paket stringr uporablja paket stringi, ki ima na voljo ve operacij, ki pa niso tako pogoste. e se boste pri svojem delu sreali z zahtevnejimi nalogami, lahko uporabite ta paket. Za razumevanje regularnih izrazov in tudi avtomatsko razlago priporoamo stran https://regex101.com/. Lahko si tudi ogledate knjigo Mastering Regular Expressions (Friedl 2006), ki obseno obravnava snov regularnih izrazov. 3.7 Domaa naloga Odprite datoteko DS-jobs.csv ter spremenite spremenljivko FormalEducation v tip faktor. Nato obdrite le tiri najbolj pogoste izobrazbe, ostale pa zamenjajte z vrednostjo other. Uporabite eno izmed funkcij v skupini fct_lump. ## # A tibble: 4,523 x 4 ## Gender Country Age FormalEducation ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 Female Australia 43 Bachelor&#39;s degree ## 2 Male Russia 33 Bachelor&#39;s degree ## 3 Male Taiwan 26 Master&#39;s degree ## 4 Male United States 25 Bachelor&#39;s degree ## 5 Male United States 33 Doctoral degree ## 6 Male Czech Republic 21 Other ## 7 Male Russia 22 Bachelor&#39;s degree ## 8 Male Netherlands 51 Master&#39;s degree ## 9 Male Colombia 34 Master&#39;s degree ## 10 Male Germany 41 Other ## # ... with 4,513 more rows Na podatkih fruit uporabite str_subset in poiite: Vse sadee, ki se zanejo in konajo na samoglasnik. ## [1] &quot;apple&quot; &quot;avocado&quot; &quot;olive&quot; &quot;orange&quot; Vse sadee, ki imajo najve 5 rk. ## [1] &quot;apple&quot; &quot;date&quot; &quot;fig&quot; &quot;grape&quot; &quot;guava&quot; &quot;lemon&quot; &quot;lime&quot; &quot;mango&quot; &quot;nut&quot; ## [10] &quot;olive&quot; &quot;peach&quot; &quot;pear&quot; &quot;plum&quot; teja Vse sadee, pri katerih je prvi samoglasnik enak zadnjemu samoglasniku v besedi. Za reitev je potrebno uporabiti negacijo in skupino. ## [1] &quot;banana&quot; &quot;bell pepper&quot; &quot;blackcurrant&quot; &quot;clementine&quot; &quot;elderberry&quot; ## [6] &quot;kiwi fruit&quot; &quot;lychee&quot; &quot;nectarine&quot; &quot;papaya&quot; &quot;pomelo&quot; ## [11] &quot;rambutan&quot; &quot;rock melon&quot; &quot;satsuma&quot; Odprite prvi list ocen v student-performance.xlsx v mapi test-script/data-raw/. Odprite le stolpce school, absences, G1, G2, G3 in averageScore. Dodajte stolpec toke, ki ima vrednosti med 0 in 100, tako da ima najvija pripadajoa vrednost v averageScore vrednost 100. Dodajte stolpec ocena, kjer so vrednosti za toke med 0 in 10 enake 1, 10 in 20 enake 2 itd. Dodajte stolpec besedna_ocena tipa faktor, ki bo imel vrednosti glede na oceno in sicer ocene &lt;6 = nezadostno, 6 = zadostno, 7 = v redu 8 = dobro, 9 = zelo dobro in 10 = odlino. Zdruite vrednosti v redu in dobro v eno vrednost dobro. ## # A tibble: 649 x 9 ## school absences G1 G2 G3 averageScore toke ocena besedna_ocena ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 GP 4 0 11 11 7.33 39.3 4 nezadostno ## 2 GP 2 9 11 11 10.3 55.4 6 zadostno ## 3 GP 6 12 13 12 12.3 66.1 7 v redu ## 4 GP 0 14 14 14 14 75 8 dobro ## 5 GP 0 11 13 13 12.3 66.1 7 v redu ## 6 GP 6 12 12 13 12.3 66.1 7 v redu ## 7 GP 0 13 12 13 12.7 67.9 7 v redu ## 8 GP 2 10 13 13 12 64.3 7 v redu ## 9 GP 0 15 16 17 16 85.7 9 zelo dobro ## 10 GP 0 12 12 13 12.3 66.1 7 v redu ## # ... with 639 more rows Shranite podatke v datoteko students-performance-math-normalized.xlsx' in v binarno datotekostudents-performance-math-normalized.rds. Ponovno preberite obe datoteki, prvo v spremenljivko podatki_excel in drugo v podatki_binarni. Prvo tudi spremenit v tibble. Katero razliko opazite? ## # A tibble: 649 x 9 ## school absences G1 G2 G3 averageScore toke ocena besedna_ocena ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 GP 4 0 11 11 7.33 39.3 4 nezadostno ## 2 GP 2 9 11 11 10.3 55.4 6 zadostno ## 3 GP 6 12 13 12 12.3 66.1 7 v redu ## 4 GP 0 14 14 14 14 75 8 dobro ## 5 GP 0 11 13 13 12.3 66.1 7 v redu ## 6 GP 6 12 12 13 12.3 66.1 7 v redu ## 7 GP 0 13 12 13 12.7 67.9 7 v redu ## 8 GP 2 10 13 13 12 64.3 7 v redu ## 9 GP 0 15 16 17 16 85.7 9 zelo dobro ## 10 GP 0 12 12 13 12.3 66.1 7 v redu ## # ... with 639 more rows ## # A tibble: 649 x 9 ## school absences G1 G2 G3 averageScore toke ocena besedna_ocena ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 GP 4 0 11 11 7.33 39.3 4 nezadostno ## 2 GP 2 9 11 11 10.3 55.4 6 zadostno ## 3 GP 6 12 13 12 12.3 66.1 7 v redu ## 4 GP 0 14 14 14 14 75 8 dobro ## 5 GP 0 11 13 13 12.3 66.1 7 v redu ## 6 GP 6 12 12 13 12.3 66.1 7 v redu ## 7 GP 0 13 12 13 12.7 67.9 7 v redu ## 8 GP 2 10 13 13 12 64.3 7 v redu ## 9 GP 0 15 16 17 16 85.7 9 zelo dobro ## 10 GP 0 12 12 13 12.3 66.1 7 v redu ## # ... with 639 more rows Naloite paket nycflights13 s podatki letov. V tej bazi je ve razpredelnic in sicer flights, airlines, planes, airports in weather. Za razumevanje si pomagajte z ?flights. Izpiite vsa letalia, ki imajo 3 ali ve besed v svojem imenu. ## # A tibble: 837 x 8 ## faa name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 06A Moton Field Municipal Ai~ 32.5 -85.7 264 -6 A America/Chica~ ## 2 09J Jekyll Island Airport 31.1 -81.4 11 -5 A America/New_Y~ ## 3 0A9 Elizabethton Municipal A~ 36.4 -82.2 1593 -5 A America/New_Y~ ## 4 0G6 Williams County Airport 41.5 -84.5 730 -5 A America/New_Y~ ## 5 0G7 Finger Lakes Regional Ai~ 42.9 -76.8 492 -5 A America/New_Y~ ## 6 0P2 Shoestring Aviation Airf~ 39.8 -76.6 1000 -5 U America/New_Y~ ## 7 0S9 Jefferson County Intl 48.1 -123. 108 -8 A America/Los_A~ ## 8 0W3 Harford County Airport 39.6 -76.2 409 -5 A America/New_Y~ ## 9 10C Galt Field Airport 42.4 -88.4 875 -6 U America/Chica~ ## 10 17G Port Bucyrus-Crawford Co~ 40.8 -83.0 1003 -5 A America/New_Y~ ## # ... with 827 more rows Teja Spremenite imena letali tako, da odstranite besedi Airport ali Airfield iz konca imena. ## # A tibble: 1,458 x 8 ## faa name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 04G &quot;Lansdowne &quot; 41.1 -80.6 1044 -5 A America/New_York ## 2 06A &quot;Moton Field Municipal~ 32.5 -85.7 264 -6 A America/Chicago ## 3 06C &quot;Schaumburg Regional&quot; 42.0 -88.1 801 -6 A America/Chicago ## 4 06N &quot;Randall &quot; 41.4 -74.4 523 -5 A America/New_York ## 5 09J &quot;Jekyll Island &quot; 31.1 -81.4 11 -5 A America/New_York ## 6 0A9 &quot;Elizabethton Municipa~ 36.4 -82.2 1593 -5 A America/New_York ## 7 0G6 &quot;Williams County &quot; 41.5 -84.5 730 -5 A America/New_York ## 8 0G7 &quot;Finger Lakes Regional~ 42.9 -76.8 492 -5 A America/New_York ## 9 0P2 &quot;Shoestring Aviation &quot; 39.8 -76.6 1000 -5 U America/New_York ## 10 0S9 &quot;Jefferson County Intl&quot; 48.1 -123. 108 -8 A America/Los_Ang~ ## # ... with 1,448 more rows Za vsak let sestavite besedno poroilo spodnje oblike, ki ga shranite v stolpec Poroilo leta. Besedilo naj se glasi: Let iz letalisca Newark Liberty Intl dne 22.01.13 ob 11:00 v letalisce George Bush Intercontinental je imel 2 minut zamude v odhodu in 11 v prihodu. Minute so lahko tudi negativne. ## # A tibble: 336,776 x 2 ## `Poroilo leta` dep_string ## &lt;chr&gt; &lt;dttm&gt; ## 1 Let iz letalisca Newark Liberty Intl, dne 01.01.13, ob 0~ 2013-01-01 05:15:00 ## 2 Let iz letalisca La Guardia, dne 01.01.13, ob 05:29 v le~ 2013-01-01 05:29:00 ## 3 Let iz letalisca John F Kennedy Intl, dne 01.01.13, ob 0~ 2013-01-01 05:40:00 ## 4 &lt;NA&gt; 2013-01-01 05:45:00 ## 5 Let iz letalisca La Guardia, dne 01.01.13, ob 06:00 v le~ 2013-01-01 06:00:00 ## 6 Let iz letalisca Newark Liberty Intl, dne 01.01.13, ob 0~ 2013-01-01 05:58:00 ## 7 Let iz letalisca Newark Liberty Intl, dne 01.01.13, ob 0~ 2013-01-01 06:00:00 ## 8 Let iz letalisca La Guardia, dne 01.01.13, ob 06:00 v le~ 2013-01-01 06:00:00 ## 9 Let iz letalisca John F Kennedy Intl, dne 01.01.13, ob 0~ 2013-01-01 06:00:00 ## 10 Let iz letalisca La Guardia, dne 01.01.13, ob 06:00 v le~ 2013-01-01 06:00:00 ## # ... with 336,766 more rows asi odhodov in prihodov so v razpredelnici flights v lokalnem asu. Dodajte spremenljivko dep_time_utc, ki bo vsebovala vrednost odhoda v asovnem pasu UTC. Zapis naj bo oblike integer, tako kot `dep_time. ## # A tibble: 336,776 x 8 ## year month day dep_time dep_time_utc origin dest tzone ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 517 1017 EWR IAH America/New_York ## 2 2013 1 1 533 1033 LGA IAH America/New_York ## 3 2013 1 1 542 1042 JFK MIA America/New_York ## 4 2013 1 1 544 1044 JFK BQN America/New_York ## 5 2013 1 1 554 1054 LGA ATL America/New_York ## 6 2013 1 1 554 1054 EWR ORD America/New_York ## 7 2013 1 1 555 1055 EWR FLL America/New_York ## 8 2013 1 1 557 1057 LGA IAD America/New_York ## 9 2013 1 1 557 1057 JFK MCO America/New_York ## 10 2013 1 1 558 1058 LGA ORD America/New_York ## # ... with 336,766 more rows Simuliramo. Vsi leti bodo zaradi nepriakovane prenove letalia po 23. 10. 2013 zamaknjeni za dva tedna. Izpiite posodobljene datume v originalni obliki (year, month, day). ## # A tibble: 63,797 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 6 454 500 -6 632 648 ## 2 2013 11 6 512 517 -5 749 757 ## 3 2013 11 6 541 545 -4 837 827 ## 4 2013 11 6 544 545 -1 935 933 ## 5 2013 11 6 545 550 -5 930 932 ## 6 2013 11 6 546 545 1 856 855 ## 7 2013 11 6 549 600 -11 711 716 ## 8 2013 11 6 549 600 -11 900 858 ## 9 2013 11 6 550 600 -10 716 717 ## 10 2013 11 6 552 600 -8 735 751 ## # ... with 63,787 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; "]]
