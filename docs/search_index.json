[["slovnica-urejanja-podatkov.html", "Poglavje 1 Slovnica urejanja podatkov 1.1 Priprava 1.2 Sodobna razpredelnica: tibble 1.3 Urejeno ovrednotenje 1.4 Izbira vrstic s filter() 1.5 Izbira stolpcev s select() 1.6 Urejanje vrstic z arrange() 1.7 Dodajanje novih spremenljivk z mutate() 1.8 Povzemanje vrednosti s summarise() 1.9 Pipe 1.10 filter() in mutate() na zdruenih podatkih 1.11 Izvajanje operacij nad veimi stolpci z across() 1.12 Povzemanje stolpcev 1.13 Povzemanje vrstic 1.14 Dodatek 1.15 Ali elite izvedeti ve? 1.16 Domaa naloga", " Poglavje 1 Slovnica urejanja podatkov V tem predavanju se bomo osredotoili na temeljne operacije, ki jih izvajamo nad podatki. Te operacije so nepogreljive pri vsaki analizi: izbira podmnoice vrstic, izbira podmnoice stolpcev, dodajanje stolpcev, ki so lahko izpeljani iz obstojeih stolpcev, urejanje razpredelnice glede na vrednosti stolpcev, povzemanje razpredelnic, na primer povpreja in vsote. Paket dplyr vsebuje funkcije, ki nam v primerjavi z osnovno razliico R-ja, te operacije olajajo. Paket dplyr uvede t. i. slovnico urejanja podatkov (ang. grammar of data manipulation), ki programsko kodo pretvori v nekaj podobnega naravnemu jeziku. Pri slovnici urejanja podatkov poznamo 5 osnovnih glagolov, s katerimi preoblikujemo podatke. Vsak glagol ustreza eni izmed temeljnih operacij, ki smo jih omenili zgoraj. Programska koda se potem bere podobno kot naravni jezik  glagoli programskemu jeziku povedo, kaj naj s podatki naredi. Ti glagoli so implementirani v obliki funkcij: filter() Izbira podmnoice vrstic glede na izbrane pogoje. select() Izbira podmnoice stolpcev, glede na imena stolpcev. mutate() Dodajanje stolpcev, ki so lahko izpeljani iz obstojeih stolpcev. summarise() Povzemanje podatkov v razpredelnici. arrange() Urejanje razpredelnice. V tem predavanju bomo bolj podrobno spoznali vsakega izmed teh glagolov. Po tem pa si bomo ogledali e dva uporabna povzetka  povzemanje po vrsticah in povzemanje po stolpcih. .fold-btn { float: right; margin: 5px 5px 0 0; } .fold { border: 1px solid black; min-height: 40px; } 1.1 Priprava V pripravi se bomo nauili osnovnih klicev petih glagolov iz slovnice urejanja podatkov. Hkrati bomo primerjali osnovno razliico R-ja z uporabo paketa dplyr. Pripravimo si podatke: library(tidyverse) # Nalozimo celotno zbirko paketov tidyverse. df &lt;- data.frame( ime = c(&quot;Maja&quot;, &quot;Ales&quot;, &quot;Tom&quot;, &quot;Barbara&quot;, &quot;Simon&quot;, &quot;Tina&quot;), spol = c(&quot;z&quot;, &quot;m&quot;, &quot;m&quot;, &quot;z&quot;, &quot;m&quot;, &quot;z&quot;), starost = c(23, 54, 21, 35, 53, 21), visina = c(170, 180, 192, 168, 177, 182) ) S funkcijo filter() izberemo podmnoico vrstic v razpredelnici glede na izbrane pogoje. Izberimo enske nije od 180 centimetrov. # Osnovni R: df[df$spol == &quot;z&quot; &amp; df$visina &lt; 180, ] ## ime spol starost visina ## 1 Maja z 23 170 ## 4 Barbara z 35 168 # dplyr: filter(df, spol == &quot;z&quot;, visina &lt; 180) ## ime spol starost visina ## 1 Maja z 23 170 ## 2 Barbara z 35 168 Opazimo, da z uporabo dplyr ni potrebno vsaki pisati df$ pred imenom spremenljivke. Tukaj gre za t. i. maskiranje podatkov (ang. data masking). Ve o tem v jedru poglavja. S funkcijo select() izberemo podmnoico stolpcev. Izberimo stolpce ime, spol in visina: # Osnovni R: df[ , c(&quot;ime&quot;, &quot;spol&quot;, &quot;visina&quot;)] ## ime spol visina ## 1 Maja z 170 ## 2 Ales m 180 ## 3 Tom m 192 ## 4 Barbara z 168 ## 5 Simon m 177 ## 6 Tina z 182 # dplyr: select(df, ime, spol, visina) ## ime spol visina ## 1 Maja z 170 ## 2 Ales m 180 ## 3 Tom m 192 ## 4 Barbara z 168 ## 5 Simon m 177 ## 6 Tina z 182 Opazimo, da nam pri uporabi dplyr stolpcev ni potrebno pisati v narekovajih. Tukaj gre za t. i. urejeno izbiranje (ang. tidy selection). Ve o tem v jedru poglavja. S funkcijo mutate() dodajamo stolpce. Dodajmo viino v metrih: # Osnovni R: df2 &lt;- df df2$visina_v_metrih &lt;- df2$visina / 100 df2 ## ime spol starost visina visina_v_metrih ## 1 Maja z 23 170 1.70 ## 2 Ales m 54 180 1.80 ## 3 Tom m 21 192 1.92 ## 4 Barbara z 35 168 1.68 ## 5 Simon m 53 177 1.77 ## 6 Tina z 21 182 1.82 # dplyr: mutate(df, visina_v_metrih = visina / 100) ## ime spol starost visina visina_v_metrih ## 1 Maja z 23 170 1.70 ## 2 Ales m 54 180 1.80 ## 3 Tom m 21 192 1.92 ## 4 Barbara z 35 168 1.68 ## 5 Simon m 53 177 1.77 ## 6 Tina z 21 182 1.82 S funkcijo arrange() urejamo razpredelnico. Uredimo osebe po starosti: # Osnovni R: df[order(df$starost), ] ## ime spol starost visina ## 3 Tom m 21 192 ## 6 Tina z 21 182 ## 1 Maja z 23 170 ## 4 Barbara z 35 168 ## 5 Simon m 53 177 ## 2 Ales m 54 180 # dplyr: arrange(df, starost) ## ime spol starost visina ## 1 Tom m 21 192 ## 2 Tina z 21 182 ## 3 Maja z 23 170 ## 4 Barbara z 35 168 ## 5 Simon m 53 177 ## 6 Ales m 54 180 S funkcijo summarise() povzamemo podatke. Obiajno se uporablja v kombinaciji z group_by(). Izraunajmo povpreno viino glede na spol: # Osnovni R: aggregate(visina ~ spol, data = df, FUN = mean) ## spol visina ## 1 m 183.0000 ## 2 z 173.3333 # dplyr: summarise(group_by(df, spol), povp_visina = mean(visina)) ## # A tibble: 2 x 2 ## spol povp_visina ## &lt;chr&gt; &lt;dbl&gt; ## 1 m 183 ## 2 z 173. Naloga: Poglejmo si nov primer podatkov. df &lt;- data.frame( podjetje = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;), panoga = c(&quot;proizvodnja&quot;, &quot;gostinstvo&quot;, &quot;proizvodnja&quot;, &quot;gostinstvo&quot;, &quot;proizvodnja&quot;), st_zaposlenih = c(100, 20, 110, 15, 20), dobicek = c(100000, 10000, 12000, 1000, 0) ) Z uporabo dplyr: Izberite vrstice, ki imajo med (vkljuno) 10000 in 20000 dobika. ## podjetje panoga st_zaposlenih dobicek ## 1 B gostinstvo 20 10000 ## 2 C proizvodnja 110 12000 Izberite drugi in etrti stolpec. ## panoga dobicek ## 1 proizvodnja 100000 ## 2 gostinstvo 10000 ## 3 proizvodnja 12000 ## 4 gostinstvo 1000 ## 5 proizvodnja 0 Dodajte stolpec, ki bo prikazal dobiek na zaposlenega. ## podjetje panoga st_zaposlenih dobicek dobicek_na_zaposlenega ## 1 A proizvodnja 100 100000 1000.00000 ## 2 B gostinstvo 20 10000 500.00000 ## 3 C proizvodnja 110 12000 109.09091 ## 4 D gostinstvo 15 1000 66.66667 ## 5 E proizvodnja 20 0 0.00000 Uredite podjetja po tevilu zaposlenih. ## podjetje panoga st_zaposlenih dobicek ## 1 D gostinstvo 15 1000 ## 2 B gostinstvo 20 10000 ## 3 E proizvodnja 20 0 ## 4 A proizvodnja 100 100000 ## 5 C proizvodnja 110 12000 Poiite maksimalno tevilo zaposlenih glede na panogo. ## # A tibble: 2 x 2 ## panoga max_st_zaposlenih ## &lt;chr&gt; &lt;dbl&gt; ## 1 gostinstvo 20 ## 2 proizvodnja 110 1.2 Sodobna razpredelnica: tibble Najprej si poglejmo podatke, na katerih se bomo nauili osnovnih konceptov slovnice urejanja podatkov. V mapi data-raw se nahajajo podatki DS-jobs.csv. Gre za rezultate ankete, ki so jo v povezavi z industrijo izvedli na spletni strani Kaggle (https://www.kaggle.com/kaggle/kaggle-survey-2017) leta 2017 z namenom raziskati trg dela na podroju podatkovnih ved in strojnega uenja. Podatki so shranjeni v tekstovni datoteki, kjer so elementi loeni s podpijem. Preberimo podatke v nao sejo R: ds_jobs &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) head(ds_jobs) ## Gender Country Age EmploymentStatus ## 1 Female Australia 43 Employed full-time ## 2 Male Russia 33 Employed full-time ## 3 Male Taiwan 26 Employed full-time ## 4 Male United States 25 Employed part-time ## 5 Male United States 33 Employed full-time ## 6 Male Czech Republic 21 Employed part-time ## CurrentJobTitle LanguageRecommendation ## 1 Business Analyst Python ## 2 Software Developer/Software Engineer Python ## 3 Software Developer/Software Engineer Python ## 4 Researcher Python ## 5 Scientist/Researcher Matlab ## 6 Other Python ## FormalEducation ## 1 Bachelor&#39;s degree ## 2 Bachelor&#39;s degree ## 3 Master&#39;s degree ## 4 Bachelor&#39;s degree ## 5 Doctoral degree ## 6 Some college/university study without earning a bachelor&#39;s degree ## Major CompensationAmount CompensationCurrency ## 1 80000 AUD ## 2 Other 1200000 RUB ## 3 Computer Science 1100000 TWD ## 4 Physics 20000 USD ## 5 Electrical Engineering 100000 USD ## 6 Computer Science 20000 CZK ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 1 60 10 5 15 ## 2 40 30 15 10 ## 3 35 20 25 10 ## 4 0 80 0 20 ## 5 0 0 0 0 ## 6 20 60 20 0 ## TimeFindingInsights TimeOtherSelect ExchangeRate ## 1 10 0 0.802310 ## 2 5 0 0.017402 ## 3 10 0 0.033304 ## 4 0 0 1.000000 ## 5 0 0 1.000000 ## 6 0 0 0.045820 Spremenljivka ds_jobs je tipa data.frame. To je osnovna oblika, v kateri v R hranimo razpredelnice. V tidyverse obstaja paket tibble, ki je namenjen sodobni predstavitvi razpredelnice. Glavna funkcionalnost tega paketa je objekt tibble, ki predstavlja nadgradnjo data frame. V preostanku knjige bomo za objekte data.frame uporabljali izraz data frame in za objekte tipa tibble izraz tibble. Veina funkcij v tidyverse sicer lahko kot vhodni podatek prejme data frame, ampak ga nekatere potem samodejno pretvorijo v tibble. Kot dobro prakso predlagamo delo izkljuno s tibble. Poleg kompatibilnosti s funkcijami tidyverse je e nekaj drugih razlik v primerjavi z data frame, veino le-teh bomo spoznali v preostanku knjige. Pretvorimo sedaj ta data frame v tibble s funkcijo as_tibble(). library(tidyverse) ds_jobs &lt;- as_tibble(ds_jobs) ds_jobs ## # A tibble: 4,523 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Netherl~ 51 Employed full-time Engineer R ## 9 Male Colombia 34 Employed full-time Data Scientist Python ## 10 Male Germany 41 Independent contrac~ Data Scientist Python ## # ... with 4,513 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Opazimo, da je oblika prikaza podatkov sedaj nekoliko drugana. Najbolj oitna razlika je, da imamo na zaslonu prikazanih samo toliko stolpcev, kot jih je mono prikazati na zaslonu. Preostali stolpci so samo zapisani zaporedno z imeni, da lahko vidimo, katere stolpce e imamo v podatkih. S tem prepreimo, da bi izpis postal nepregleden. e vedno lahko vidimo vse oziroma ve stolpcev z uporabo View() ali pa e tibble izpiemo s pomojo print() in ustrezno nastavitvijo irine, na primer print(ds_jobs, width = 120). Izpis tibble pa nam nudi e nekaj dodatnih informacij v primerjavi z data frame. V prvi vrstici imamo izpisano dimenzijo podatkov  tevilo vrstic in tevilo stolpcev. Pod vsako spremenljivko je zapisan tudi njen tip. Tibble tudi dopua imena stolpcev, ki niso standardna za R (na primer vsebujejo - in podobno), eprav uporaba takih imen ni dobra praksa. Ve o tem bomo povedali kasneje. 1.3 Urejeno ovrednotenje Preden zanemo resneje delati z glagoli slovnice urejanja podatkov, spoznajmo t. i. urejeno ovrednotenje (ang. tidy evaluation). To je posebnost tidyverse in veina glagolov v dplyr ga uporablja. Kaj pa je urejeno ovrednotenje? To je nestandarden pristop k ovrednotenju izrazov v programskem jeziku R. V predpripravi smo e sreali dva primera: Pri funkciji filter() ni bilo potrebno vsaki navesti df$ za izbiro spremenljivk iz razpredelnice. Pri funkciji select() nismo potrebovali narekovajev. Oba sta primera dveh vrst urejenega ovrednotenja: Pri nekaterih glagolih v dplyr lahko uporabimo spremenljivke (stolpce) tibbla (ali razpredelnice), kot da bi bile spremenljivke v globalnem okolju (torej lahko uporabimo moja_spremenljivka namesto df$moja_spremenljivka). Temu pravimo maskiranje podatkov (ang. data masking). Funkcije, ki podpirajo to strukturo in jih bomo spoznali v nadaljevanju so: arrange(), count(), filter(), group_by(), mutate() in summarise(). Pri nekaterih glagolih v dplyr lahko na laji nain izberemo spremenljivke (stolpce) glede na njihovo pozicijo, ime ali tip (na primer izbira stolpcev po imenu brez narekovajev, izbira stolpcev ki se zanejo na doloen niz, izbira samo tevilskih stolpcev). Temu pravimo urejeno izbiranje (ang. tidy selection). Funkcije, ki podpirajo to strukturo so: across(), count(), rename(), select() in pull(). Informacije o tem, ali funkcija vsebuje maskiranje podatkov ali urejeno izbiranje, lahko najdemo v datoteki s pomojo pod razdelkom Arguments. 1.4 Izbira vrstic s filter() S funkcijo filter() izbiramo podmnoico vrstic glede na izbrane pogoje. Sintaksa je: filter(&lt;tibble&gt;, &lt;pogoj1&gt;, &lt;pogoj2&gt;, ...) Kot prvi argument podamo tibble s podatki, potem pa z vejicami loene pogoje. Izberimo vse osebe mlaje od 30 let: library(dplyr) filter(ds_jobs, Age &lt; 30) ## # A tibble: 1,729 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Taiwan 26 Employed full-t~ Software Developer~ Python ## 2 Male United S~ 25 Employed part-t~ Researcher Python ## 3 Male Czech Re~ 21 Employed part-t~ Other Python ## 4 Male Russia 22 Employed full-t~ Data Analyst Python ## 5 Male Poland 29 Employed full-t~ Software Developer~ Python ## 6 Male Other 28 Employed full-t~ Data Scientist R ## 7 Male Mexico 26 Employed part-t~ Data Scientist Python ## 8 Male Singapore 24 Employed full-t~ Data Analyst Python ## 9 Male India 29 Employed full-t~ Data Scientist R ## 10 Male United S~ 25 Employed full-t~ Engineer Python ## # ... with 1,719 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Ve pogojev loimo z vejico, kadar elimo, da veljajo vsi pogoji (enakovredno uporabi operatorja in  &amp; pri natevanju pogojev). Poglejmo si vse osebe mlaje od 30 let, ki prihajajo iz Nemije: filter(ds_jobs, Age &lt; 30, Country == &quot;Germany&quot;) ## # A tibble: 42 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Germany 24 Employed part-time Scientist/Resear~ R ## 2 Male Germany 28 Employed full-time Scientist/Resear~ Python ## 3 Male Germany 24 Independent contract~ Data Scientist Python ## 4 Female Germany 29 Employed full-time Business Analyst SQL ## 5 Male Germany 26 Employed part-time Researcher Python ## 6 Male Germany 27 Employed full-time Data Scientist Python ## 7 Female Germany 26 Employed part-time Statistician R ## 8 Male Germany 26 Independent contract~ Data Scientist Python ## 9 Male Germany 29 Employed full-time Machine Learning~ Python ## 10 Male Germany 25 Employed full-time Data Scientist Python ## # ... with 32 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; V kolikor elimo, da velja vsaj eden izmed pogojev, moramo uporabiti operator ali  |. Poglejmo si vse osebe mlaje od 30 ali stareje od 50 let: filter(ds_jobs, Age &lt; 30 | Age &gt; 50) ## # A tibble: 2,006 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Taiwan 26 Employed full-t~ Software Developer~ Python ## 2 Male United S~ 25 Employed part-t~ Researcher Python ## 3 Male Czech Re~ 21 Employed part-t~ Other Python ## 4 Male Russia 22 Employed full-t~ Data Analyst Python ## 5 Male Netherla~ 51 Employed full-t~ Engineer R ## 6 Male Poland 29 Employed full-t~ Software Developer~ Python ## 7 Male Other 28 Employed full-t~ Data Scientist R ## 8 Male Mexico 26 Employed part-t~ Data Scientist Python ## 9 Male Singapore 24 Employed full-t~ Data Analyst Python ## 10 Male India 29 Employed full-t~ Data Scientist R ## # ... with 1,996 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; e elimo nek kategorini stolpec pogojiti z veimi vrednostmi (na primer udeleence iz veih drav), lahko namesto veih | uporabimo operator %in%, ki preveri, e je element del mnoice: filter(ds_jobs, Country %in% c(&quot;Germany&quot;, &quot;Canada&quot;, &quot;Ireland&quot;)) ## # A tibble: 306 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Germany 41 Independent contrac~ Data Scientist Python ## 2 Female Germany 49 Employed part-time Scientist/Resea~ Python ## 3 Male Germany 44 Employed full-time Other Python ## 4 A diffe~ Canada 23 Employed full-time Scientist/Resea~ Python ## 5 Female Germany 24 Employed part-time Scientist/Resea~ R ## 6 Male Canada 52 Employed full-time Software Develo~ Python ## 7 Male Ireland 27 Employed full-time Data Scientist Python ## 8 Male Canada 24 Employed full-time Business Analyst Python ## 9 Male Canada 46 Employed full-time Data Scientist Python ## 10 Male Canada 31 Employed full-time Data Analyst R ## # ... with 296 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; 1.4.1 Manjkajoe vrednosti Vrstice pogosto filtriramo na podlagi manjkajoih vrednosti. Vasih so te pomembne za samo analizo, saj nas lahko zanimajo razlogi za njihov pojav. Vasih pa so to nepomembne vrstice, saj nam ne prinesejo dodatne informacije. V tem primeru jih obiajno kar izloimo iz nadaljnje analize. V nadaljevanju bomo spoznali, kako dodati nov stolpec, in to ilustrirali na izraunu plae v dolarjih. Za to bomo potrebovali stolpca CompensationAmount in ExchangeRate. V slednjem je kar nekaj manjkajoih vrednosti. Takne vrstice bodo za analizo pla neuporabne, zato jih bomo sedaj izloili iz podatkov. Ali je vrednost enaka NA (objekt, ki predstavlja manjkajoo vrednost v R) preverimo s funkcijo is.na(). Izloimo sedaj te vrstice: ds_jobs &lt;- filter(ds_jobs, !is.na(ExchangeRate)) Podobno kot v zgornjem primeru lahko v pogoju nastopa poljubna funkcija. 1.5 Izbira stolpcev s select() S funkcijo select() izbiramo podmnoico stolpcev. Osnovna sintaksa je: filter(&lt;tibble&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ...) Izberimo sedaj stolpce Country, Age in EmploymentStatus. select(ds_jobs, Country, Age, EmploymentStatus) ## # A tibble: 3,781 x 3 ## Country Age EmploymentStatus ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Australia 43 Employed full-time ## 2 Russia 33 Employed full-time ## 3 Taiwan 26 Employed full-time ## 4 United States 25 Employed part-time ## 5 United States 33 Employed full-time ## 6 Czech Republic 21 Employed part-time ## 7 Russia 22 Employed full-time ## 8 Colombia 34 Employed full-time ## 9 Germany 41 Independent contractor, freelancer, or self-employed ## 10 Poland 29 Employed full-time ## # ... with 3,771 more rows Izberimo vse stolpce razen teh treh stolpcev. Za to enostavno dodamo minus pred imenom stolpca, ki ga elimo izloiti: select(ds_jobs, -Country, -Age, -EmploymentStatus) ## # A tibble: 3,781 x 14 ## Gender CurrentJobTitle LanguageRecommen~ FormalEducation Major ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Business Analyst Python Bachelor&#39;s degree &quot;&quot; ## 2 Male Software Develope~ Python Bachelor&#39;s degree &quot;Other&quot; ## 3 Male Software Develope~ Python Master&#39;s degree &quot;Computer ~ ## 4 Male Researcher Python Bachelor&#39;s degree &quot;Physics&quot; ## 5 Male Scientist/Researc~ Matlab Doctoral degree &quot;Electrica~ ## 6 Male Other Python Some college/univers~ &quot;Computer ~ ## 7 Male Data Analyst Python Bachelor&#39;s degree &quot;Informati~ ## 8 Male Data Scientist Python Master&#39;s degree &quot;Computer ~ ## 9 Male Data Scientist Python I did not complete a~ &quot;&quot; ## 10 Male Software Develope~ Python Master&#39;s degree &quot;Computer ~ ## # ... with 3,771 more rows, and 9 more variables: CompensationAmount &lt;dbl&gt;, ## # CompensationCurrency &lt;chr&gt;, TimeGatheringData &lt;int&gt;, ## # TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, TimeVisualizing &lt;dbl&gt;, ## # TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ExchangeRate &lt;dbl&gt; Izberimo vse stolpce med Country in Major. Podobno kot v R 1:10 nateje vsa cela tevila med 1 in 10, operator : v tidyverse izbere vse stolpce med Country in Major: select(ds_jobs, Country:Major) ## # A tibble: 3,781 x 7 ## Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Australia 43 Employed full-time Business Analyst Python ## 2 Russia 33 Employed full-time Software Developer~ Python ## 3 Taiwan 26 Employed full-time Software Developer~ Python ## 4 United S~ 25 Employed part-time Researcher Python ## 5 United S~ 33 Employed full-time Scientist/Research~ Matlab ## 6 Czech Re~ 21 Employed part-time Other Python ## 7 Russia 22 Employed full-time Data Analyst Python ## 8 Colombia 34 Employed full-time Data Scientist Python ## 9 Germany 41 Independent contractor~ Data Scientist Python ## 10 Poland 29 Employed full-time Software Developer~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; Izberimo vse stolpce, ki se zanejo z besedo Time. Za to bomo uporabili funkcijo starts_with(). Ta funkcija je t. i. selection helper, kar pomeni, da jo lahko uporabimo le znotraj funkcij, ki omogoajo urejeno ovrednotenje in nam omogoa lajo izbiro na podlagi nekega pogoja. V tem primeru je ta pogoj, da se beseda zane na doloen niz: select(ds_jobs, starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 6 ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 60 10 5 15 ## 2 40 30 15 10 ## 3 35 20 25 10 ## 4 0 80 0 20 ## 5 0 0 0 0 ## 6 20 60 20 0 ## 7 50 20 10 5 ## 8 60 10 20 5 ## 9 50 10 20 10 ## 10 25 20 25 20 ## # ... with 3,771 more rows, and 2 more variables: TimeFindingInsights &lt;dbl&gt;, ## # TimeOtherSelect &lt;int&gt; Poleg starts_with() dplyr vsebuje e ve taknih funkcij: ends_with() Ali se ime stolpca kona na doloen niz? contains() Ali ime stolpca vsebuje niz? matches() Ali ime stolpca ustreza regularnemu izrazu? Ve o regularnih izrazih bomo povedali v 3. predavanju. num_range() Ali ime stolpca vsebuje tevila znotraj mnoice tevil? Na primer, e imamo stolpce, ki v imenu vsebujejo tevila  stolpec1, stolpec2, in tako naprej. 1.6 Urejanje vrstic z arrange() Vrstice lahko tudi uredimo glede na vrednosti v posameznih stolpcih. Za to uporabimo funkcijo arrange(). Sintaksa te funkcije je: filter(&lt;tibble&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ...) kjer stolpci predstavljajo vrednosti, po katerih elimo urediti tibble. Ustvarimo najprej nov tibble, v katerem bomo izbrali podmnoico stolpcev. ds_jobs_tmp &lt;- select(ds_jobs, CurrentJobTitle, Country, CompensationCurrency, Age, CompensationAmount) Uredimo sedaj podatke glede na leta: arrange(ds_jobs_tmp, Age) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Predictive Modeler Australia AUD 0 78000 ## 2 Scientist/Researcher United St~ USD 1 100000 ## 3 Programmer Other GBP 11 0 ## 4 Data Scientist United St~ USD 16 50000 ## 5 Software Developer/Soft~ Russia USD 18 40000 ## 6 Programmer Other USD 18 1000 ## 7 Machine Learning Engine~ Other USD 19 30000 ## 8 Programmer Russia USD 19 40000 ## 9 Scientist/Researcher Canada CAD 19 0 ## 10 Computer Scientist Brazil BRL 19 400 ## # ... with 3,771 more rows Opazimo, da imamo nekaj neveljavnih starosti, na primer 0 in 1, najverjetneje tudi 11. Prav tako imamo nekaj nesmiselnih vrednosti v stolpcu o plai. Pri celostni analizi bi seveda raziskali, zakaj je prilo do takih vrednosti, oziroma bi jih izloili iz analize. Za namen spoznavanja urejanja podatkov in dplyr to ni pomembno, tako da temu ne bomo posveali pozornosti. Bralcem pa predlagamo, naj razmislijo, kako bi se tega lotili z e nauenimi koncepti. e elimo podatke urediti padajoe, potem uporabimo funkcijo desc(): arrange(ds_jobs_tmp, desc(Age)) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Statistician United Ki~ ILS 100 100000000000 ## 2 Other Other EUR 99 15000 ## 3 Researcher Portugal EUR 78 63000 ## 4 Data Scientist Canada USD 75 110 ## 5 Software Developer/Soft~ Netherlan~ EUR 73 40000 ## 6 Data Analyst Russia USD 70 14000 ## 7 Business Analyst United St~ USD 70 130000 ## 8 Machine Learning Engine~ United Ki~ GBP 70 40000 ## 9 Scientist/Researcher United St~ USD 69 200000 ## 10 Business Analyst United St~ USD 68 125000 ## # ... with 3,771 more rows Uredimo lahko tudi glede na ve stolpcev, kjer se najprej uredi po prvem zapisanem, nato drugem, itd.: arrange(ds_jobs_tmp, Age, CompensationAmount) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Predictive Modeler Australia AUD 0 78000 ## 2 Scientist/Researcher United St~ USD 1 100000 ## 3 Programmer Other GBP 11 0 ## 4 Data Scientist United St~ USD 16 50000 ## 5 Programmer Other USD 18 1000 ## 6 Software Developer/Soft~ Russia USD 18 40000 ## 7 Scientist/Researcher Canada CAD 19 0 ## 8 Computer Scientist Brazil BRL 19 400 ## 9 Machine Learning Engine~ Other USD 19 30000 ## 10 Programmer Russia USD 19 40000 ## # ... with 3,771 more rows 1.7 Dodajanje novih spremenljivk z mutate() Pogosto elimo ustvariti nove stolpce, ki so izpeljani iz obstojeih stolpcev. Pri naih podatkih imamo stolpec CompensationAmount, ki predstavlja letno plao in ExchangeRate, ki predstavlja menjalni teaj lokalne valute v ameriki dolar. e elimo imeti primerljive podatke, moramo izraunati vrednosti v dolarjih za vse podatke. Za to uporabimo funkcijo mutate(), ki doda stolpec (ali ve stolpcev). Sintaksa funkcije je: &lt;tibble&gt; &lt;- mutate(&lt;tibble&gt;, &lt;ime-novega-stolpca&gt; = &lt;funkcija-obstojeih-stolpcev&gt;, ...) Dodajmo stolpec CompensationUSD, ki bo prikazal letno plao v USD: ds_jobs &lt;- mutate(ds_jobs, CompensationUSD = CompensationAmount * ExchangeRate) select(ds_jobs, CompensationAmount, ExchangeRate, CompensationUSD) ## # A tibble: 3,781 x 3 ## CompensationAmount ExchangeRate CompensationUSD ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 80000 0.802 64185. ## 2 1200000 0.0174 20882. ## 3 1100000 0.0333 36634. ## 4 20000 1 20000 ## 5 100000 1 100000 ## 6 20000 0.0458 916. ## 7 624000 0.0174 10859. ## 8 156000000 0.000342 53352 ## 9 150000 1.20 179374. ## 10 126000 0.281 35419. ## # ... with 3,771 more rows Znotraj klica mutate() lahko uporabimo stolpce, ki smo jih ustvarili v istem klicu v preteklih vrsticah. Recimo, da elimo poleg plae v USD izraunati e meseno plao v USD: ds_jobs &lt;- mutate(ds_jobs, CompensationUSD = CompensationAmount * ExchangeRate, MonthlyCompUSD = CompensationUSD / 12) select(ds_jobs, CompensationAmount, ExchangeRate, CompensationUSD, MonthlyCompUSD) ## # A tibble: 3,781 x 4 ## CompensationAmount ExchangeRate CompensationUSD MonthlyCompUSD ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 80000 0.802 64185. 5349. ## 2 1200000 0.0174 20882. 1740. ## 3 1100000 0.0333 36634. 3053. ## 4 20000 1 20000 1667. ## 5 100000 1 100000 8333. ## 6 20000 0.0458 916. 76.4 ## 7 624000 0.0174 10859. 905. ## 8 156000000 0.000342 53352 4446 ## 9 150000 1.20 179374. 14948. ## 10 126000 0.281 35419. 2952. ## # ... with 3,771 more rows 1.8 Povzemanje vrednosti s summarise() Funkcija summarise() se uporablja za povzemanje vrednosti (na primer povpreja, vsote, tevci, ). Sintaksa funkcije je: summarise(&lt;tibble&gt;, &lt;ime-povzetka&gt; = &lt;funkcija-ki-povzame-stolpec&gt;, ...) Najprej poglejmo delovanje te funkcije, tako da povzamemo povpreen as priprave podatkov: summarise(ds_jobs, MeanDataCleaning = mean(TimeGatheringData)) ## # A tibble: 1 x 1 ## MeanDataCleaning ## &lt;dbl&gt; ## 1 37.3 Funkcija enostavno vrne povpreje stolpca TimeGatheringData. Ta informacija je sicer uporabna, ampak to ni edina funkcionalnost te funkcije in je obiajno ne uporabljamo v tej obliki. Njena mo se izrazi, ko jo uporabimo v kombinaciji z ukazom group_by(). Ta ukaz zdrui vrstice glede na vrednosti v podanih stolpcih. Zdruene vrednosti imajo posebno funkcijo v paketu dplyr in vplivajo na funkcionalnosti funkcij summarise(), mutate() in filter(). Vpliv grupiranja na mutate() in filter() si bomo ogledali nekoliko kasneje, poglejmo sedaj vpliv na summarise(). Recimo, da nas zanima, v katerih slubah je potrebnega najve ienja podatkov. Najprej podatke zdruimo po stolpcu CurrentJobTitle, potem pa uporabimo summarise(): ds_jobs_grouped &lt;- group_by(ds_jobs, CurrentJobTitle) summarise(ds_jobs_grouped, MeanDataCleaning = mean(TimeGatheringData)) ## # A tibble: 17 x 2 ## CurrentJobTitle MeanDataCleaning ## &lt;chr&gt; &lt;dbl&gt; ## 1 &quot;&quot; 40 ## 2 &quot;Business Analyst&quot; 37.9 ## 3 &quot;Computer Scientist&quot; 33.3 ## 4 &quot;Data Analyst&quot; 41.2 ## 5 &quot;Data Miner&quot; 48.0 ## 6 &quot;Data Scientist&quot; 39.4 ## 7 &quot;DBA/Database Engineer&quot; 37.7 ## 8 &quot;Engineer&quot; 36.4 ## 9 &quot;Machine Learning Engineer&quot; 34.7 ## 10 &quot;Operations Research Practitioner&quot; 37.8 ## 11 &quot;Other&quot; 36.3 ## 12 &quot;Predictive Modeler&quot; 37.1 ## 13 &quot;Programmer&quot; 35.8 ## 14 &quot;Researcher&quot; 31.3 ## 15 &quot;Scientist/Researcher&quot; 33.5 ## 16 &quot;Software Developer/Software Engineer&quot; 36.9 ## 17 &quot;Statistician&quot; 34.7 Izgleda, da so povpreja kar blizu  as ienja podatkov je relativno neodvisen od delovnega mesta. Povzemamo lahko tudi preko veih stolpcev. Poglejmo si tevilo ljudi z razlinimi statusi zaposlitve v kombinaciji z izobrazbo. Da pretejemo tevilo vrstic, ki ustrezajo grupiranju, uporabimo funkcijo n(): ds_jobs_grouped &lt;- group_by(ds_jobs, FormalEducation, EmploymentStatus) summarise(ds_jobs_grouped, Count = n()) ## # A tibble: 21 x 3 ## # Groups: FormalEducation [8] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows Ker je tetje primerov zelo pogosta operacija, obstaja tudi funkcija count(), ki naredi enako kot kombinacija group_by() in summarise(): count(ds_jobs, FormalEducation, EmploymentStatus) ## # A tibble: 21 x 3 ## FormalEducation EmploymentStatus n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows 1.9 Pipe V praksi urejanje podatkov zajame veino, e ne kar vseh funkcij, ki smo jih predstavili do sedaj. e elimo sproti shranjevati nae spremembe, moramo po vsaki uporabi funkcije spremenjene podatke ponovno shraniti v spremenljivko. To lahko postane nekoliko nepregledno. Poglejmo si potek dela, kjer bomo nad osnovnimi podatki izvedli te operacije: Izbrali bomo vrstice, kjer so osebe stareje od 30 let in drava ni Other ali prazen niz. Izloili vse stolpce, ki vsebujejo niz Time. Izraunali stolpec s plao v amerikih dolarjih. Povzeli plao glede na dravo. Z uporabo shranjevanja podatkov v spremenljivko, kot smo navajeni iz osnovne razliice R, bi s funkcijami iz dplyr izgledalo takole: ds_jobs2 &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs2 &lt;- as_tibble(ds_jobs2) ds_jobs2 &lt;- filter(ds_jobs2, Age &gt; 30, !(Country %in% c(&quot;Other&quot;, &quot;&quot;))) ds_jobs2 &lt;- select(ds_jobs2, -contains(&quot;Time&quot;)) ds_jobs2 &lt;- mutate(ds_jobs2, CompensationUSD = CompensationAmount * ExchangeRate) ds_jobs2 &lt;- group_by(ds_jobs2, Country) ds_jobs2_summarised &lt;- summarise(ds_jobs2, MeanCompensation = mean(CompensationUSD, na.rm = T)) ds_jobs2_summarised ## # A tibble: 51 x 2 ## Country MeanCompensation ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 39282. ## 2 Australia 112800. ## 3 Belarus 33500 ## 4 Belgium 74141. ## 5 Brazil 47799. ## 6 Canada 85471. ## 7 Chile 44152. ## 8 Colombia 43303. ## 9 Czech Republic 50223. ## 10 Denmark 88136. ## # ... with 41 more rows Pri raunanju povpreja smo uporabili argument na.rm = T, s katerim smo manjkajoe vrednosti ignorirali. Celoten postopek je vseboval kar nekaj prepisovanja. Predvsem spremenljivko ds_jobs2 smo morali prepisati kar 6-krat. Dplyr pa vsebuje poseben operator, ki ga imenujemo pipe in ga oznaimo z %&gt;%. S tem operatorjem funkcije poveemo v sosledje. Poglejmo si, kako deluje: ds_jobs2 &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs2_summarised &lt;- ds_jobs2 %&gt;% filter(Age &gt; 30, !(Country %in% c(&quot;Other&quot;, &quot;&quot;))) %&gt;% select(-contains(&quot;Time&quot;)) %&gt;% mutate(CompensationUSD = CompensationAmount * ExchangeRate) %&gt;% group_by(Country) %&gt;% summarise(MeanCompensation = mean(CompensationUSD, na.rm = T)) ds_jobs2_summarised ## # A tibble: 51 x 2 ## Country MeanCompensation ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 39282. ## 2 Australia 112800. ## 3 Belarus 33500 ## 4 Belgium 74141. ## 5 Brazil 47799. ## 6 Canada 85471. ## 7 Chile 44152. ## 8 Colombia 43303. ## 9 Czech Republic 50223. ## 10 Denmark 88136. ## # ... with 41 more rows Sedaj smo do povzetka prili z zaporednim izvajanjem operacij nad spremenljivko ds_jobs. Ta nain je bolj pregleden, saj bralec kode takoj opazi, da se je vse izvajalo nad istimi podatki. Opazimo tudi, zakaj gre za slovnico urejanja podatkov. Programska koda zapisana zgoraj se bere skoraj kot naravni jezik. Na primer, izberi vrstice, kjer so leta veja od 30 in drava ni v ustrezni mnoici. Zatem izberi stolpce, ki ne vsebujejo besede Time. Dodaj novo spremenljivko, zdrui podatke in jih povzemi. 1.10 filter() in mutate() na zdruenih podatkih Spoznali smo, kako funkcija group_by() vpliva na povzemanje podatkov. Uporabimo pa jo lahko tudi v povezavi s filter() in mutate(). Kombinacija z izbiro vrstic pride prav, kadar elimo pogojno izbiro na nek drugi stolpec. Kot primer si poglejmo, kako bi iz podatkov za vsako dravo filtrirali top 3 anketirance, ki prejmejo najvijo plao. Najprej bomo podatke grupirali, nato pa uporabili filter: ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country) %&gt;% filter(rank(desc(CompensationUSD)) &lt;= 3) %&gt;% arrange(Country) ## # A tibble: 154 x 4 ## # Groups: Country [53] ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 &quot;&quot; NA Data Scientist 107624. ## 2 &quot;&quot; 63 Machine Learning Engineer 160000 ## 3 &quot;&quot; NA Operations Research Practitioner 120000 ## 4 &quot;Argentina&quot; 55 Data Scientist 100000 ## 5 &quot;Argentina&quot; 26 Data Scientist 65000 ## 6 &quot;Argentina&quot; 26 Data Scientist 80000 ## 7 &quot;Australia&quot; 39 Data Scientist 280808. ## 8 &quot;Australia&quot; 50 Data Miner 248716. ## 9 &quot;Australia&quot; 37 Software Developer/Software Engineer 400000 ## 10 &quot;Belarus&quot; 22 Data Scientist 10800 ## # ... with 144 more rows Kombinacija group_by() in mutate() je uporabna, kadar elimo ustvariti novo spremenljivko, pri kateri bomo pri izraunu potrebovali kak povzetek vrednosti znotraj posamezne skupine. Primer takne transformacije je na primer standardiziranje znotraj skupine. Standardna ocena je: \\[ z_i = \\frac{x_i - \\bar{x}}{S_x}, \\] kjer je \\(\\bar{x}\\) povpreje vektorja \\(x\\) in \\(S_x\\) njegov vzorni standardni odklon. Poskusimo za vsako dravo izraunati vzorno povpreno vrednost in standardni odklon, ter s tema vrednostima ustrezno transformirati plao v USD. Da pa bo funkcija mutate() vedela, katere vrednosti naj vzame za raunanje teh dveh statistie moramo podatke najprej grupirati glede na dravo: ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country) %&gt;% mutate(CompensationStand = (CompensationUSD - mean(CompensationUSD)) / sd(CompensationUSD)) ## # A tibble: 3,781 x 5 ## # Groups: Country [53] ## Country Age CurrentJobTitle CompensationUSD CompensationSta~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. -0.617 ## 2 Russia 33 Software Developer/Softwa~ 20882. -0.136 ## 3 Taiwan 26 Software Developer/Softwa~ 36634. 0.0566 ## 4 United Sta~ 25 Researcher 20000 -0.0468 ## 5 United Sta~ 33 Scientist/Researcher 100000 -0.0347 ## 6 Czech Repu~ 21 Other 916. -0.907 ## 7 Russia 22 Data Analyst 10859. -0.417 ## 8 Colombia 34 Data Scientist 53352 0.770 ## 9 Germany 41 Data Scientist 179374. 2.35 ## 10 Poland 29 Software Developer/Softwa~ 35419. 0.486 ## # ... with 3,771 more rows e ta tibble shranimo v novo spremenljivko, se bo informacija o zdruevanju ohranila. ds_jobs_grouped &lt;- ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country, CurrentJobTitle) ds_jobs_grouped ## # A tibble: 3,781 x 4 ## # Groups: Country, CurrentJobTitle [543] ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. ## 2 Russia 33 Software Developer/Software Engineer 20882. ## 3 Taiwan 26 Software Developer/Software Engineer 36634. ## 4 United States 25 Researcher 20000 ## 5 United States 33 Scientist/Researcher 100000 ## 6 Czech Republic 21 Other 916. ## 7 Russia 22 Data Analyst 10859. ## 8 Colombia 34 Data Scientist 53352 ## 9 Germany 41 Data Scientist 179374. ## 10 Poland 29 Software Developer/Software Engineer 35419. ## # ... with 3,771 more rows Opazimo, da ima ta tibble dodatno informacijo v drugi vrstici, ki nam sporoa, da je zdruen glede na spremenljivki Country in CurrentJobTitle. Poleg tega je v oglatih oklepajih zapisano tevilo unikatnih skupin. Pri tem so vsi pari drave in trenutne pozicije, za katere nimamo nobenega podatka, izpueni. Informacija o tem, da je ta tibble grupiran, je pomembna, saj se bodo vse nadaljnje operacije nad njim izvajale nad skupinami. e tega ne elimo, lahko uporabimo funkcijo ungroup(). ds_jobs_ungrouped &lt;- ds_jobs_grouped %&gt;% ungroup() ds_jobs_ungrouped ## # A tibble: 3,781 x 4 ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. ## 2 Russia 33 Software Developer/Software Engineer 20882. ## 3 Taiwan 26 Software Developer/Software Engineer 36634. ## 4 United States 25 Researcher 20000 ## 5 United States 33 Scientist/Researcher 100000 ## 6 Czech Republic 21 Other 916. ## 7 Russia 22 Data Analyst 10859. ## 8 Colombia 34 Data Scientist 53352 ## 9 Germany 41 Data Scientist 179374. ## 10 Poland 29 Software Developer/Software Engineer 35419. ## # ... with 3,771 more rows 1.11 Izvajanje operacij nad veimi stolpci z across() S kombinacijo funkcij mutate() in across() lahko izvajamo isto operacijo hkrati na ve stolpcih. Znotraj funkcije across() lahko uporabljamo iste funkcije za izbiro kot znotraj select(). Spremenimo vrednosti stolpcev, ki se zanejo s Time, v delee tako, da jih pomnoimo z 0.01. Na tem mestu bomo uporabili dva nova operatorja: . in ~. Operator . v dplyr igra vlogo podatkov, nad katerimi operiramo. Operator ~ je nekakna blinjica, ki ustvari funkcijo. Na primer ~ x^2 je blinjica za zapis function(x) {x^2}. To je uporabno predvsem, ko funkcijo potrebujemo samo na enem mestu znotraj naega poteka dela in jo tako lahko na kraji nain zapiemo. Poglejmo si sedaj spremembo stolpcev v delee: ds_jobs %&gt;% mutate(across(starts_with(&quot;Time&quot;), ~ . * 0.01)) %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 8 ## Country CurrentJobTitle TimeGatheringDa~ TimeModelBuildi~ TimeProduction ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 0.6 0.1 0.05 ## 2 Russia Software Develope~ 0.4 0.3 0.15 ## 3 Taiwan Software Develope~ 0.35 0.2 0.25 ## 4 United S~ Researcher 0 0.8 0 ## 5 United S~ Scientist/Researc~ 0 0 0 ## 6 Czech Re~ Other 0.2 0.6 0.2 ## 7 Russia Data Analyst 0.5 0.2 0.1 ## 8 Colombia Data Scientist 0.6 0.1 0.2 ## 9 Germany Data Scientist 0.5 0.1 0.2 ## 10 Poland Software Develope~ 0.25 0.2 0.25 ## # ... with 3,771 more rows, and 3 more variables: TimeVisualizing &lt;dbl&gt;, ## # TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;dbl&gt; Funkciji across() smo najprej podali stolpce, na katerih elimo izvajati izraune, nato pa funkcijo, ki jo elimo izvesti. 1.12 Povzemanje stolpcev Pogosto elimo dobiti numerine povzetke glede na vrednosti v stolpcih. Z uporabo osnovne razliice R to lahko naredimo s funkcijo apply(), ki ji podamo tibble numerinih vrednosti (lahko tudi data.frame ali matriko), doloimo dimenzijo 2, ki predstavlja stolpce, ter podamo kateri povzetek elimo (na primer povpreje, varianco, maksimalno vrednost, ). Izraunajmo povpreja in standardne odklone stolpcev, ki se zanejo s Time: ds_jobs_times &lt;- ds_jobs %&gt;% select(starts_with(&quot;Time&quot;)) apply(ds_jobs_times, 2, mean, na.rm = T) ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 37.341973 21.085472 11.172853 14.190924 ## TimeFindingInsights TimeOtherSelect ## 13.375298 2.202176 apply(ds_jobs_times, 2, sd, na.rm = T) ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 20.96041 15.19101 12.03243 10.99431 ## TimeFindingInsights TimeOtherSelect ## 12.01139 11.18898 apply() nam v teh primerih vrne vektor, eprav smo operacijo izvajali na tibble. Ideja paketa tidyverse je, da so izhodni podatki enakega tipa kot vhodni  v tem primeru tibble. e elimo izraunati povzetke za vsak stolpec, lahko v paketu dplyr uporabimo kombinacijo funkcije summarise() in across(). Kot smo e spoznali, nam funkcija across() omogoa izvajanje operacij nad veimi stolpci. ds_jobs %&gt;% summarise(across(starts_with(&quot;Time&quot;), mean, na.rm = T)) ## # A tibble: 1 x 6 ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 37.3 21.1 11.2 14.2 ## # ... with 2 more variables: TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;dbl&gt; Povzetke lahko enostavno izraunamo tudi za razline skupine z uporabo funkcije group_by(): ds_jobs %&gt;% group_by(EmploymentStatus) %&gt;% summarise(across(starts_with(&quot;Time&quot;), mean, na.rm = T)) ## # A tibble: 3 x 7 ## EmploymentStatus TimeGatheringDa~ TimeModelBuildi~ TimeProduction ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Employed full-time 37.6 20.6 11.0 ## 2 Employed part-time 37.4 26.1 10.3 ## 3 Independent contractor, free~ 34.8 23.0 12.8 ## # ... with 3 more variables: TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, ## # TimeOtherSelect &lt;dbl&gt; 1.13 Povzemanje vrstic Kadar analiziramo podatke, preverimo, ali so vneeni podatki smiselni. Na primer, v stolpcih, ki se zanejo s Time, so odstotkovne vrednosti asa, ki ga anketiranci porabijo za posamezne naloge. Te bi se morale seteti v 100 in v primeru, ko se ne, se lahko odloimo, da takne vrstice izbriemo. Na tem primeru si bomo sedaj pogledali e operacije nad stolpci. Na cilj bo, da dodamo temu tibblu e en stolpec, v katerem bomo seteli vse te stolpce. Funkcija apply deluje tudi nad stolpci, e spremenimo drugi argument: tmp &lt;- ds_jobs %&gt;% select(starts_with(&quot;Time&quot;)) head(apply(tmp, 1, sum, na.rm = T)) ## [1] 100 100 100 100 0 100 Kako pa to naredimo z dplyr, tako da se bo naravno vkljuilo v potek dela? Prva ideja bi morda bila, da enostavno natejemo vse stolpce. ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TotalTime = TimeGatheringData + TimeModelBuilding + TimeProduction + TimeVisualizing + TimeFindingInsights + TimeOtherSelect) %&gt;% select(!starts_with(&quot;Time&quot;)) # Ta vrstica je samo za lepi izpis. ## # A tibble: 3,781 x 3 ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 100 ## 2 Russia Software Developer/Software Engineer 100 ## 3 Taiwan Software Developer/Software Engineer 100 ## 4 United States Researcher 100 ## 5 United States Scientist/Researcher 0 ## 6 Czech Republic Other 100 ## 7 Russia Data Analyst 100 ## 8 Colombia Data Scientist 100 ## 9 Germany Data Scientist 100 ## 10 Poland Software Developer/Software Engineer 100 ## # ... with 3,771 more rows Sicer je to v naem primeru bilo izvedljivo, saj smo imeli samo 6 stolpcev. Kako pa bi to naredili z veimi stolpci? Morda lahko uporabimo starts_with(): ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TimeTotal = sum(starts_with(&quot;Time&quot;), na.rm = T)) ## Error: Problem with `mutate()` column `TimeTotal`. ## i `TimeTotal = sum(starts_with(&quot;Time&quot;), na.rm = T)`. ## x `starts_with()` must be used within a *selecting* function. ## i See &lt;https://tidyselect.r-lib.org/reference/faq-selection-context.html&gt;. R vrne napako in nas opozori, da se lahko starts_with() uporabi le znotraj izbire. e elimo v tem primeru omogoiti tidy izbiro stolpcev, uporabimo funkcijo c_across(). Ta funkcija je po funkcionalnosti bolj podobna funkciji c() ali select(), kot pa funkciji across(), tako da jih ne smemo zamenjati: ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TotalTime = sum(c_across(starts_with(&quot;Time&quot;)), na.rm = T)) %&gt;% select(!starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 3 ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 375462 ## 2 Russia Software Developer/Software Engineer 375462 ## 3 Taiwan Software Developer/Software Engineer 375462 ## 4 United States Researcher 375462 ## 5 United States Scientist/Researcher 375462 ## 6 Czech Republic Other 375462 ## 7 Russia Data Analyst 375462 ## 8 Colombia Data Scientist 375462 ## 9 Germany Data Scientist 375462 ## 10 Poland Software Developer/Software Engineer 375462 ## # ... with 3,771 more rows Sedaj smo dobili nek rezultat, ki pa e vedno ni pravilen. V em je teava? e sum() uporabimo znotraj mutate(), ta vrne vsoto znotraj skupin, doloenih z group_by(). Ker podatkov nismo grupirali, vrne vsoto kar ez celotne podatke (bralca vzpodbujamo, da to preveri tudi sam). Reitev se torej skriva v ustreznem zdruevanju vrstic. V dplyr obstaja funkcija, ki celoten tibble grupira po posameznih vrsticah in to je rowwise(): ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% rowwise() %&gt;% mutate(TotalTime = sum(c_across(starts_with(&quot;Time&quot;)), na.rm = T)) %&gt;% select(!starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 3 ## # Rowwise: ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 100 ## 2 Russia Software Developer/Software Engineer 100 ## 3 Taiwan Software Developer/Software Engineer 100 ## 4 United States Researcher 100 ## 5 United States Scientist/Researcher 0 ## 6 Czech Republic Other 100 ## 7 Russia Data Analyst 100 ## 8 Colombia Data Scientist 100 ## 9 Germany Data Scientist 100 ## 10 Poland Software Developer/Software Engineer 100 ## # ... with 3,771 more rows 1.14 Dodatek 1.14.1 Zamenjava vrstnega reda stolpcev Vrstni red stolpcev zamenjamo s funkcijo relocate(). Ustvarimo najprej manji tibble: ds_jobs_select &lt;- ds_jobs %&gt;% select(Gender:Major) ds_jobs_select ## # A tibble: 3,781 x 8 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; e elimo doloene stolpce premakniti na zaetek, jih enostavno podamo funkciji relocate(). Dajmo na prvo mesto stolpca Major in Age: ds_jobs_select %&gt;% relocate(Major, Age) ## # A tibble: 3,781 x 8 ## Major Age Gender Country EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;&quot; 43 Female Austra~ Employed full-t~ Business Analy~ Python ## 2 &quot;Othe~ 33 Male Russia Employed full-t~ Software Devel~ Python ## 3 &quot;Comp~ 26 Male Taiwan Employed full-t~ Software Devel~ Python ## 4 &quot;Phys~ 25 Male United~ Employed part-t~ Researcher Python ## 5 &quot;Elec~ 33 Male United~ Employed full-t~ Scientist/Rese~ Matlab ## 6 &quot;Comp~ 21 Male Czech ~ Employed part-t~ Other Python ## 7 &quot;Info~ 22 Male Russia Employed full-t~ Data Analyst Python ## 8 &quot;Comp~ 34 Male Colomb~ Employed full-t~ Data Scientist Python ## 9 &quot;&quot; 41 Male Germany Independent con~ Data Scientist Python ## 10 &quot;Comp~ 29 Male Poland Employed full-t~ Software Devel~ Python ## # ... with 3,771 more rows, and 1 more variable: FormalEducation &lt;chr&gt; Poljubno ureditev dobimo tako, da enostavno zapiemo vrstni red stolpcev, kot ga elimo. Funkcija relocate() omogoa e nekatere monosti urejanja, kot na primer, glede na tip spremenljivke. Za ve informacij o razlinih nainih urejanja stolpcev bralcu predlagamo uporabo pomoi ?relocate. 1.14.2 Preimenovanje stolpcev Stolpce preimenujemo s funkcijo rename(). ds_jobs_select %&gt;% rename(employment_status = EmploymentStatus, current_job_title = CurrentJobTitle) ## # A tibble: 3,781 x 8 ## Gender Country Age employment_status current_job_title LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; Tibble lahko vsebuje tudi imena stolpcev, ki niso veljavna za spremenljivke v R. V tem primeru jih moramo zapisati znotraj `. Na primer, spremenljivki v R ne moremo prirediti imena z minusom. Poizkusimo to narediti v tibblu: ds_jobs_select %&gt;% rename(`employment-status` = EmploymentStatus, `current-job-title` = CurrentJobTitle) ## # A tibble: 3,781 x 8 ## Gender Country Age `employment-status` `current-job-tit~ LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; 1.14.3 Summarise in group unpeeling Kot smo e spoznali je funkcija summarise() najbolj uporabna v kombinaciji z group_by(). Pogljemo si sedaj bolj podrobno, kaken tibble je rezultat te kombinacije. Najprej samo grupirajmo ds_jobs: ds_jobs_grouped &lt;- ds_jobs %&gt;% group_by(FormalEducation, EmploymentStatus) ds_jobs_grouped ## # A tibble: 3,781 x 19 ## # Groups: FormalEducation, EmploymentStatus [21] ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 13 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt;, CompensationUSD &lt;dbl&gt;, MonthlyCompUSD &lt;dbl&gt; V drugi vrstici vidimo, da je ta tibble grupiran po spremenljivkah FormalEducation in EmploymentStatus. Poglejmo kaj se zgodi, ko uporabimo summarise(): ds_jobs_summarised &lt;- ds_jobs_grouped %&gt;% summarise(Count = n()) ds_jobs_summarised ## # A tibble: 21 x 3 ## # Groups: FormalEducation [8] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows Opazimo, da je ta novi tibble grupiran samo po spremenljivki FormalEducation. Privzeto summarise() vedno odstrani zadnje grupiranje. e tega ne elimo, lahko uporabimo dodaten parameter .groups = \"keep\". ds_jobs_summarised &lt;- ds_jobs_grouped %&gt;% summarise(Count = n(), .groups = &quot;keep&quot;) ds_jobs_summarised ## # A tibble: 21 x 3 ## # Groups: FormalEducation, EmploymentStatus [21] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows 1.15 Ali elite izvedeti ve? V tem poglavju smo spoznali temeljne operacije nad podatki in njihovo implementacijo v R paketu dplyr. Opis vseh funkcij v dplyr najdemo tukaj: https://dplyr.tidyverse.org/reference/index.html. Jedrnat povzetek pa je na voljo tukaj: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf. 1.16 Domaa naloga Zaeli bomo z relativno preprosto nalogo, kjer bomo ponovili osnovne ukaze iz slovnice urejanja podatkov. Osnovna razliica programskega jezika R e vsebuje nekatere podatkovne zbirke. Z ukazom data() dobimo opis vseh zbirk. V tej nalogi bomo uporabili podatkovno zbirko mtcars: head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Za podrobneji opis podatkov uporabite pomo ?mtcars. Najprej ustvarite novo spremenljivko mtcars_tib, v katero shranite razpredelnico mtcars kot tibble. Nato vsako izmed spodnjih nalog izvedite posebej (torej v vsaki toki izvedite ukaz na mtcars_tib, ampak tako spremenjenega tibbla ne shranite nazaj v to spremenljivko), razen e je v nalogi eksplicitno navedeno drugae. Vae naloge so sledee: Ustvarite novo spremenljivko mtcars_tib, v katero shranite razpredelnico mtcars kot tibble. Izberite vse vrstice avtomobilov z avtomatskim menjalnikom. ## # A tibble: 19 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 2 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 3 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 5 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 6 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 7 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 8 17.8 6 168. 123 3.92 3.44 18.9 1 0 4 4 ## 9 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 10 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## 11 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 ## 12 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 13 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 14 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## 15 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 16 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 ## 17 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 ## 18 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 19 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 Izberite vse vrstice, kjer je poraba manja od 15 galon na miljo ali veja od 20 galon na miljo in je motor oblike V. ## # A tibble: 8 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 4 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 5 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 6 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## 7 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 8 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 Izberite vse stolpce, kjer ime stolpca vsebuje rko a. ## # A tibble: 32 x 4 ## drat am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.9 1 4 4 ## 2 3.9 1 4 4 ## 3 3.85 1 4 1 ## 4 3.08 0 3 1 ## 5 3.15 0 3 2 ## 6 2.76 0 3 1 ## 7 3.21 0 3 4 ## 8 3.69 0 4 2 ## 9 3.92 0 4 2 ## 10 3.92 0 4 4 ## # ... with 22 more rows Izberite zadnje 4 stolpce. ## # A tibble: 32 x 4 ## vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 1 4 4 ## 2 0 1 4 4 ## 3 1 1 4 1 ## 4 1 0 3 1 ## 5 0 0 3 2 ## 6 1 0 3 1 ## 7 0 0 3 4 ## 8 1 0 4 2 ## 9 1 0 4 2 ## 10 1 0 4 4 ## # ... with 22 more rows V tibble mtcars_tib dodajte stolpca, kjer bosta izraunani tevilo litrov na 100 kilometrov in tea v kilogramih (v tisoicah). 1 milja je priblino 1.61 kilometra, 1 galona 3.79 litra in 1 funt 0.45 kilograma. Izraunajte povpreno porabo avtomobilov v odvisnosti tevila cilindrov. ## # A tibble: 3 x 2 ## cyl mean_mpg ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 Izraunajte povpreno konjsko mo v odvisnosti od oblike motorja in ali je avtomobil avtomatik ali ne. ## # A tibble: 4 x 3 ## # Groups: vs [2] ## vs am mean_hp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 194. ## 2 0 1 181. ## 3 1 0 102. ## 4 1 1 80.6 Normalizirajte vse stolpce, ki vsebujejo decimalna tevila, na interval [0, 1]. To naredimo tako, da vrednostim odtejemo minimalno vrednost in delimo z razliko med maksimalno in minimalno vrednostjo: \\[ x_i&#39; = \\frac{x_i - \\min(x)}{\\max(x) - \\min(x)}. \\] ## # A tibble: 32 x 13 ## mpg cyl disp hp drat wt qsec vs am gear carb lp100km ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.451 6 0.222 110 0.525 0.283 0.233 0 1 4 4 11.2 ## 2 0.451 6 0.222 110 0.525 0.348 0.3 0 1 4 4 11.2 ## 3 0.528 4 0.0920 93 0.502 0.206 0.489 1 1 4 1 10.3 ## 4 0.468 6 0.466 110 0.147 0.435 0.588 1 0 3 1 11.0 ## 5 0.353 8 0.721 175 0.180 0.493 0.3 0 0 3 2 12.6 ## 6 0.328 6 0.384 105 0 0.498 0.681 1 0 3 1 13.0 ## 7 0.166 8 0.721 245 0.207 0.526 0.160 0 0 3 4 16.5 ## 8 0.596 4 0.189 62 0.429 0.429 0.655 1 0 4 2 9.65 ## 9 0.528 4 0.174 95 0.535 0.419 1 1 0 4 2 10.3 ## 10 0.374 6 0.241 123 0.535 0.493 0.452 1 0 4 4 12.3 ## # ... with 22 more rows, and 1 more variable: wt_in_kg &lt;dbl&gt; Izraunajte povprene vrednosti vseh stolpcev. ## # A tibble: 1 x 13 ## mpg cyl disp hp drat wt qsec vs am gear carb lp100km ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20.1 6.19 231. 147. 3.60 3.22 17.8 0.438 0.406 3.69 2.81 12.8 ## # ... with 1 more variable: wt_in_kg &lt;dbl&gt; Teja naloga. V mapi data-raw se nahajajo podatki o gozdnih poarih na Portugalskem. Podatki so bili uporabljeni v znanstvenem lanku (Cortez et Morais 2007), kjer so napovedovali velikost poganega obmoja v odvisnosti od meteorolokih in drugih podatkov. Vrednosti 0 za pogano obmoje predstavljajo poare, kjer je pogorelo manj kot 100 kvadratnih metrov. Preberite podatke in jih shranite kot tibble. Preverite, v katerem mesecu je najve poarov in jih uredite padajoe od tistega z najve poari do tistega z najmanj. ## # A tibble: 12 x 2 ## month n ## &lt;chr&gt; &lt;int&gt; ## 1 aug 184 ## 2 sep 172 ## 3 mar 54 ## 4 jul 32 ## 5 feb 20 ## 6 jun 17 ## 7 oct 15 ## 8 apr 9 ## 9 dec 9 ## 10 jan 2 ## 11 may 2 ## 12 nov 1 Preverite, ali obstajajo obmoja v parku, kjer se bolj pogosto pojavljajo poari. Za vsako kombinacijo koordinat bomo torej izraunali tevilo poarov. Rezultat lahko predstavimo z razpredelnico. Glede na to, da imamo dvodimenzionalne podatke, bi jih morda bilo smiselno predstaviti vizualno. V kolikor poznate paket ggplot2, predlagamo da si pogledate funkcijo geom_tile(). ## # A tibble: 36 x 3 ## X Y n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2 19 ## 2 1 3 10 ## 3 1 4 15 ## 4 1 5 4 ## 5 2 2 25 ## 6 2 3 1 ## 7 2 4 27 ## 8 2 5 20 ## 9 3 3 1 ## 10 3 4 43 ## # ... with 26 more rows Dodajte stolpec, ki bo za vsak poar izraunal dele poganega obmoja glede na vse poare na posameznih koordinatah. Za tem smiselno filtrirajte podatke (ali smo v novem stolpcu dobili kakne nepriakovane, oziroma neveljavne vrednosti?). ## # A tibble: 509 x 5 ## X Y month day area_by_coord ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 7 5 mar fri 0 ## 2 7 4 oct tue 0 ## 3 7 4 oct sat 0 ## 4 8 6 mar fri 0 ## 5 8 6 mar sun 0 ## 6 8 6 aug sun 0 ## 7 8 6 aug mon 0 ## 8 8 6 aug mon 0 ## 9 8 6 sep tue 0 ## 10 7 5 sep sat 0 ## # ... with 499 more rows Preverite, ali ob vroem vremenu in nizki vlanosti pogori veji dele obmoja, ki smo ga izraunali v prejnji toki, tako da izberete vrstice, kjer je temperatura vija od 0.8 kvantila temperature in vlanost nija od 0.2 kvantila vlanosti ter izraunate povpreje. \\(q\\)-ti kvantil je ocena tevila, za katerega velja, da je \\(q\\) vrednosti manjih od tega tevila. Za raunanje kvantilov uporabite funkcijo quantile(). Za primerjavo izraunajte e povpreje te spremenljivke za vse preostale vrstice. Ali se rezultati skladajo z vao intuicijo? ## # A tibble: 1 x 1 ## mean_area_by_coord ## &lt;dbl&gt; ## 1 0.153 ## # A tibble: 1 x 1 ## mean_area_by_coord ## &lt;dbl&gt; ## 1 0.0555 Izraunajte povpreje standardiziranih indeksov in ga vstavite kot stolpec pred prvo spremenljivko, ki predstavlja indeks. ## # A tibble: 509 x 15 ## # Rowwise: ## X Y month day mean_indices FFMC_index DMC_index DC_index ISI_index ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 5 mar fri -1.21 -0.796 -1.32 -1.86 -0.859 ## 2 7 4 oct tue -0.304 -0.00502 -1.18 0.480 -0.510 ## 3 7 4 oct sat -0.254 -0.00502 -1.05 0.552 -0.510 ## 4 8 6 mar fri -0.739 0.193 -1.21 -1.92 -0.00890 ## 5 8 6 mar sun -0.719 -0.239 -0.934 -1.82 0.122 ## 6 8 6 aug sun 0.218 0.301 -0.405 -0.256 1.23 ## 7 8 6 aug mon -0.0979 0.301 -0.349 -0.225 -0.118 ## 8 8 6 aug mon 0.320 0.157 0.530 0.232 0.361 ## 9 8 6 sep tue 0.120 0.0669 0.283 0.575 -0.445 ## 10 7 5 sep sat 0.0375 0.337 -0.363 0.599 -0.423 ## # ... with 499 more rows, and 6 more variables: temp &lt;dbl&gt;, RH &lt;dbl&gt;, ## # wind &lt;dbl&gt;, rain &lt;dbl&gt;, area &lt;dbl&gt;, area_by_coord &lt;dbl&gt; "]]
