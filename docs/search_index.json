[["urejeni-in-relacijski-podatki.html", "Poglavje 2 Urejeni in relacijski podatki 2.1 Priprava 2.2 Urejeni podatki 2.3 pivot_longer(): pretvorba v daljo obliko 2.4 pivot_wider(): pretvorba v iro obliko 2.5 separate() in unite(): deljenje in zdruevanje stolpcev 2.6 Relacijske zbirke podatkov 2.7 Primer: Banni podatki 2.8 Kljui 2.9 Zdruevanja 2.10 Operacije nad mnoicami 2.11 Ali elite izvedeti ve? 2.12 Domaa naloga", " Poglavje 2 Urejeni in relacijski podatki Pri kakrnemkoli delu smo obiajno zelo ciljno naravnani. Dobimo nalogo in jo elimo imprej in imbolje opraviti. Z namenom uinkovitosti se obiajno posluimo znanih orodij in postopkov, ki jih prilagodimo samemu problemu. Pri delu s podatki se ciljna naravnanost obiajno izrazi tako, da elimo imprej priti do analize in zakljukov, samemu urejanju podatkov pa ne posvetimo pretirane pozornosti, oziroma le toliko, kot je nujno potrebno (kar je e vedno lahko dolgotrajno). Na kratek rok to deluje v redu in celo prihranimo nekaj asa. Na dolgi rok pa obiajno zahteva veliko ve asa, saj se moramo pri vsaki novi nalogi na novo prilagajati podatkom. Bolji pristop bi bil, da bi problem prilagodili ustaljenemu postopku. Obiajno lahko veino podatkov uredimo do te mere, da so si po obliki podobni. V kolikor se nauimo narediti to za neko splono podatkovno zbirko, lahko potem vsaki pristopimo do nadaljnjega dela na podoben nain. V praksi s tem na dolgi rok prihranimo veliko asa. Koncept urejenih podatkov (ang. tidy data), ki ga bomo spoznali v tem poglavju, je formalizacija intuitivne predstavke kaj podatki so. Podatke, ki so urejeni, lahko veliko laje transformiramo in pripravimo na nadaljnjo analizo. Tudi funkcije v tidyverse so implementirane tako, da na vhod prejmejo urejene podatke in takne tudi vrnejo. Z drugimi besedami ohranjajo urejenost. Relacijski podatki pa so podatki o razlinih entitetah (na primer podjetje, delavec, slubeno vozilo, klient), ki so shranjeni v razlinih razpredelnicah. Kadar elimo analizirati relacijske podatke moramo razumeti povezave med njimi in kako delati z njimi. Spoznali bomo koncept relacijskih podatkovnih zbirk in kako uporabiti tidyverse za delo z njimi. 2.1 Priprava V tem poglavju bomo spoznali, kako podatke pretvorimo iz dalje v krajo obliko (in obratno) ter kako delamo z relacijskimi podatki. Kaj vsi ti koncepti pomenijo in kako so povezani z urejenimi podatki, bomo predelali v jedru poglavja. Pri pretvorbi podatkov v daljo obliko gre za pretvorbo, kjer vrednosti veih stolpcev zdruimo v en stolpec. Poglejmo si razpredelnico, kjer imamo shranjene podatke za ve let: df &lt;- tibble( ime = c(&quot;Mojca&quot;, &quot;Miha&quot;, &quot;Mateja&quot;), `2018` = c(5.5, 4.6, 8.7), `2019` = c(5.8, 4.2, 9) ) df ## # A tibble: 3 x 3 ## ime `2018` `2019` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mojca 5.5 5.8 ## 2 Miha 4.6 4.2 ## 3 Mateja 8.7 9 Recimo, da elimo stolpca z leti spraviti v en stolpec. Uporabimo funkcijo pivot_longer(). df_longer &lt;- pivot_longer(df, c(`2018`, `2019`), names_to = &quot;leto&quot;, values_to = &quot;rezultat&quot;) df_longer ## # A tibble: 6 x 3 ## ime leto rezultat ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mojca 2018 5.5 ## 2 Mojca 2019 5.8 ## 3 Miha 2018 4.6 ## 4 Miha 2019 4.2 ## 5 Mateja 2018 8.7 ## 6 Mateja 2019 9 Lahko naredimo tudi obratno transformacijo, torej da vrednosti enega stolpca razirimo v ve stolpcev. Na primer, razirimo stolpec ime: pivot_wider(df_longer, names_from = ime, values_from = rezultat) ## # A tibble: 2 x 4 ## leto Mojca Miha Mateja ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2018 5.5 4.6 8.7 ## 2 2019 5.8 4.2 9 Naloga: Spodnjo razpredelnico transformirajte v daljo obliko, tako da informacije o tevilu oddelkov shranite v 1 stolpec. df &lt;- tibble( podjetje = c(&quot;Podjetje A&quot;, &quot;Podjetje A&quot;, &quot;Podjetje B&quot;), kraj_tovarne = c(&quot;Koper&quot;, &quot;Kranj&quot;, &quot;Koper&quot;), prihodek = c(100000, 120000, 60000), razvojni_oddelki = c(2, 3, 1), prodajni_oddelki = c(3, 3, 2) ) df ## # A tibble: 3 x 5 ## podjetje kraj_tovarne prihodek razvojni_oddelki prodajni_oddelki ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Podjetje A Koper 100000 2 3 ## 2 Podjetje A Kranj 120000 3 3 ## 3 Podjetje B Koper 60000 1 2 Reitev: ## # A tibble: 6 x 5 ## podjetje kraj_tovarne prihodek oddelek stevilo_oddelkov ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Podjetje A Koper 100000 razvojni_oddelki 2 ## 2 Podjetje A Koper 100000 prodajni_oddelki 3 ## 3 Podjetje A Kranj 120000 razvojni_oddelki 3 ## 4 Podjetje A Kranj 120000 prodajni_oddelki 3 ## 5 Podjetje B Koper 60000 razvojni_oddelki 1 ## 6 Podjetje B Koper 60000 prodajni_oddelki 2 Spoznali bomo tudi relacijske podatke, pri katerih so podatki razdeljeni med ve razpredelnic. Zato bomo potrebovali ve funkcij, ki nam omogoajo zdruevanje teh razpredelnic. Poglejmo si dve razpredelnici: ekipe &lt;- tibble( id_ekipe = c(1, 2, 3, 4), ekipa = c(&quot;Liverpool&quot;, &quot;Manchester United&quot;, &quot;Arsenal&quot;, &quot;Rokova ekipa&quot;) ) igralci &lt;- tibble( id_igralca = c(1, 2, 3, 4, 5, 6, 7), ime = c(&quot;Henderson&quot;, &quot;Fernandes&quot;, &quot;Alisson&quot;, &quot;Rashford&quot;, &quot;Novak&quot;, &quot;Aubameyang&quot;, &quot;Vega&quot;), id_ekipe = c(1, 2, 1, 2, 8, 3, 8) ) ekipe ## # A tibble: 4 x 2 ## id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Liverpool ## 2 2 Manchester United ## 3 3 Arsenal ## 4 4 Rokova ekipa igralci ## # A tibble: 7 x 3 ## id_igralca ime id_ekipe ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 Henderson 1 ## 2 2 Fernandes 2 ## 3 3 Alisson 1 ## 4 4 Rashford 2 ## 5 5 Novak 8 ## 6 6 Aubameyang 3 ## 7 7 Vega 8 Za zdruevanje razpredelnic obstaja ve funkcij, vse imajo konnico _join. Poglejmo si, kako jih kliemo in kaj vsaka izmed njih naredi. Ve bomo o njih povedali na predavanju. left_join() zdrui razpredelnici tako, da obdri vse primere iz prve razpredelnice: left_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 7 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 5 Novak 8 &lt;NA&gt; ## 6 6 Aubameyang 3 Arsenal ## 7 7 Vega 8 &lt;NA&gt; right_join() zdrui razpredelnici tako, da obdri vse primere iz druge razpredelnice: right_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 6 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 6 Aubameyang 3 Arsenal ## 6 NA &lt;NA&gt; 4 Rokova ekipa inner_join() zdrui razpredelnici tako, da obdri samo primere, ki se pojavijo v obeh razpredelnicah: inner_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 5 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 6 Aubameyang 3 Arsenal full_join() zdrui razpredelnici tako, da obdri vse primere iz obeh razpredelnic: full_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 8 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 5 Novak 8 &lt;NA&gt; ## 6 6 Aubameyang 3 Arsenal ## 7 7 Vega 8 &lt;NA&gt; ## 8 NA &lt;NA&gt; 4 Rokova ekipa Naloga: Obstajata e dve operaciji zdruevanja, ki pa ne delujeta popolnoma enako kot zgornje funkcije. Pokliite funkciji semi_join() in anti_join() in poizkusite ugotoviti, kaj sta ti funkciji naredili. Sintaksa je enaka kot pri ostalih funkcijah join. Za branje podatkov iz tekstovnih datotek velikokrat uporabljamo funkcijo read.csv() ali katero od preostalih izpeljank funkcije read.table(). Tidyverse ima svojo razliico teh funkcij, ki pa imajo nekaj dodatne funkcionalnosti. Najbolj pomembna je ta, da se podatki samodejno shranijo kot tibble. To omogoa relativno enostavno branje datotek, kjer stolpci niso poimenovani v skladu s pravili programskega jezika R (na primer, lahko se zanejo s tevilom, lahko imajo minuse, presledke in podobno). Kot smo omenili shranjevanje podatkov, kjer imena stolpcev niso standardne oblike, ni dobra praksa. Vsekakor pa se pri realnih podatkih velikokrat zgodi, da imamo takna imena. V tem primeru je bolje, da jih prebermo takna kot so in jih programsko spremenimo, saj s tem ne posegamo v izvirne podatke. Je pa potrebno pri teh funkcijah dodatno nastaviti kodiranje, da znajo prebrati umnike. Poglejmo si uporabo funkcije read_csv2() paketa readr, kjer bomo ustrezno nastavili kodiranje. df &lt;- read_csv2(&quot;./data-raw/SLO-gradbena-dovoljenja-messy1.csv&quot;, locale = readr::locale(encoding = &quot;cp1250&quot;)) Ve o kodiranjih bomo povedali na zadnjem predavanju. 2.2 Urejeni podatki Omenili smo e, da se v praksi sreamo z najrazlinejimi oblikami zapisov podatkov. Skupek paketov tidyverse je namenjen delu s tako imenovanimi urejenimi podatki (ang. tidy data). Ideja je, da se ustvari enoten standard za obliko podatkov, s katero je laje delati. V kolikor se drimo tega standarda pri vseh naih analizah, nam to omogoa, da vedno uporabljamo ista orodja (na primer, ggplot2) in se nam ni potrebno uiti novih orodij za vsako analizo. Standard lahko povzamemo s 3 lastnostmi: vsak stolpec je spremenljivka, vsaka vrstica je primer podatka, vsaka vrednost ima svojo celico. Morda se na tej toki to slii nekoliko abstraktno. Poglejmo si praktien primer. Nabrali smo podatke o tevilu izdanih gradbenih dovoljenj v Sloveniji, razdeljeno glede na obine. Podatke smo prenesli s spletne strani statistinega urada Slovenije https://pxweb.stat.si/SiStat/slshranili in jih shranili na ve nainov. Najprej si poglejmo podatke v takni obliki, kot smo jih dobili naravnost iz vira. ## # A tibble: 424 x 16 ## OBINE TIP.STAVBE `2007` `2008` `2009` `2010` `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdov~ Stanovanjsk~ 52 55 45 33 52 40 29 30 ## 2 Ajdov~ Nestanovanj~ 19 9 22 15 27 11 23 11 ## 3 Ankaran~ Stanovanjsk~ NA NA NA NA NA NA NA NA ## 4 Ankaran~ Nestanovanj~ NA NA NA NA NA NA NA NA ## 5 Apae Stanovanjsk~ 10 11 22 12 7 5 9 10 ## 6 Apae Nestanovanj~ 3 3 8 3 4 6 2 3 ## 7 Beltinci Stanovanjsk~ 16 19 11 15 19 14 5 13 ## 8 Beltinci Nestanovanj~ 4 6 1 3 8 4 4 5 ## 9 Benedikt Stanovanjsk~ 11 12 6 9 7 3 16 10 ## 10 Benedikt Nestanovanj~ 3 2 1 3 5 3 4 3 ## # ... with 414 more rows, and 6 more variables: 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt;, ## # 2017 &lt;dbl&gt;, 2018 &lt;dbl&gt;, 2019 &lt;dbl&gt;, 2020 &lt;dbl&gt; Najprej imamo na voljo spremenljivki OBINE in TIP.STAVBE. Potem pa imamo za vsako leto natete vrednosti, oziroma tevila gradbenih dovoljenj. Podatki so velikokrat shranjeni v taknem formatu, saj ima doloene prednosti. Tak format je bolj prijazen za prikaz loveku, saj lahko samo s pogledom na razpredelnico hitro oceni, ali obstaja trend v posamezni vrstici. Format pa ni najbolji za delo s podatki. Govorili smo e o istih podatkih in da vse funkcije v tidyverse podpirajo operacije nad taknimi podatki. Kot vhod bo veina teh funkcij prejela iste podatke in takne potem tudi vrnila. Kaj je razlog, da ti podatki niso isti? Ne dri, da imamo v vsakem stolpcu spremenljivko, saj imamo eno spremenljivko razvleeno ez ve stolpcev  leto. Ta podatek vsekakor predstavlja spremenljivko, torej bi moral imeti enoten stolpec. Poglejmo si te podatke e v dveh neistih formatih. ## # A tibble: 28 x 214 ## TIP.STAVBE Leto Ajdovina `Ankaran/Ancaran~ Apae Beltinci Benedikt ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Stanovanjske stav~ 2007 52 NA 10 16 11 ## 2 Stanovanjske stav~ 2008 55 NA 11 19 12 ## 3 Stanovanjske stav~ 2009 45 NA 22 11 6 ## 4 Stanovanjske stav~ 2010 33 NA 12 15 9 ## 5 Stanovanjske stav~ 2011 52 NA 7 19 7 ## 6 Stanovanjske stav~ 2012 40 NA 5 14 3 ## 7 Stanovanjske stav~ 2013 29 NA 9 5 16 ## 8 Stanovanjske stav~ 2014 30 NA 10 13 10 ## 9 Stanovanjske stav~ 2015 38 3 12 23 13 ## 10 Stanovanjske stav~ 2016 31 1 10 22 15 ## # ... with 18 more rows, and 207 more variables: Bistrica ob Sotli &lt;dbl&gt;, ## # Bled &lt;dbl&gt;, Bloke &lt;dbl&gt;, Bohinj &lt;dbl&gt;, Borovnica &lt;dbl&gt;, Bovec &lt;dbl&gt;, ## # Braslove &lt;dbl&gt;, Brda &lt;dbl&gt;, Brezovica &lt;dbl&gt;, Breice &lt;dbl&gt;, Cankova &lt;dbl&gt;, ## # Celje &lt;dbl&gt;, Cerklje na Gorenjskem &lt;dbl&gt;, Cerknica &lt;dbl&gt;, Cerkno &lt;dbl&gt;, ## # Cerkvenjak &lt;dbl&gt;, Cirkulane &lt;dbl&gt;, renovci &lt;dbl&gt;, rna na Korokem &lt;dbl&gt;, ## # rnomelj &lt;dbl&gt;, Destrnik &lt;dbl&gt;, Divaa &lt;dbl&gt;, Dobje &lt;dbl&gt;, ## # Dobrepolje &lt;dbl&gt;, Dobrna &lt;dbl&gt;, Dobrova - Polhov Gradec &lt;dbl&gt;, ## # Dobrovnik/Dobronak &lt;dbl&gt;, Dol pri Ljubljani &lt;dbl&gt;, Dolenjske Toplice &lt;dbl&gt;, ## # Domale &lt;dbl&gt;, Dornava &lt;dbl&gt;, Dravograd &lt;dbl&gt;, Duplek &lt;dbl&gt;, ## # Gorenja vas - Poljane &lt;dbl&gt;, Gorinica &lt;dbl&gt;, Gorje &lt;dbl&gt;, ## # Gornja Radgona &lt;dbl&gt;, Gornji Grad &lt;dbl&gt;, Gornji Petrovci &lt;dbl&gt;, Grad &lt;dbl&gt;, ## # Grosuplje &lt;dbl&gt;, Hajdina &lt;dbl&gt;, Hoe - Slivnica &lt;dbl&gt;, Hodo/Hodos &lt;dbl&gt;, ## # Horjul &lt;dbl&gt;, Hrastnik &lt;dbl&gt;, Hrpelje - Kozina &lt;dbl&gt;, Idrija &lt;dbl&gt;, ## # Ig &lt;dbl&gt;, Ilirska Bistrica &lt;dbl&gt;, Ivanna Gorica &lt;dbl&gt;, Izola/Isola &lt;dbl&gt;, ## # Jesenice &lt;dbl&gt;, Jezersko &lt;dbl&gt;, Jurinci &lt;dbl&gt;, Kamnik &lt;dbl&gt;, Kanal &lt;dbl&gt;, ## # Kidrievo &lt;dbl&gt;, Kobarid &lt;dbl&gt;, Kobilje &lt;dbl&gt;, Koevje &lt;dbl&gt;, Komen &lt;dbl&gt;, ## # Komenda &lt;dbl&gt;, Koper/Capodistria &lt;dbl&gt;, Kostanjevica na Krki &lt;dbl&gt;, ## # Kostel &lt;dbl&gt;, Kozje &lt;dbl&gt;, Kranj &lt;dbl&gt;, Kranjska Gora &lt;dbl&gt;, ## # Krievci &lt;dbl&gt;, Krko &lt;dbl&gt;, Kungota &lt;dbl&gt;, Kuzma &lt;dbl&gt;, Lako &lt;dbl&gt;, ## # Lenart &lt;dbl&gt;, Lendava/Lendva &lt;dbl&gt;, Litija &lt;dbl&gt;, Ljubljana &lt;dbl&gt;, ## # Ljubno &lt;dbl&gt;, Ljutomer &lt;dbl&gt;, Log - Dragomer &lt;dbl&gt;, Logatec &lt;dbl&gt;, ## # Loka dolina &lt;dbl&gt;, Loki Potok &lt;dbl&gt;, Lovrenc na Pohorju &lt;dbl&gt;, ## # Lue &lt;dbl&gt;, Lukovica &lt;dbl&gt;, Majperk &lt;dbl&gt;, Makole &lt;dbl&gt;, Maribor &lt;dbl&gt;, ## # Markovci &lt;dbl&gt;, Medvode &lt;dbl&gt;, Menge &lt;dbl&gt;, Metlika &lt;dbl&gt;, Meica &lt;dbl&gt;, ## # Miklav na Dravskem polju &lt;dbl&gt;, Miren - Kostanjevica &lt;dbl&gt;, Mirna &lt;dbl&gt;, ## # Mirna Pe &lt;dbl&gt;, Mislinja &lt;dbl&gt;, ... Sedaj imamo podobno situacijo kot prej  ena spremenljivka je razvleena preko ve stolpcev  v tem primeru je to obina. Kot smo e omenili, so vsaki neisti podatki neisti na svoj nain. Podatki so popolnoma enaki kot v prejnjem prikazu, ampak razpredelnica izgleda popolnoma drugae. isti podatki pa imajo samo eno pravilno obliko, torej ne more priti do taknih dvoumnih prikazov. Poglejmo si e tretji format: ## # A tibble: 5,936 x 3 ## OBINA_TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina_Stanovanjske stavbe 2007 52 ## 2 Ajdovina_Stanovanjske stavbe 2008 55 ## 3 Ajdovina_Stanovanjske stavbe 2009 45 ## 4 Ajdovina_Stanovanjske stavbe 2010 33 ## 5 Ajdovina_Stanovanjske stavbe 2011 52 ## 6 Ajdovina_Stanovanjske stavbe 2012 40 ## 7 Ajdovina_Stanovanjske stavbe 2013 29 ## 8 Ajdovina_Stanovanjske stavbe 2014 30 ## 9 Ajdovina_Stanovanjske stavbe 2015 38 ## 10 Ajdovina_Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Ta je morda nekoliko blije istim podatkom, kot prejnja dva, ampak e vedno ni v popolnoma pravilni obliki. V em je teava? Dve spremenljivki imamo podani v enem stolpcu  obino in tip. Ker gre za razlini spremenljivki, bi bilo dobro, da se pojavita v razlinih stolpcih. Poglejmo si sedaj e iste podatke: ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Sedaj ima vsaka spremenljivka (obina, tip in leto) svoj stolpec, zadnji stolpec pa je namenjen vrednostim. V tem poglavju se bomo nauili neiste podatke spremeniti v iste. isti podatki imajo obiajno ve vrstic kot neisti in jim zato pravimo da so dalji (ang. longer). Neisti pa so obiajno iri (ang. wider). Izogibamo se besedam dolgi in iroki, saj je ta definicija relativna, se pravi lahko uporabimo transformacijo, ki naredi podatke dalje, ne pa nujno dolge, saj morda obstaja e kakna operacija, ki jih bo naredila e dalje. 2.3 pivot_longer(): pretvorba v daljo obliko Funkcija pivot_longer() podatke spremeni v daljo obliko. Ta trasformacija je pri delu s podatki bolj pogosta kot sprememba v iro. Obiajno uporabljamo to transformacijo, ko preurejamo podatke v iste. Poglejmo si ponovno neiste podatke, ki smo jih dobili naravnost iz vira: ## # A tibble: 424 x 16 ## OBINE TIP.STAVBE `2007` `2008` `2009` `2010` `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdov~ Stanovanjsk~ 52 55 45 33 52 40 29 30 ## 2 Ajdov~ Nestanovanj~ 19 9 22 15 27 11 23 11 ## 3 Ankaran~ Stanovanjsk~ NA NA NA NA NA NA NA NA ## 4 Ankaran~ Nestanovanj~ NA NA NA NA NA NA NA NA ## 5 Apae Stanovanjsk~ 10 11 22 12 7 5 9 10 ## 6 Apae Nestanovanj~ 3 3 8 3 4 6 2 3 ## 7 Beltinci Stanovanjsk~ 16 19 11 15 19 14 5 13 ## 8 Beltinci Nestanovanj~ 4 6 1 3 8 4 4 5 ## 9 Benedikt Stanovanjsk~ 11 12 6 9 7 3 16 10 ## 10 Benedikt Nestanovanj~ 3 2 1 3 5 3 4 3 ## # ... with 414 more rows, and 6 more variables: 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt;, ## # 2017 &lt;dbl&gt;, 2018 &lt;dbl&gt;, 2019 &lt;dbl&gt;, 2020 &lt;dbl&gt; Sedaj elimo te podatke spremeniti v isto obliko. Vse stolpce, ki prikazujejo razline vrednosti spremenljivke leto, moramo zapisati v 1 stolpec. Uporabimo funkcijo pivot_longer(), ki prejme argumente: data. Katere podatke elimo spremeniti. cols. V katerih stolpcih imamo vrednosti spremenljivke, ki jo elimo shraniti v 1 stolpec. df %&gt;% pivot_longer(cols = `2007`:`2020`) ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Sedaj imamo leta shranjena v stolpcu, prav tako pa vrednosti. Stolpca sta dobila privzeti meni name in value. Funkcija pivot_longer() pa lahko prejme e ve opcijskih argumentov, za nas bosta najbolj pomembna 2: names_to. Ime stolpca, v katerega bomo shranili spremenljivko. value_to. Ime stolpca, v katerega bomo shranili vrednosti. Uporabimo sedaj e ta 2 parametra: df_longer &lt;- df %&gt;% pivot_longer(cols = `2007`:`2020`, names_to = &quot;Leto&quot;, values_to = &quot;tevilo&quot;) df_longer ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE Leto tevilo ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows 2.4 pivot_wider(): pretvorba v iro obliko Obiajno bo ta transformacija naredila podatke neiste, vendar s tem ni ni narobe, saj imajo tudi takni podatki svoje prednosti: Podatki v iri obliki so loveku laje berljivi. Nekatera podjetja in podroja imajo razvite standarde, v katerih potrebujemo podatke v iri obliki. Nekatere metode, predvsem gre tukaj za metode strojnega uenja, delujejo bolje ali izkljuno s podatki v iri obliki. e elimo podatke pretvoriti v matriko. Za pretvorbo podatkov v iro obliko uporabimo funkcijo pivot_wider(), ki prejme dva argumenta: names_from. Ime stolpca, katerga elimo raztegniti v iro obliko. values_from. Ime stolpca, v katerem so shranjene vrednosti. Pretvorimo sedaj df_longer v iro obliko glede na stolpec TIP.STAVBE. df_wider &lt;- df_longer %&gt;% pivot_wider(names_from = TIP.STAVBE, values_from = tevilo) df_wider[1:14, ] ## # A tibble: 14 x 4 ## OBINE Leto `Stanovanjske stavbe` `Nestanovanjske stavbe` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina 2007 52 19 ## 2 Ajdovina 2008 55 9 ## 3 Ajdovina 2009 45 22 ## 4 Ajdovina 2010 33 15 ## 5 Ajdovina 2011 52 27 ## 6 Ajdovina 2012 40 11 ## 7 Ajdovina 2013 29 23 ## 8 Ajdovina 2014 30 11 ## 9 Ajdovina 2015 38 49 ## 10 Ajdovina 2016 31 66 ## 11 Ajdovina 2017 33 60 ## 12 Ajdovina 2018 42 36 ## 13 Ajdovina 2019 38 39 ## 14 Ajdovina 2020 42 46 S taknim prikazom lahko relativno hitro opazimo doloene trende. Na primer v Ajdovini se je gradilo veliko ve stanovanjskih stavb med leti 2007 in 2014, leta 2015 pa se je oitno zaelo graditi ve nestanovanjskih stavb, kar bi lahko nakazovalo na gospodarsko rast tega mesta. Za loveka je torej tak prikaz bolji. Vsekakor pa bi v tem primeru raje uporabili vizualizacijo. 2.5 separate() in unite(): deljenje in zdruevanje stolpcev V uvodu tega poglavja smo prikazali podatke, kjer sta bili dve spremenljivki shranjeni v enem stolpcu. Poglejmo si te podatke e enkrat: df &lt;- read_csv2(&quot;./data-raw/SLO-gradbena-dovoljenja-messy2.csv&quot;, locale = readr::locale(encoding = &quot;cp1250&quot;)) df ## # A tibble: 5,936 x 3 ## OBINA_TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina_Stanovanjske stavbe 2007 52 ## 2 Ajdovina_Stanovanjske stavbe 2008 55 ## 3 Ajdovina_Stanovanjske stavbe 2009 45 ## 4 Ajdovina_Stanovanjske stavbe 2010 33 ## 5 Ajdovina_Stanovanjske stavbe 2011 52 ## 6 Ajdovina_Stanovanjske stavbe 2012 40 ## 7 Ajdovina_Stanovanjske stavbe 2013 29 ## 8 Ajdovina_Stanovanjske stavbe 2014 30 ## 9 Ajdovina_Stanovanjske stavbe 2015 38 ## 10 Ajdovina_Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Vasih se sreamo celo z dvema vrednostima v istem stolpcu. Da loimo ti spremenljivki na dva stolpca uporabimo funkcijo separate(): separate(&lt;podatki&gt;, col = &lt;ime-stolpca&gt;, into = &lt;ime-novih-stolpcev&gt;, sep = &lt;znak-ki-locuje&gt;) Uporabimo sedaj to funkcijo da pretvorimo df v isto obliko: df_tidy &lt;- df %&gt;% separate(col = &quot;OBINA_TIP&quot;, into = c(&quot;OBINA&quot;, &quot;TIP&quot;), sep = &quot;_&quot;) df_tidy ## # A tibble: 5,936 x 4 ## OBINA TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Obstaja pa tudi obratna operacija unite(), ki zdrui dva stolpca: unite(&lt;podatki&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ..., sep = &lt;znak-ki-locuje&gt;) Pri tem tri pikice prestavljajo morebitne preostale stolpce, saj jih lahko zdruimo ve. Za primer si poglejmo, kako bi v eno spremenljivko shranili podatke o tevilu stanovanjskih in nestanovanjskih gradbenih dovoljenj. Najprej pretvorimo podatke v iro obliko glede na tip, potem pa ta nova stolpca zdruimo s funkcijo unite(). df_wider &lt;- df_tidy %&gt;% pivot_wider(names_from = TIP, values_from = tevilo.gradbenih.dovoljenj) %&gt;% unite(&quot;Stanovanjske/Nestanovanjske&quot;, &quot;Stanovanjske stavbe&quot;, &quot;Nestanovanjske stavbe&quot;, sep = &quot;/&quot;) df_wider ## # A tibble: 2,968 x 3 ## OBINA Leto `Stanovanjske/Nestanovanjske` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Ajdovina 2007 52/19 ## 2 Ajdovina 2008 55/9 ## 3 Ajdovina 2009 45/22 ## 4 Ajdovina 2010 33/15 ## 5 Ajdovina 2011 52/27 ## 6 Ajdovina 2012 40/11 ## 7 Ajdovina 2013 29/23 ## 8 Ajdovina 2014 30/11 ## 9 Ajdovina 2015 38/49 ## 10 Ajdovina 2016 31/66 ## # ... with 2,958 more rows 2.6 Relacijske zbirke podatkov Pogosto se pri analizi podatkov sreamo z razpredelnicami, ki so med seboj logino povezane. Nekaj primerov: V spletni trgovini lahko hranimo podatke v 3 razpredelnicah o produktih, kupcih in nakupih. Razpredelnice so med seboj povezane, na primer razpredelnica o nakupih vsebuje ID kupca in produkta. Baze podatkov o filmih, kot je IMDB, imajo na primer podatke o filmih, ocenjevalcih, igralcih in ocenah. Filmi povezujejo vse preostale razpredelnice. Bioloke podatkovne zbirke lahko imajo razpredelnice atomov, molekul in vezi. Pri eleznikem omreju imamo razpredelnice z vlaki, vagoni, eleznikimi postajami, prihodi in odhodi. Pri nogometu imamo razpredelnice z igralci, klubi in odigranimi tekmami. Taknim podatkovnim zbirkam pravimo relacijske zbirke podatkov, saj so poleg podatkov v razpredelnicah pomembne tudi relacije oziroma povezave med razpredelnicami. Zaenkrat smo se nauili, kako urejati podatke v eni razpredelnici. e elimo analizirati relacijske podatke, moramo znati upotevati tudi povezave med njimi in jih ustrezno zdruevati. V tem poglavju bomo predelali operacije, ki nam to omogoajo. Morda ste se e sreali z jezikom SQL, ki se obiajno uporablja za urejanje podatkov v sistemih za upravljanje relacijskih podatkovnih baz (ang. relational database management systems, RDBMS). Paket dplyr ima podobno sintakso kot SQL, vendar pa ni popolnoma enaka. Je tudi enostavneji za uporabo pri analizi podatkov, saj je ustvarjen prav s tem namenom. 2.7 Primer: Banni podatki V tem poglavju bomo delali s podatki eke banke (https://data.world/lpetrocelli/czech-financial-dataset-real-anonymized-transactions, https://relational.fit.cvut.cz/dataset/Financial). Gre za realno anonimizirano podatkovno zbirko, ki je bila uporabljena v izzivu PKDD99 Discovery Challenge (https://sorry.vse.cz/~berka/challenge/pkdd1999/berka.htm). Cilj izziva je bil odkriti dobre in slabe kliente z namenom izboljanja ponudbe. Mi bomo te podatke uporabili za ilustracijo operacij na relacijski zbirki podatkov. V mapi data_raw/financial se nahaja 5 razpredelnic v csv formatu: account.csv, client.csv, disp.csv, loan.csv in transaction-smaller.csv. Izvirni podatki vsebujejo e nekaj razpredelnic, vendar jih bomo z namenom uinkovitega prikaza izpustili. Prav tako smo pri razpredelnici transaction.csv nakljuno izbrali 20000 vrstic, saj originalna datoteka vsebuje preko milijon vrstic, kar bi upoasnilo izvajanje ukazov in zasedlo veliko prostora na repozitoriju. V kolikor elite raziskati celotno zbirko, predlagamo, da si podatke prenesete iz vira. Poglejmo si sedaj vsako izmed razpredelnic. Razpredelnica account vsebuje podatke o raunih na banki. account &lt;- read_csv2(&quot;./data-raw/financial/account.csv&quot;) account ## # A tibble: 4,500 x 4 ## account_id district_id frequency date ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; ## 1 1 18 monthly payment 1995-03-24 ## 2 2 1 monthly payment 1993-02-26 ## 3 3 5 monthly payment 1997-07-07 ## 4 4 12 monthly payment 1996-02-21 ## 5 5 15 monthly payment 1997-05-30 ## 6 6 51 monthly payment 1994-09-27 ## 7 7 60 monthly payment 1996-11-24 ## 8 8 57 monthly payment 1995-09-21 ## 9 9 70 monthly payment 1993-01-27 ## 10 10 54 monthly payment 1996-08-28 ## # ... with 4,490 more rows Razpredelnica client vsebuje podatke o strankah. client &lt;- read_csv2(&quot;./data-raw/financial/client.csv&quot;) client ## # A tibble: 5,369 x 4 ## client_id gender birth_date district_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 1 F 1970-12-13 18 ## 2 2 M 1945-02-04 1 ## 3 3 F 1940-10-09 1 ## 4 4 M 1956-12-01 5 ## 5 5 F 1960-07-03 5 ## 6 6 M 1919-09-22 12 ## 7 7 M 1929-01-25 15 ## 8 8 F 1938-02-21 51 ## 9 9 M 1935-10-16 60 ## 10 10 M 1943-05-01 57 ## # ... with 5,359 more rows Razpredelnica disp povee podatke o osebah in raunih, torej, katere osebe imajo pravico opravljati s katerimi rauni. disp &lt;- read_csv2(&quot;./data-raw/financial/disp.csv&quot;) disp ## # A tibble: 5,369 x 4 ## disp_id client_id account_id type ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 1 1 OWNER ## 2 2 2 2 OWNER ## 3 3 3 2 DISPONENT ## 4 4 4 3 OWNER ## 5 5 5 3 DISPONENT ## 6 6 6 4 OWNER ## 7 7 7 5 OWNER ## 8 8 8 6 OWNER ## 9 9 9 7 OWNER ## 10 10 10 8 OWNER ## # ... with 5,359 more rows Razpredelnica loan vsebuje podatke o posojilih. loan &lt;- read_csv2(&quot;./data-raw/financial/loan.csv&quot;) loan ## # A tibble: 682 x 7 ## loan_id account_id date amount duration payments status ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 4959 2 1994-01-05 80952 24 3373 A ## 2 4961 19 1996-04-29 30276 12 2523 B ## 3 4962 25 1997-12-08 30276 12 2523 A ## 4 4967 37 1998-10-14 318480 60 5308 D ## 5 4968 38 1998-04-19 110736 48 2307 C ## 6 4973 67 1996-05-02 165960 24 6915 A ## 7 4986 97 1997-08-10 102876 12 8573 A ## 8 4988 103 1997-12-06 265320 36 7370 D ## 9 4989 105 1998-12-05 352704 48 7348 C ## 10 4990 110 1997-09-08 162576 36 4516 C ## # ... with 672 more rows Razpredelnica trans vsebuje podatke o transakcijah. trans &lt;- read_csv2(&quot;./data-raw/financial/transaction-smaller.csv&quot;) trans ## # A tibble: 20,000 x 10 ## trans_id account_id date type operation amount balance k_symbol bank ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 736882 2517 1997-07-17 CHOICE CHOICE 21992 22279 &lt;NA&gt; &lt;NA&gt; ## 2 201830 686 1997-05-08 INCOME DEPOSIT 10533 18473 &lt;NA&gt; &lt;NA&gt; ## 3 3158278 10478 1998-01-29 EXPEN~ CHOICE 2100 8821 &lt;NA&gt; &lt;NA&gt; ## 4 41116 135 1994-05-09 EXPEN~ CHOICE 2900 21513 &lt;NA&gt; &lt;NA&gt; ## 5 1046207 3578 1996-09-08 EXPEN~ TRANSFER~ 4051 51755 SIPO KL ## 6 875501 2982 1997-04-30 EXPEN~ CHOICE 12100 41859 &lt;NA&gt; &lt;NA&gt; ## 7 893918 3047 1996-11-30 EXPEN~ CHOICE 15 24788 SERVICES &lt;NA&gt; ## 8 3442751 1543 1998-07-31 INCOME &lt;NA&gt; 71 17153 UROK &lt;NA&gt; ## 9 462371 1571 1998-08-25 EXPEN~ CHOICE 2760 25770 &lt;NA&gt; &lt;NA&gt; ## 10 1028586 3513 1993-10-12 EXPEN~ TRANSFER~ 4507 31227 SIPO KL ## # ... with 19,990 more rows, and 1 more variable: account &lt;dbl&gt; Imamo 5 razpredelnice, vse pa so med seboj povezane. Razpredelnici account in client sta povezani preko razpredelnice disp. Razpredelnici loan in transsta povezani z razpredelnico account preko spremenljivke account_id. To strukturo najbolje prikaemo z relacijskim diagramom. Relacijski diagram 2.8 Kljui Spremenljivkam, ki povezujejo razpredelnice, pravimo kljui. Te spremenljivke (ali zbirke spremenljivk) edinstveno definirajo podatke. Lahko gre za eno spremenljivko, kot je na primer account_id v razpredelnici account. Lahko pa obstaja ve spremenljivk, ki definirajo en podatek. Na primer, e imamo razpredelnico s temperaturami za vsak dan in uro. Potem ni nujno, da ima vsaka vrstica svoj ID, lahko pa jih edinstveno loimo na podlagi dveh spremenljivk  dneva in ure. V tem primeru gre torej za klju, ki je sestavljen iz dveh spremenljivk. Poznamo dva glavna tipa kljuev: Primarni klju. Ta klju edinstveno definira podatek v razpredelnici. Na primer, trans_id v razpredelnici trans. V urejenih podatkih ima vsaka tabela svoj primarni klju. Tuj klju. To je klju v razpredelnici, ki je primarni klju v eni od preostalih razpredelnic. Na primer, account_id v razpredelnici trans. Vrednosti tujih kljuev se lahko podvajajo. Na primer, ve transakcij lahko ima isto vrednost tujega kljua za account_id, saj se na enem bannem raunu izvede ve transakcij. V kolikor razpredelnica nima primarnega kljua, lahko ustvarimo t. i. nadomestni klju, ki igra vlogo primarnega kljua. To lahko naredimo na primer tako, da vsaki vrstici priredimo njeno zaporedno vrednost v razpredelnici. Na primer mutate(row_number()). Primarni in tuj klju skupaj tvorita relacijo med razpredelnicama. Na primer account_id predstavlja relacijo med razpredelnicama trans in account. Relacije so lahko ena-proti-ena (ena drava ima enega predsednika in ena oseba je lahko predsednik samo ene drave), ena-proti-mnogo (en igralec lahko igra za en klub, ampak en klub ima ve igralcev) ali mnogo-proti-mnogo (en avtor lahko napie ve knjig in ena knjiga je lahko napisana s strani veih avtorjev). Kadar imamo opravka z relacijskimi podatki, je smiselno preveriti, ali je primarni klju res edinstven za vsako razpredelnico. df_list &lt;- list(account, client, disp, trans, loan) id_vec &lt;- c(&quot;account_id&quot;, &quot;client_id&quot;, &quot;disp_id&quot;, &quot;trans_id&quot;, &quot;loan_id&quot;) for (i in 1:length(df_list)) { tmp &lt;- df_list[[i]] %&gt;% group_by(.data[[id_vec[i]]]) %&gt;% summarise(n = n()) %&gt;% filter(n &gt; 1) print(tmp) } ## # A tibble: 0 x 2 ## # ... with 2 variables: account_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: client_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: disp_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: trans_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: loan_id &lt;dbl&gt;, n &lt;int&gt; V prejnjem klicu kode se pojavi nova sintaksa, in sicer .data[[id_vec[i]]]. Funkcija group_by() uporablja t. i. tidyselect, s katerim izbiramo stolpce brez da bi jih dali v narekovaje. To pa predstavlja teavo, kadar so imena stolpcev shranjena v neki spremenljivki, kot v tem primeru. Tidyverse je ustvarjen na naelu, da olaja bolj pogoste operacije (na primer, enostavno uporaba group_by() pri urejanju posamezne razpredelnice), za ceno teje izvedbe manj pogostih operacij (na primer, uporaba group_by() v zanki for). Veliko veino urejanja podatkov bomo lahko z uporabo tidyverse naredili brez uporabe zank ali naprednih lastnih funkcij. V kolikor se boste lotili bolj programerskega pristopa, pa predlagamo, da si preberete navodila za programiranje z dplyr, ki jih dobite tako, da v konzoli kliete vignette('programming'). Na tej delavnici ne bomo predstavili podrobnosti teh pristopov. Zaenkrat je dovolj, da poznamo samo zgornji klic. Torej, e imamo imena stolpcev shranjena v neki spremenljivki, potem moramo znotraj tidyselecta uporabiti .data[[&lt;spremenljivka-z-imeni-stolpcev&gt;]]. 2.9 Zdruevanja Kadar imamo opravka z veimi razpredelnicami potrebujemo orodja, s katerimi lahko posamezne pare razpredelnic zdruimo. Vei uporabniki R morda e poznajo funkcijo merge, ki je del osnovne razliice R in je namenjena splonemu zdruevanju razpredelnic. Seveda pa tidyverse premore svoje razliice podobnih funkcij, ki premorejo enake lastnosti kot preostale funkcije v tej zbirki  prejmejo in vrnejo podatke v enakem formatu in sicer tibblu. Poleg tega so funkcije iz paketa dplyr tudi hitreje od merge, kar ima pomembno vlogo, kadar imamo opravka z nekoliko vejimi podatkovnimi mnoicami. Zdruevanja podatkovnih razpredelnic lahko loimo na 3 sklope: Mutirajoa zdruevanja (ang. mutating joins). Dodajo nove stolpce k razpredelnici iz ujemajoih vrstic druge razpredelnice. Filtrirajoa zdruevanja (ang. filtering joins). Izberejo vrstice ene razpredenice glede na to, ali se te ujemajo z vrsticami v drugi razpredelnici. Operacije nad mnoicami. Operirajo nad vrsticami, kot da so ti deli mnoice. 2.9.1 Mutirajoa zdruevanja Mutirajoa zdruevanja so pogosta operacija pri delu z relacijskimi podatki. Te operacije zdruijo dve (ali ve) razpredelnici glede na vrednosti stolpcev. Obstajajo 4 takne operacije: left_join(). Ohrani vse vrstice prve (leve) razpredelnice in povee ustrezne vrstice iz druge razpredelnice s temi vrsticami. right_join(). Ohrani vse vrstice druge (desne) razpredelnice in povee ustrezne vrstice iz prve rapredelnice s temi vrsticami. full_join(). Ohrani vse vrstice obeh razpredelnic. inner_join(). Ohrani samo tiste vrstice, ki se pojavijo v obeh razpredelnicah. Prvi trije so tako imenovani zunanji stiki (outer join), saj uporabijo vrstice, ki se pojavijo vsaj v eni razpredelnici. Za laje razumevanje bomo najprej prikazali uporabo stikov na podatkih, ki jih bomo ustvarili sami. Sintaksa pri vseh zdruevanjih je: left_join(&lt;razpredelnica1&gt;, &lt;razpredelnica2&gt;) Ustvarimo dva tibbla: df1 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), x = c(4, 6, 1, 2) ) df2 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id3&quot;, &quot;id4&quot;, &quot;id5&quot;), y = c(20, 52, 11, 21) ) df1 ## # A tibble: 4 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 1 ## 4 id4 2 df2 ## # A tibble: 4 x 2 ## id y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id3 52 ## 3 id4 11 ## 4 id5 21 left_join() obdri tibble df1 taken kot je in mu pripne stolpec y iz tibbla df2, kjer so vrednosti spremenljivke id enake. Za tiste vrstice df1, ki nimajo ustreznega id v df2 se vrednosti v spremenljivki y nastavijo na NA. left_join(df1, df2) ## # A tibble: 4 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id2 6 NA ## 3 id3 1 52 ## 4 id4 2 11 right_join() obdri tibble df2 taken kot je in mu pripne stolpec x iz tibbla df1, kjer so vrednosti spremenljivke id enake. Za tiste vrstice df2, ki nimajo ustreznega id v df1, se vrednosti v spremenljivki y nastavijo na NA. right_join(df1, df2) ## # A tibble: 4 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id3 1 52 ## 3 id4 2 11 ## 4 id5 NA 21 inner_join() obdri samo tiste podatke, kjer se id nahaja v obeh razpredelnicah (torej 1, 3 in 4). Vse preostale vrstice zavre. inner_join(df1, df2) ## # A tibble: 3 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id3 1 52 ## 3 id4 2 11 full_join() obdri vse podatke iz df1 in df2. Kjer ni ustreznega id v nasprotni razpredelnici se vrednosti nastavijo na NA. full_join(df1, df2) ## # A tibble: 5 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id2 6 NA ## 3 id3 1 52 ## 4 id4 2 11 ## 5 id5 NA 21 Najbolj pogosto bomo uporabljali left_join(), kadar bo cilj obdrati originalno razpredelnico, kot je, ali inner_join(), kadar bomo eleli podatke brez manjkajoih vrednosti. Stik right_join() je samo drugae usmerjen left_join(). Do sedaj smo prikazovali, kako zdruimo razpredelnice glede na primarni klju, za katerega predpostavljamo, da je unikaten. Torej vsaka vrstica ima svoj klju, ki se v razpredelnici ne ponovi. Vasih pa razpredelnice zdruujemo glede na sekundarni klju. V tem primeru se lahko zgodi, da imamo relacijo ena-proti-mnogo. e vzamemo banne podatke od zgoraj ima lahko en raun ve skrbnikov. Kaj se zgodi v tem primeru? Kaj pa e zdruimo transakcije in osebe glede na raun? En raun ima lahko ve transakcij in ve skrbnikov. Ker pri obeh razpredelnicah uporabimo sekundarni klju, bomo najverjetneje dobili podvojene vrednosti pri obeh. Poglejmo si sedaj na primeru podatkov, ki jih generiramo sami. df3 &lt;- tibble( id1 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), id2 = c(&quot;id1&quot;, &quot;id1&quot;, &quot;id3&quot;, &quot;id4&quot;), x = c(5, 6, 1, 2) ) df4 &lt;- tibble( id2 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;), y = c(20, 52, 11) ) df5 &lt;- tibble( id3 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), id2 = c(&quot;id1&quot;, &quot;id1&quot;, &quot;id4&quot;, &quot;id5&quot;), z = c(5, 1, 23, 5) ) df3 ## # A tibble: 4 x 3 ## id1 id2 x ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 ## 2 id2 id1 6 ## 3 id3 id3 1 ## 4 id4 id4 2 df4 ## # A tibble: 3 x 2 ## id2 y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id2 52 ## 3 id3 11 df5 ## # A tibble: 4 x 3 ## id3 id2 z ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 ## 2 id2 id1 1 ## 3 id3 id4 23 ## 4 id4 id5 5 df3 in df5 imata podvojen sekundarni klju. Zdruimo sedaj df3 in df4 z uporabo inner_join(). inner_join(df3, df4) ## # A tibble: 3 x 4 ## id1 id2 x y ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 id1 5 20 ## 2 id2 id1 6 20 ## 3 id3 id3 1 11 Klju torej ostane podvojen. Kaj pa se zgodi, e imata obe razpredelnici podvojene kljue? V tem primeru dobimo kartezini produkt vseh podvojenih vrednosti: inner_join(df3, df5) ## # A tibble: 5 x 5 ## id1 id2 x id3 z ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 id1 5 ## 2 id1 id1 5 id2 1 ## 3 id2 id1 6 id1 5 ## 4 id2 id1 6 id2 1 ## 5 id4 id4 2 id3 23 df3 in df5 imata podvojeno vrednost kljua id1. Torej dobimo vse kombinacije preostalih vrednosti (5, 5), (5, 1), (6, 5) in (6, 1). 2.9.2 Argument by Zdruevanja, ki smo jih spoznali, privzeto zdruijo razpredelnici glede na vrednosti v vseh stolpcih, ki imajo enaka imena  tamu pravimo tudi naravno zdruevanje (ang. natural join). Lahko pa tudi sami doloimo, po katerih stolpcih elimo zdruiti podatke. To naredimo tako, da pri zdruevanjih uporabimo argument by. Sintaksa zdruevanj je potem: inner_join(&lt;razpredelnica1&gt;, &lt;razpredelnica2&gt;, by = &lt;vektor-imen-stolpcev&gt;) inner_join() dveh razpredelnic bi potem zapisali kot: inner_join(df3, df4, by = &quot;id2&quot;) ## # A tibble: 3 x 4 ## id1 id2 x y ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 id1 5 20 ## 2 id2 id1 6 20 ## 3 id3 id3 1 11 Ta primer slui samo kot ilustracija in je uporaba by nepotrebna. Seveda pa se pri realnih podatkih velikokrat sreamo s stanjem, kjer ta argument potrebujemo. Prav tako je koda s parametrom by bolj robustna, saj sami definiramo, glede na katere stolpce naj se razpredelnice zdruujejo in ne more priti do kaknih napak pri ponovljivosti. Razpredelnici lahko zdruimo tudi po stolpcih, ki nimajo istega imena. Ni nenavadno, da imamo dve razpredelnici z enakimi spremenljivkami, ki pa so poimenovane drugae. e bi eleli taki razpredelnici zdruiti glede na to spremenljivko, potem bi jo morali naeloma v eni razpredelnici preimenovati. S paketom dplyr pa lahko to naredimo tudi drugae. Zdruimo sedaj df3 in df5 glede na stolpca x in z ter skupni stolpec id2. inner_join(df3, df5, by = c(&quot;x&quot; = &quot;z&quot;, &quot;id2&quot;)) ## # A tibble: 1 x 4 ## id1 id2 x id3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id1 id1 5 id1 2.9.3 Filtrirajoa zdruevanja Pri filtrirajoih zdruevanjih ne gre toliko za zdruevanja, kolikor gre za izbiro posameznih vrstic, glede na ujemanje vrednotsti stolpcev v neki drugi razpredelnici. Poznamo 2 takni zdruevanji: semi_join(). Obdri vse vrstice v prvi razpredelnici, ki ustrezajo vrsticam v drugi razpredelnici. anti_join(). Izloi vse vrstice v prvi razpredelnici, ki ustrezajo vrsticam v drugi razpredelnici. Poglejmo si uporabo teh zdruevanj na naih generiranih razpredelnicah. df1 ## # A tibble: 4 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 1 ## 4 id4 2 df2 ## # A tibble: 4 x 2 ## id y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id3 52 ## 3 id4 11 ## 4 id5 21 semi_join(df1, df2) ## # A tibble: 3 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id3 1 ## 3 id4 2 semi_join() je torej izloil vrstico z id2, saj se ta ne pojavi v df2. anti_join(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id2 6 semi_join() je torej izloil vse vrstice, ki se pojavijo tudi v df2. Ostane torej samo vrstica z id2. 2.9.4 Zdruevanja na realnih podatkih Sedaj, ko smo spoznali glavne lastnosti razlinih zdruevanj na primerih, ki so nam omogoali lajo predstavo, pa se posvetimo realnim podatkom, ki smo jih predstavili v zaetku tega poglavja. Imamo torej podatke o bannih raunih, transakcijah, posojilih, skrbnikih raunov in povezovalno razpredelnico med rauni in skrbniki. Lotimo se sedaj relativno enostavne analize, kjer bomo naredili sledee: Ustvarili novo razpredelnico, kjer bomo imeli podatke o vseh bannih raunih in o lastnikih teh raunov. Lastnik rauna je lahko samo en, medtem ko je skrbnikov lahko ve. Filtrirali razpredelnico iz toke 1), v kateri bodo samo tisti, ki imajo posojila nad 100000 kron. Ustvarili novo razpredelnico klientov, kjer bomo imeli podatke o klientih in posojilih in bodo zajeti samo klienti s posojili. Izraunali kateri klienti, ki imajo posojilo, imajo tudi najve transakcij. Za vsakega izmed teh korakov bomo morali uporabiti eno od zdruevanj, ki smo jih spoznali. Na primer, v samih razpredelnicah nimamo direktne povezave med komitenti in transakcijami, tako da bomo morali zadeve nekako zdruiti. Podobno velja za ostale alineje. Najprej elimo zdruiti razpredelnici account in client. Za to bomo potrebovali povezovalno razpredelnico disp v kateri se tudi nahaja informacija o tem, ali je klient lastnik ali samo skrbnik rauna. Najprej poveemo razpredelnico account z razpredelnico disp in filtriramo glede na tip klienta: account_disp &lt;- left_join(account, disp) %&gt;% filter(type == &quot;OWNER&quot;) account_disp ## # A tibble: 4,500 x 7 ## account_id district_id frequency date disp_id client_id type ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 18 monthly payment 1995-03-24 1 1 OWNER ## 2 2 1 monthly payment 1993-02-26 2 2 OWNER ## 3 3 5 monthly payment 1997-07-07 4 4 OWNER ## 4 4 12 monthly payment 1996-02-21 6 6 OWNER ## 5 5 15 monthly payment 1997-05-30 7 7 OWNER ## 6 6 51 monthly payment 1994-09-27 8 8 OWNER ## 7 7 60 monthly payment 1996-11-24 9 9 OWNER ## 8 8 57 monthly payment 1995-09-21 10 10 OWNER ## 9 9 70 monthly payment 1993-01-27 12 12 OWNER ## 10 10 54 monthly payment 1996-08-28 13 13 OWNER ## # ... with 4,490 more rows Sedaj lahko to novo razpredelnico poveemo z razpredelnico client. account_client &lt;- left_join(account_disp, client) S tem smo dobili eljeno razpredelnico, v kateri imamo za vsak raun tudi informacijo o lastniku. Kot drugi korak elimo ustvariti razpredelnico, v kateri bodo samo podatki o klientih, ki imajo posojila v vrednosti ve kot 100000 kron. Najprej ustvarimo razpredelnico, v kateri so samo takna posojila, nato pa uporabimo semi_join(), ki bo iz razpredelnice account_client izbral samo vrstice, ki se bodo ujemale z vrsticami v tej novi razpredelnici posojil. loan_100k &lt;- loan %&gt;% filter(amount &gt; 100000) account_100k &lt;- semi_join(account_client, loan_100k) account_100k ## # A tibble: 0 x 9 ## # ... with 9 variables: account_id &lt;dbl&gt;, district_id &lt;dbl&gt;, frequency &lt;chr&gt;, ## # date &lt;date&gt;, disp_id &lt;dbl&gt;, client_id &lt;dbl&gt;, type &lt;chr&gt;, gender &lt;chr&gt;, ## # birth_date &lt;date&gt; Hmdobili smo prazen tibble, eprav obstajajo tako velika posojila. Zakaj je do tega prilo? V obeh razpredelnicah se nahajata spremenjivki account_id in date. Ampak spremenljivka date ni ista spremenljivka, pri razpredelnici account_client predstavlja, kdaj je bil raun odprt, pri loan_100k pa predstavlja kdaj je bilo posojilo odobreno. Torej po tej spremenljivki ne smemo zdruevati. Uporabimo by: account_100k &lt;- semi_join(account_client, loan_100k, by = &quot;account_id&quot;) account_100k ## # A tibble: 377 x 9 ## account_id district_id frequency date disp_id client_id type gender ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 37 20 monthly pay~ 1997-08-18 45 45 OWNER M ## 2 38 19 weekly paym~ 1997-08-08 46 46 OWNER F ## 3 67 16 monthly pay~ 1994-10-19 78 78 OWNER F ## 4 97 74 monthly pay~ 1996-05-05 116 116 OWNER M ## 5 103 44 monthly pay~ 1996-03-10 124 124 OWNER M ## 6 105 21 monthly pay~ 1997-07-10 127 127 OWNER F ## 7 110 36 monthly pay~ 1996-07-17 132 132 OWNER M ## 8 173 66 monthly pay~ 1993-11-26 210 210 OWNER M ## 9 226 70 monthly pay~ 1997-02-23 272 272 OWNER F ## 10 276 38 monthly pay~ 1997-12-08 333 333 OWNER M ## # ... with 367 more rows, and 1 more variable: birth_date &lt;date&gt; V naslednjem koraku elimo imeti podatke o klientih in posojilih. Najprej bomo morali zdruiti razpredelnici client in disp, nato pa dodati e razpredelnico loan. Ustvarimo to novo razpredelnico kar z uporabo operatorja %&gt;%: client_loan &lt;- client %&gt;% left_join(disp) %&gt;% inner_join(loan, by = &quot;account_id&quot;) client_loan ## # A tibble: 827 x 13 ## client_id gender birth_date district_id disp_id account_id type loan_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 M 1945-02-04 1 2 2 OWNER 4959 ## 2 3 F 1940-10-09 1 3 2 DISPONENT 4959 ## 3 25 F 1939-04-23 21 25 19 OWNER 4961 ## 4 31 M 1962-02-09 68 31 25 OWNER 4962 ## 5 45 M 1952-08-26 20 45 37 OWNER 4967 ## 6 46 F 1940-01-30 19 46 38 OWNER 4968 ## 7 78 F 1944-06-13 16 78 67 OWNER 4973 ## 8 116 M 1942-01-28 74 116 97 OWNER 4986 ## 9 117 F 1936-09-20 74 117 97 DISPONENT 4986 ## 10 124 M 1967-09-21 44 124 103 OWNER 4988 ## # ... with 817 more rows, and 5 more variables: date &lt;date&gt;, amount &lt;dbl&gt;, ## # duration &lt;dbl&gt;, payments &lt;dbl&gt;, status &lt;chr&gt; Na koncu preverimo e, kateri klienti, ki imajo posojilo, imajo najve transakcij. Za to bomo morali najprej izraunati tevilo transakcij na vsakem bannem raunu. Uporabimo znanje, ki smo ga pridobili na prvem predavanju: trans_count &lt;- trans %&gt;% group_by(account_id) %&gt;% summarise(n_trans = n()) trans_count ## # A tibble: 4,205 x 2 ## account_id n_trans ## &lt;dbl&gt; &lt;int&gt; ## 1 1 6 ## 2 2 10 ## 3 3 3 ## 4 4 6 ## 5 5 3 ## 6 6 8 ## 7 7 3 ## 8 8 7 ## 9 9 3 ## 10 10 1 ## # ... with 4,195 more rows left_join(client_loan, trans_count) %&gt;% arrange(desc(n_trans)) ## # A tibble: 827 x 14 ## client_id gender birth_date district_id disp_id account_id type loan_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 11126 F 1965-01-22 1 10818 9034 OWNER 6820 ## 2 6367 M 1970-04-28 44 6367 5270 OWNER 6077 ## 3 7291 F 1940-12-02 77 7291 6034 OWNER 6228 ## 4 7195 M 1962-09-11 50 7195 5952 OWNER 6216 ## 5 4620 F 1940-11-01 54 4620 3834 OWNER 5754 ## 6 4621 M 1946-02-10 54 4621 3834 DISPONENT 5754 ## 7 11461 M 1974-07-08 70 11153 9307 OWNER 6895 ## 8 11866 M 1937-09-02 1 11558 9640 OWNER 6960 ## 9 11867 F 1934-11-19 1 11559 9640 DISPONENT 6960 ## 10 13657 F 1963-05-12 59 13349 11111 OWNER 7259 ## # ... with 817 more rows, and 6 more variables: date &lt;date&gt;, amount &lt;dbl&gt;, ## # duration &lt;dbl&gt;, payments &lt;dbl&gt;, status &lt;chr&gt;, n_trans &lt;int&gt; 2.10 Operacije nad mnoicami V tem poglavju si bomo ogledali operacije nad mnoicami. Te delujejo nad vektorji, prav tako pa nad data.frame oziroma nad tibbli. Poznamo 3 glavne operacije: Unija. Vrne vse elemente, ki se pojavijo v eni ali drugi mnoici. Presek. Vrne vse elemente, ki se pojavijo v obeh mnoicah. Razlika. Vrne vse elemente prve mnoice, ki se ne pojavijo v drugi mnoici. Poglejmo si uporabo teh operacij nad tibbli. df1 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id2&quot;), x = c(4, 6) ) df2 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id3&quot;), x = c(4, 52) ) df1 ## # A tibble: 2 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 df2 ## # A tibble: 2 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id3 52 union(df1, df2) ## # A tibble: 3 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 52 intersect(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 setdiff(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id2 6 setdiff(df2, df1) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id3 52 2.11 Ali elite izvedeti ve? Hadley Wickham je objavil znanstveni lanek na temo urejenih podatkov: https://vita.had.co.nz/papers/tidy-data.pdf, ki je vsekakor vreden branja. Za ve informacij o neurejenih podatkih in v katerih primerih so lahko celo bolj zaeljeni, predlagamo ta blog: https://simplystatistics.org/2016/02/17/non-tidy-data/. 2.12 Domaa naloga Spodaj imamo podatke o strokih za 4 osebe. Razpredelnica je v neurejeni obliki. Vaa naloga je, da jo pretvorite v urejeno obliko. podatki_o_stroskih &lt;- tibble( ime = c(&quot;Miha&quot;, &quot;Ana&quot;, &quot;Andrej&quot;, &quot;Maja&quot;), april_2019 = c(400, 200, 300, 350), maj_2019 = c(390, 250, 280, 400), april_2020 = c(410, 150, 500, 400), maj_2020 = c(300, 320, 550, 320) ) Reitev: ## # A tibble: 16 x 4 ## ime mesec leto strosek ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Miha april 2019 400 ## 2 Miha maj 2019 390 ## 3 Miha april 2020 410 ## 4 Miha maj 2020 300 ## 5 Ana april 2019 200 ## 6 Ana maj 2019 250 ## 7 Ana april 2020 150 ## 8 Ana maj 2020 320 ## 9 Andrej april 2019 300 ## 10 Andrej maj 2019 280 ## 11 Andrej april 2020 500 ## 12 Andrej maj 2020 550 ## 13 Maja april 2019 350 ## 14 Maja maj 2019 400 ## 15 Maja april 2020 400 ## 16 Maja maj 2020 320 V mapi data-raw se nahajajo podatki o predsednikih volitvah v ZDA. Najprej izberite samo podmnoico vrstic, kjer sta kandidata Joe Biden ali Donald Trump, in izloite stolpec party. Nato pretvorite podatke v iro obliko, tako da bo vsak izmed kandidatov imel svoj stolpec. ## # A tibble: 4,633 x 4 ## state county `Joe Biden` `Donald Trump` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Delaware Kent County 44518 40976 ## 2 Delaware New Castle County 194238 87685 ## 3 Delaware Sussex County 56657 71196 ## 4 District of Columbia District of Columbia 29509 1149 ## 5 District of Columbia Ward 2 24247 2365 ## 6 District of Columbia Ward 3 33584 2972 ## 7 District of Columbia Ward 4 35117 1467 ## 8 District of Columbia Ward 5 36585 1416 ## 9 District of Columbia Ward 6 44699 3360 ## 10 District of Columbia Ward 7 30253 885 ## # ... with 4,623 more rows Pri bannih podatkih smo zaenkrat delali samo s petimi razpredelnicami. Celotna zbirka je nekoliko veja, saj vsebuje e 3 razpredelnice. V mapi data-raw/financial-hw/ se nahajajo e preostale razpredelnice. Pri nalogi bomo uporabili razpredelnico district, ki vsebuje podatke o okrajih. Vsekakor pa se lahko za lastno vajo poigrate e s preostalima dvema. Vae naloge so: Preberite podatke o okrajih v R. Ugotovite, kaj je primarni klju te razpredelnice. Ustrezno dopolnite entitetni diagram. To lahko naredite rono, v kolikor pa se elite nauiti narediti bolj profesionalne diagrame pa predlagamo spletno orodje https://app.diagrams.net/. V mapi support-files se nahaja na diagram. Tega lahko enostavno naloite v to orodje in ga dopolnite. Poiite 3 pokrajine (A3) z najvejo povpreno vrednostjo posojil. ## # A tibble: 3 x 2 ## A3 mean_loan ## &lt;chr&gt; &lt;dbl&gt; ## 1 east Bohemia 165997. ## 2 south Bohemia 156236. ## 3 central Bohemia 155392. Teka naloga. Namestite paket nycflights13. Gre za relacijsko podatkovno zbirko o letih iz New Yorka v letu 2013. Naloite podatke z library(nycflights13). Uporabljali bomo tiri razpredelnice: flights, weather, airlines in planes. Vaa naloga je: Poizkusite najti primarni klju za razpredelnico flights. Ali gre za primarni klju lahko preverite tako, da preverite ali ta klju unikatno doloa vrstico v podatkih, torej da pretejete podatke, grupirane glede na ta klju. Klju je lahko sestavljen tudi iz veih spremenljivk. Na prvi pogled bi rekli, da je primarni klju tevilka leta, ampak temu ni tako (preverimo s tetjem). Ali je morda kakna druga kombinacija spremenljivk? Lahko da razpredelnica nima primarnega kljua. V tem primeru doloite nadomestni klju tako, da dodate stolpec ID z mutate(ID = row_number()). Ugotovite, kaj so primarni in kaj tuji kljui preostalih razpredelnic. Pri nekaterih razpredelnicah v tej zbirki bomo imeli sestavljene kljue, torej bodo kljui sestavljeni iz veih stolpcev. Namig: Pri vremenu je manja napaka v podatkih in se tudi primarni klju ponovi v zanemarljivem tevilu primerov. Vsekakor so napake v realnih podatkih priakovane in moramo na to biti pozorni! Nariite relacijski diagram. Ustvarite novo razpredelnico tako da razpredelnici flights dodate podrobnosti o lastnostih letal za vsak let. ## # A tibble: 336,776 x 28 ## ID year.x month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2013 1 1 517 515 2 830 ## 2 2 2013 1 1 533 529 4 850 ## 3 3 2013 1 1 542 540 2 923 ## 4 4 2013 1 1 544 545 -1 1004 ## 5 5 2013 1 1 554 600 -6 812 ## 6 6 2013 1 1 554 558 -4 740 ## 7 7 2013 1 1 555 600 -5 913 ## 8 8 2013 1 1 557 600 -3 709 ## 9 9 2013 1 1 557 600 -3 838 ## 10 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 20 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt;, year.y &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;, ## # model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt; Ustvarite novo razpredelnico tako da razpredelnici flights dodate podrobnosti o vremenu na letaliu vsak let. ## # A tibble: 336,776 x 30 ## ID year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2013 1 1 517 515 2 830 ## 2 2 2013 1 1 533 529 4 850 ## 3 3 2013 1 1 542 540 2 923 ## 4 4 2013 1 1 544 545 -1 1004 ## 5 5 2013 1 1 554 600 -6 812 ## 6 6 2013 1 1 554 558 -4 740 ## 7 7 2013 1 1 555 600 -5 913 ## 8 8 2013 1 1 557 600 -3 709 ## 9 9 2013 1 1 557 600 -3 838 ## 10 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 22 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour.x &lt;dttm&gt;, temp &lt;dbl&gt;, dewp &lt;dbl&gt;, humid &lt;dbl&gt;, wind_dir &lt;dbl&gt;, ## # wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;, ## # visib &lt;dbl&gt;, time_hour.y &lt;dttm&gt; Poiite vsa letala z 2 motorjema, ki so v New York priletela 5. aprila iz letalia Chicago Ohare Intl. ## # A tibble: 35 x 35 ## ID year.x month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 169022 2013 4 5 545 600 -15 710 ## 2 169051 2013 4 5 604 610 -6 739 ## 3 169062 2013 4 5 624 630 -6 755 ## 4 169086 2013 4 5 636 630 6 814 ## 5 169100 2013 4 5 653 700 -7 827 ## 6 169114 2013 4 5 659 700 -1 823 ## 7 169125 2013 4 5 720 725 -5 851 ## 8 169159 2013 4 5 752 759 -7 920 ## 9 169183 2013 4 5 810 815 -5 933 ## 10 169201 2013 4 5 823 830 -7 957 ## # ... with 25 more rows, and 27 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt;, year.y &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;, ## # model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;, ## # name &lt;chr&gt;, lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, ## # tzone &lt;chr&gt; Zelo teka naloga. V mapi data-raw se nahajajo podatki o kreditnih karticah v Tajvanu default of credit card clients.xlsx. Pridobili smo jih iz UCI Machine Learning repozitorija (Dua and Graff 2017). Podatki so bili uporabljeni v znanstveni raziskavi (Yeh and Lien 2009), kjer so napovedovali verjetnosti neplail v odvisnosti od preteklih transakcij na kartici in podatkov o lastnikih. Podatki so v xlsx datoteki. Bodite pozorni, da je prva vrstica datoteke nepomembna in se glava zane komaj v drugi vrstici. Trenutno so podatki v obliki, v kateri so zelo primerni kot vhodni podatek za kak model, na primer linearno regresijo. Vsekakor pa niso v primerni obliki za uinkotivo urejanje in hranjenje. Vaa naloga je, da podatke preberete v R in razpredelnico pretvorite v urejeno obliko. Predlagamo, da nalogo poizkusite reiti sami. Naloga zahteva precej razmisleka in tudi nekaj samostojne raziskave (na primer, kaj posamezni stolpci pomenijo  pomagate si lahko s spletno stranjo, iz katere smo prenesli podatke). V kolikor se vam zatakne, smo vam spodaj pripravili nekaj namigov: Najprej je potrebno razmisliti, kaj so spremenljivke. Na primer, ali sta PAY_1 in PAY_2 2 spremenljivki, ali predstavljata 1 spremenljivko, ki pa je razdeljena glede na neko drugo spremenljivko? Predlagamo da zanete ukaze tako, da razpredelnico spremenite v daljo obliko, kjer vse spremenljivke, ki se pojavijo v veih stolpcih, shranite v 1 stolpec. V novem stolpcu so celice sestavljene iz 2 spremenljivk. Ena od teh je ID meseca. Torej moramo ta stolpec loiti na 2 stolpca. Katero funkcijo uporabimo za to? Pri tem bo prav priel tudi argument te funkcije sep = -1, ki bo stolpec loil na zadnji znak v besedi in vse preostalo (na primer, beseda3 bo razdelil na beseda in 3). -1 predstavlja pri koliko znakih od konca proti zaetku naredimo loitev besede. V enem od teh dveh preostalih stolpcev imamo e vedno shranjene 3 spremenljivke, za katere bi bilo bolje, e so v 3 stolpcih. Ustrezno pretvorite tabelo. Na tej toki smo e skoraj pri koncu. ID mesecev al ne sovpada z zaporednimi tevili mesecev v letu. Predlagamo, da si ustvarite novo razpredelnico, ki bo mapirala ID mesecev v njihova zaporedna tevila. Potem pa to razpredelnico poveete z razpredelnico, kjer hranimo podatke. Kako naredimo to? Kadar zdruujemo razpredelnice moramo tudi biti pozorni na to, da so stolpci, ki jih zdruujemo, istega tipa. ## # A tibble: 180,000 x 10 ## ID LIMIT_BAL SEX EDUCATION MARRIAGE AGE MONTH PAY PAY_AMT BILL_AMT ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 20000 2 2 1 24 9 2 0 3913 ## 2 1 20000 2 2 1 24 8 2 689 3102 ## 3 1 20000 2 2 1 24 7 -1 0 689 ## 4 1 20000 2 2 1 24 6 -1 0 0 ## 5 1 20000 2 2 1 24 5 -2 0 0 ## 6 1 20000 2 2 1 24 4 -2 0 0 ## 7 2 120000 2 2 2 26 9 -1 0 2682 ## 8 2 120000 2 2 2 26 8 2 1000 1725 ## 9 2 120000 2 2 2 26 7 0 1000 2682 ## 10 2 120000 2 2 2 26 6 0 1000 3272 ## # ... with 179,990 more rows "]]
