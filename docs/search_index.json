[["index.html", "Urejanje podatkov Uvod Struktura te knjige Stil programske kode", " Urejanje podatkov Gregor Pir, Matej Piulin in Erik trumbelj 2021-06-09 Uvod Pri delu s podatki se sreujemo z razlinimi izzivi. Prvi izziv je zbiranje do podatkov. Takoj za tem pa se sooimo z drugim izzivom, ki obiajno zahteva najve naega asa  ienje in urejanje podatkov. V veini primerov so podatki v izvorni obliki namre neurejeni (ang. messy data). Ta knjiga je namenjena spoznanju osnovnih konceptov ienja in urejanja podatkov, ki nam bodo olajali nadaljnjo analizo in vizualizacijo. Vse koncepte bomo prikazali v programskem jeziku R. Podatkovne mnoice in izvorne datoteke te knjige so objavljene na Github repozitoriju. Cilj delavnice je spoznati: Najbolj uporabne funkcije za urejanje podatkov; Koncept t. i. urejenih (ang. tidy) podatkov; Dobre prakse dela z datumi, nizi in kategorinimi spremenljivkami. Za sistematino delo s podatki v R-ju je bil razvit skupek paketov, ki se imenuje tidyverse. Sestavljen je iz 8 temeljnih paketov: ggplot2. Vizualizacija podatkov s slovnico grafike (ang. grammar of graphics). dplyr. Laje urejanje podatkov, na primer izbiranje vrstic in stolpcev, dodajanje stolpcev, povzemanje in urejanje podatkov. Ta paket je glavna tema 1. predavanja. tidyr. Preoblikovanje podatkov med dolgo in iroko obliko, oziroma preoblikovanje podatkov v urejeno obliko. Ve o tem bomo povedali na 2. predavanju. readr. Uinkovito branje in shranjevanje podatkov. purrr. Funkcijsko programiranje v R. tibble. Moderna verzija data.frame. Tema 1. predavanja. stringr. Preprosteje delo z nizi. Tema 3. predavanja. forcats. Preprosteje delo s kategorinimi spremenljivkami. Tema 3. predavanja. Vseh 8 paketov lahko namestimo z enim ukazom: install.packages(&quot;tidyverse&quot;) Lahko pa namestimo tudi samo posamezne pakete: install.packages(&quot;dplyr&quot;) Struktura te knjige Vsako poglavje ima 3 sklope: Priprava. Ta sklop je namenjen temu, da se udeleenci pripravijo na predavanje. Ker bodo le-ta intenzivna in namenjena predstavitvi glavnih konceptov ter uporabi funkcij na praktinih primerih, je dobro, da poznamo osnovne klice uporabljenih funkcij. V pripravi si bomo na preprostih podatkih pogledali, kako izvajati osnovne klice funkcij v tidyverse. Za vsako pripravo je na voljo video. Priprava traja najve 30 minut. Jedro. V tem sklopu je zajeta vsebina posameznega predavanja in vasih dodatna snov, ki jo predelamo samostojno. Podrobneje opiemo posamezne koncepte in funkcije ter demonstriramo na praktinih primerih. Domaa naloga. Na koncu vsakega predavanja so vaje za utrjevanje. Poskusimo jih reiti sami. V tej knjigi bodo prikazani samo rezultati reitev brez postopka oziroma programske kode. V kolikor se nam zatakne, lahko preverimo reitev v izvornih datotekah Rmd, ki se nahajajo na repozitoriju. Nekatere naloge od nas zahtevaj, da kaj raziemo sami, z uporabo vgrajene pomoi ali spleta, kot smo to navajeni pri vsakodnevnem programerskem delu. Domaa naloga vsakega sklopa je sestavljena iz nekaj osnovnih nalog, ki ponovijo snov predavanj. Poleg teh pa so tudi teje naloge, pri kateri je potrebno koncepte uporabiti na realni podatkovni mnoici ali samostojno reiti probleme, ki jih na predavanju ne bomo predelali. Stil programske kode V tej knjigi bomo predelali potrebne koncepte za urejanje podatkov, kar nam bo omogoilo bolj kvalitetno in uinkovito delo s podatki. Poleg poznavanja teh orodij in konceptov pa nam analizo olaja tudi konsistenten stil programiranja. Dober stil programiranja za nae delo ni nujen, je pa vsekakor dobrodoel, saj je programska koda bolj berljiva. Zbirka paketov tidyverse ima tudi svoj stilski vodnik. Vsak stilski vodnik vsebuje pravila, ki so doloena dokaj arbitrarno, oziroma glede na preference avtorja. Najbolj pomembno je, da smo pri pisanju programske kode konsistentni in stilski vodnik nam to nudi. "],["slovnica-ravnanja-s-podatki.html", "Poglavje 1 Slovnica ravnanja s podatki 1.1 Priprava 1.2 Sodobna razpredelnica: tibble 1.3 Urejeno ovrednotenje 1.4 Izbira vrstic s filter() 1.5 Izbira stolpcev s select() 1.6 Urejanje vrstic z arrange() 1.7 Dodajanje novih spremenljivk z mutate() 1.8 Povzemanje vrednosti s summarise() 1.9 Pipe 1.10 filter() in mutate() na zdruenih podatkih 1.11 Izvajanje operacij nad veimi stolpci z across() 1.12 Povzemanje stolpcev 1.13 Povzemanje vrstic 1.14 Dodatek 1.15 Ali elite izvedeti ve? 1.16 Domaa naloga", " Poglavje 1 Slovnica ravnanja s podatki Pri sistematinem delu s podatki je zelo pomembna berljivost in preglednost programske kode. Pri delu velikokrat delimo svojo programsko kodo z drugimi strokovnjaki, zato je zaeljeno, da je koda pregledna in razumljiva. Lahko se tudi zgodi, da imamo teave z razumevanjem svoje stareje kode. Zaradi tega je smiselno, da stremimo k imveji konsistentnosti in preglednosti. Na dolgi rok s tem prihranimo as  s konsistentno uporabo enakih ukazov postanemo bolj uinkoviti, prav tako pa laje prenesemo programsko kodo iz enega problema na drugega. Naa programska koda je s tem bolj robustna in ponovljiva, kar je pomembno iz vidika iskanja napak v analizah. Dober primer konsistentnosti in razumljivosti za sporazumevanje je naraven jezik  v kolikor dve osebi govorita enak jezik se bosta brez teav sporazumevali. Lahko si predstavljate, da ne boste imeli teav z razumevanjem teksta v slovenini, e se bo avtor dral slovninih in pravopisnih pravil. Tako kot se pri naravnem jeziku drimo doloenih pravil, lahko podobno doseemo tudi s programskim jezikom. V tem predavanju se bomo osredotoili na temeljne operacije, ki jih izvajamo nad podatki. Te operacije so nepogreljive pri vsaki analizi: izbira podmnoice vrstic, izbira podmnoice stolpcev, dodajanje stolpcev, ki so lahko izpeljani iz obstojeih stolpcev, urejanje razpredelnice glede na vrednosti stolpcev, povzemanje razpredelnic, na primer povpreja in vsote. Paket dplyr vsebuje funkcije, ki nam v primerjavi z osnovno razliico R-ja, te operacije olajajo. Temelji na t. i. slovnici ravnanja s podatki (ang. grammar of data manipulation), ki programsko kodo pretvori v nekaj podobnega naravnemu jeziku. Pri slovnici ravnanja s podatki poznamo 5 osnovnih glagolov, s katerimi preoblikujemo podatke. Vsak glagol ustreza eni izmed temeljnih operacij, ki smo jih omenili zgoraj. Programska koda se potem bere podobno kot naravni jezik  glagoli programskemu jeziku povedo, kaj naj s podatki naredi. Ti glagoli so implementirani v obliki funkcij: filter() Izbira podmnoice vrstic glede na izbrane pogoje. select() Izbira podmnoice stolpcev, glede na imena stolpcev. mutate() Dodajanje stolpcev, ki so lahko izpeljani iz obstojeih stolpcev. summarise() Povzemanje podatkov v razpredelnici. arrange() Urejanje razpredelnice. V tem predavanju bomo bolj podrobno spoznali vsakega izmed teh glagolov. Po tem pa si bomo ogledali e dva uporabna povzetka  povzemanje po vrsticah in povzemanje po stolpcih. .fold-btn { float: right; margin: 5px 5px 0 0; } .fold { border: 1px solid black; min-height: 40px; } 1.1 Priprava V pripravi se bomo nauili osnovnih klicev petih glagolov iz slovnice ravnanja s podatki. Hkrati bomo primerjali osnovno razliico R-ja z uporabo paketa dplyr. Pripravimo podatke: library(tidyverse) # Nalozimo celotno zbirko paketov tidyverse. df &lt;- data.frame( ime = c(&quot;Maja&quot;, &quot;Ales&quot;, &quot;Tom&quot;, &quot;Barbara&quot;, &quot;Simon&quot;, &quot;Tina&quot;), spol = c(&quot;z&quot;, &quot;m&quot;, &quot;m&quot;, &quot;z&quot;, &quot;m&quot;, &quot;z&quot;), starost = c(23, 54, 21, 35, 53, 21), visina = c(170, 180, 192, 168, 177, 182) ) S funkcijo filter() izberemo podmnoico vrstic v razpredelnici glede na izbrane pogoje. Izberimo enske nije od 180 centimetrov. # Osnovni R: df[df$spol == &quot;z&quot; &amp; df$visina &lt; 180, ] ## ime spol starost visina ## 1 Maja z 23 170 ## 4 Barbara z 35 168 # dplyr: filter(df, spol == &quot;z&quot;, visina &lt; 180) ## ime spol starost visina ## 1 Maja z 23 170 ## 2 Barbara z 35 168 Opazimo, da z uporabo dplyr ni potrebno vsaki pisati df$ pred imenom spremenljivke. Tukaj gre za t. i. maskiranje podatkov (ang. data masking). Ve o tem v jedru poglavja. S funkcijo select() izberemo podmnoico stolpcev. Izberimo stolpce ime, spol in visina: # Osnovni R: df[ , c(&quot;ime&quot;, &quot;spol&quot;, &quot;visina&quot;)] ## ime spol visina ## 1 Maja z 170 ## 2 Ales m 180 ## 3 Tom m 192 ## 4 Barbara z 168 ## 5 Simon m 177 ## 6 Tina z 182 # dplyr: select(df, ime, spol, visina) ## ime spol visina ## 1 Maja z 170 ## 2 Ales m 180 ## 3 Tom m 192 ## 4 Barbara z 168 ## 5 Simon m 177 ## 6 Tina z 182 Opazimo, da nam pri uporabi dplyr stolpcev ni potrebno pisati v narekovajih. Tukaj gre za t. i. urejeno izbiranje (ang. tidy selection). Ve o tem v jedru poglavja. S funkcijo mutate() dodajamo stolpce. Dodajmo viino v metrih: # Osnovni R: df2 &lt;- df df2$visina_v_metrih &lt;- df2$visina / 100 df2 ## ime spol starost visina visina_v_metrih ## 1 Maja z 23 170 1.70 ## 2 Ales m 54 180 1.80 ## 3 Tom m 21 192 1.92 ## 4 Barbara z 35 168 1.68 ## 5 Simon m 53 177 1.77 ## 6 Tina z 21 182 1.82 # dplyr: mutate(df, visina_v_metrih = visina / 100) ## ime spol starost visina visina_v_metrih ## 1 Maja z 23 170 1.70 ## 2 Ales m 54 180 1.80 ## 3 Tom m 21 192 1.92 ## 4 Barbara z 35 168 1.68 ## 5 Simon m 53 177 1.77 ## 6 Tina z 21 182 1.82 S funkcijo arrange() urejamo razpredelnico. Uredimo osebe po starosti: # Osnovni R: df[order(df$starost), ] ## ime spol starost visina ## 3 Tom m 21 192 ## 6 Tina z 21 182 ## 1 Maja z 23 170 ## 4 Barbara z 35 168 ## 5 Simon m 53 177 ## 2 Ales m 54 180 # dplyr: arrange(df, starost) ## ime spol starost visina ## 1 Tom m 21 192 ## 2 Tina z 21 182 ## 3 Maja z 23 170 ## 4 Barbara z 35 168 ## 5 Simon m 53 177 ## 6 Ales m 54 180 S funkcijo summarise() povzamemo podatke. Obiajno se uporablja v kombinaciji z group_by(). Izraunajmo povpreno viino glede na spol: # Osnovni R: aggregate(visina ~ spol, data = df, FUN = mean) ## spol visina ## 1 m 183.0000 ## 2 z 173.3333 # dplyr: summarise(group_by(df, spol), povp_visina = mean(visina)) ## # A tibble: 2 x 2 ## spol povp_visina ## &lt;chr&gt; &lt;dbl&gt; ## 1 m 183 ## 2 z 173. Naloga: Poglejmo si nov primer podatkov. df &lt;- data.frame( podjetje = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;), panoga = c(&quot;proizvodnja&quot;, &quot;gostinstvo&quot;, &quot;proizvodnja&quot;, &quot;gostinstvo&quot;, &quot;proizvodnja&quot;), st_zaposlenih = c(100, 20, 110, 15, 20), dobicek = c(100000, 10000, 12000, 1000, 0) ) Z uporabo dplyr: Izberite vrstice, ki imajo med (vkljuno) 10000 in 20000 dobika. ## podjetje panoga st_zaposlenih dobicek ## 1 B gostinstvo 20 10000 ## 2 C proizvodnja 110 12000 Izberite drugi in etrti stolpec. ## panoga dobicek ## 1 proizvodnja 100000 ## 2 gostinstvo 10000 ## 3 proizvodnja 12000 ## 4 gostinstvo 1000 ## 5 proizvodnja 0 Dodajte stolpec, ki bo prikazal dobiek na zaposlenega. ## podjetje panoga st_zaposlenih dobicek dobicek_na_zaposlenega ## 1 A proizvodnja 100 100000 1000.00000 ## 2 B gostinstvo 20 10000 500.00000 ## 3 C proizvodnja 110 12000 109.09091 ## 4 D gostinstvo 15 1000 66.66667 ## 5 E proizvodnja 20 0 0.00000 Uredite podjetja po tevilu zaposlenih. ## podjetje panoga st_zaposlenih dobicek ## 1 D gostinstvo 15 1000 ## 2 B gostinstvo 20 10000 ## 3 E proizvodnja 20 0 ## 4 A proizvodnja 100 100000 ## 5 C proizvodnja 110 12000 Poiite maksimalno tevilo zaposlenih glede na panogo. ## # A tibble: 2 x 2 ## panoga max_st_zaposlenih ## &lt;chr&gt; &lt;dbl&gt; ## 1 gostinstvo 20 ## 2 proizvodnja 110 1.2 Sodobna razpredelnica: tibble Najprej si poglejmo podatke, na katerih se bomo nauili osnovnih konceptov slovnice ravnanja s podatki. V mapi data-raw se nahajajo podatki DS-jobs.csv. Gre za rezultate ankete, ki so jo v povezavi z industrijo izvedli na spletni strani Kaggle (https://www.kaggle.com/kaggle/kaggle-survey-2017) leta 2017 z namenom raziskati trg dela na podroju podatkovnih ved in strojnega uenja. Podatki so shranjeni v tekstovni datoteki, kjer so elementi loeni s podpijem. Preberimo podatke v nao sejo R: ds_jobs &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) head(ds_jobs) ## Gender Country Age EmploymentStatus ## 1 Female Australia 43 Employed full-time ## 2 Male Russia 33 Employed full-time ## 3 Male Taiwan 26 Employed full-time ## 4 Male United States 25 Employed part-time ## 5 Male United States 33 Employed full-time ## 6 Male Czech Republic 21 Employed part-time ## CurrentJobTitle LanguageRecommendation ## 1 Business Analyst Python ## 2 Software Developer/Software Engineer Python ## 3 Software Developer/Software Engineer Python ## 4 Researcher Python ## 5 Scientist/Researcher Matlab ## 6 Other Python ## FormalEducation ## 1 Bachelor&#39;s degree ## 2 Bachelor&#39;s degree ## 3 Master&#39;s degree ## 4 Bachelor&#39;s degree ## 5 Doctoral degree ## 6 Some college/university study without earning a bachelor&#39;s degree ## Major CompensationAmount CompensationCurrency ## 1 80000 AUD ## 2 Other 1200000 RUB ## 3 Computer Science 1100000 TWD ## 4 Physics 20000 USD ## 5 Electrical Engineering 100000 USD ## 6 Computer Science 20000 CZK ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 1 60 10 5 15 ## 2 40 30 15 10 ## 3 35 20 25 10 ## 4 0 80 0 20 ## 5 0 0 0 0 ## 6 20 60 20 0 ## TimeFindingInsights TimeOtherSelect ExchangeRate ## 1 10 0 0.802310 ## 2 5 0 0.017402 ## 3 10 0 0.033304 ## 4 0 0 1.000000 ## 5 0 0 1.000000 ## 6 0 0 0.045820 Spremenljivka ds_jobs je tipa data.frame. To je osnovna oblika, v kateri v R hranimo razpredelnice. V tidyverse obstaja paket tibble, ki je namenjen sodobni predstavitvi razpredelnice. Glavna funkcionalnost tega paketa je objekt tibble, ki predstavlja nadgradnjo data frame. V preostanku knjige bomo za objekte data.frame uporabljali izraz data frame in za objekte tipa tibble izraz tibble. Veina funkcij v tidyverse sicer lahko kot vhodni podatek prejme data frame, ampak ga nekatere potem samodejno pretvorijo v tibble. Kot dobro prakso predlagamo delo izkljuno s tibble. Poleg kompatibilnosti s funkcijami tidyverse je e nekaj drugih razlik v primerjavi z data frame, veino le-teh bomo spoznali v preostanku knjige. Pretvorimo sedaj ta data frame v tibble s funkcijo as_tibble(). library(tidyverse) ds_jobs &lt;- as_tibble(ds_jobs) ds_jobs ## # A tibble: 4,523 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Netherl~ 51 Employed full-time Engineer R ## 9 Male Colombia 34 Employed full-time Data Scientist Python ## 10 Male Germany 41 Independent contrac~ Data Scientist Python ## # ... with 4,513 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Opazimo, da je oblika prikaza podatkov sedaj nekoliko drugana. Najbolj oitna razlika je, da imamo na zaslonu prikazanih samo toliko stolpcev, kot jih je mono prikazati na zaslonu. Preostali stolpci so samo zapisani zaporedno z imeni, da lahko vidimo, katere stolpce e imamo v podatkih. S tem prepreimo, da bi izpis postal nepregleden. e vedno lahko vidimo vse oziroma ve stolpcev z uporabo View() ali pa e tibble izpiemo s pomojo print() in ustrezno nastavitvijo irine, na primer print(ds_jobs, width = 120). Izpis tibble pa nam nudi e nekaj dodatnih informacij v primerjavi z data frame. V prvi vrstici imamo izpisano dimenzijo podatkov  tevilo vrstic in tevilo stolpcev. Pod vsako spremenljivko je zapisan tudi njen tip. Tibble tudi dopua imena stolpcev, ki niso standardna za R (na primer vsebujejo - in podobno), eprav uporaba takih imen ni dobra praksa. Ve o tem bomo povedali kasneje. 1.3 Urejeno ovrednotenje Preden zanemo resneje delati z glagoli slovnice ravnanja s podatki, spoznajmo t. i. urejeno ovrednotenje (ang. tidy evaluation). To je posebnost tidyverse in veina glagolov v dplyr ga uporablja. Kaj pa je urejeno ovrednotenje? To je nestandarden pristop k ovrednotenju izrazov v programskem jeziku R. V pripravi smo e sreali dva primera: Pri funkciji filter() ni bilo potrebno vsaki navesti df$ za izbiro spremenljivk iz razpredelnice. Pri funkciji select() nismo potrebovali narekovajev. Oba sta primera dveh vrst urejenega ovrednotenja: Pri nekaterih glagolih v dplyr lahko uporabimo spremenljivke (stolpce) tibbla (ali razpredelnice), kot da bi bile spremenljivke v globalnem okolju (torej lahko uporabimo moja_spremenljivka namesto df$moja_spremenljivka). Temu pravimo maskiranje podatkov (ang. data masking). Funkcije, ki podpirajo to strukturo in jih bomo spoznali v nadaljevanju so: arrange(), count(), filter(), group_by(), mutate() in summarise(). Pri nekaterih glagolih v dplyr lahko na laji nain izberemo spremenljivke (stolpce) glede na njihovo pozicijo, ime ali tip (na primer izbira stolpcev po imenu brez narekovajev, izbira stolpcev ki se zanejo na doloen niz, izbira samo tevilskih stolpcev). Temu pravimo urejeno izbiranje (ang. tidy selection). Funkcije, ki podpirajo to strukturo so: across(), count(), rename(), select() in pull(). Informacije o tem, ali funkcija vsebuje maskiranje podatkov ali urejeno izbiranje, lahko najdemo v datoteki s pomojo pod razdelkom Arguments. 1.4 Izbira vrstic s filter() S funkcijo filter() izbiramo podmnoico vrstic glede na izbrane pogoje. Sintaksa je: filter(&lt;tibble&gt;, &lt;pogoj1&gt;, &lt;pogoj2&gt;, ...) Kot prvi argument podamo tibble s podatki, potem pa z vejicami loene pogoje. Izberimo vse osebe mlaje od 30 let: library(dplyr) filter(ds_jobs, Age &lt; 30) ## # A tibble: 1,729 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Taiwan 26 Employed full-t~ Software Developer~ Python ## 2 Male United S~ 25 Employed part-t~ Researcher Python ## 3 Male Czech Re~ 21 Employed part-t~ Other Python ## 4 Male Russia 22 Employed full-t~ Data Analyst Python ## 5 Male Poland 29 Employed full-t~ Software Developer~ Python ## 6 Male Other 28 Employed full-t~ Data Scientist R ## 7 Male Mexico 26 Employed part-t~ Data Scientist Python ## 8 Male Singapore 24 Employed full-t~ Data Analyst Python ## 9 Male India 29 Employed full-t~ Data Scientist R ## 10 Male United S~ 25 Employed full-t~ Engineer Python ## # ... with 1,719 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Ve pogojev loimo z vejico, kadar elimo, da veljajo vsi pogoji (enakovredno uporabi operatorja in  &amp; pri natevanju pogojev). Poglejmo si vse osebe mlaje od 30 let, ki prihajajo iz Nemije: filter(ds_jobs, Age &lt; 30, Country == &quot;Germany&quot;) ## # A tibble: 42 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Germany 24 Employed part-time Scientist/Resear~ R ## 2 Male Germany 28 Employed full-time Scientist/Resear~ Python ## 3 Male Germany 24 Independent contract~ Data Scientist Python ## 4 Female Germany 29 Employed full-time Business Analyst SQL ## 5 Male Germany 26 Employed part-time Researcher Python ## 6 Male Germany 27 Employed full-time Data Scientist Python ## 7 Female Germany 26 Employed part-time Statistician R ## 8 Male Germany 26 Independent contract~ Data Scientist Python ## 9 Male Germany 29 Employed full-time Machine Learning~ Python ## 10 Male Germany 25 Employed full-time Data Scientist Python ## # ... with 32 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; V kolikor elimo, da velja vsaj eden izmed pogojev, moramo uporabiti operator ali  |. Poglejmo si vse osebe mlaje od 30 ali stareje od 50 let: filter(ds_jobs, Age &lt; 30 | Age &gt; 50) ## # A tibble: 2,006 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Taiwan 26 Employed full-t~ Software Developer~ Python ## 2 Male United S~ 25 Employed part-t~ Researcher Python ## 3 Male Czech Re~ 21 Employed part-t~ Other Python ## 4 Male Russia 22 Employed full-t~ Data Analyst Python ## 5 Male Netherla~ 51 Employed full-t~ Engineer R ## 6 Male Poland 29 Employed full-t~ Software Developer~ Python ## 7 Male Other 28 Employed full-t~ Data Scientist R ## 8 Male Mexico 26 Employed part-t~ Data Scientist Python ## 9 Male Singapore 24 Employed full-t~ Data Analyst Python ## 10 Male India 29 Employed full-t~ Data Scientist R ## # ... with 1,996 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; e elimo nek kategorini stolpec pogojiti z veimi vrednostmi (na primer udeleence iz veih drav), lahko namesto veih | uporabimo operator %in%, ki preveri, e je element del mnoice: filter(ds_jobs, Country %in% c(&quot;Germany&quot;, &quot;Canada&quot;, &quot;Ireland&quot;)) ## # A tibble: 306 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Germany 41 Independent contrac~ Data Scientist Python ## 2 Female Germany 49 Employed part-time Scientist/Resea~ Python ## 3 Male Germany 44 Employed full-time Other Python ## 4 A diffe~ Canada 23 Employed full-time Scientist/Resea~ Python ## 5 Female Germany 24 Employed part-time Scientist/Resea~ R ## 6 Male Canada 52 Employed full-time Software Develo~ Python ## 7 Male Ireland 27 Employed full-time Data Scientist Python ## 8 Male Canada 24 Employed full-time Business Analyst Python ## 9 Male Canada 46 Employed full-time Data Scientist Python ## 10 Male Canada 31 Employed full-time Data Analyst R ## # ... with 296 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; 1.4.1 Manjkajoe vrednosti Vrstice pogosto filtriramo na podlagi manjkajoih vrednosti. Vasih so te pomembne za samo analizo, saj nas lahko zanimajo razlogi za njihov pojav. Vasih pa so to nepomembne vrstice, saj nam ne prinesejo dodatne informacije. V tem primeru jih obiajno kar izloimo iz nadaljnje analize. V nadaljevanju bomo spoznali, kako dodati nov stolpec, in to ilustrirali na izraunu plae v dolarjih. Za to bomo potrebovali stolpca CompensationAmount in ExchangeRate. V slednjem je kar nekaj manjkajoih vrednosti. Takne vrstice bodo za analizo pla neuporabne, zato jih bomo sedaj izloili iz podatkov. Ali je vrednost enaka NA (objekt, ki predstavlja manjkajoo vrednost v R) preverimo s funkcijo is.na(). Izloimo sedaj te vrstice: ds_jobs &lt;- filter(ds_jobs, !is.na(ExchangeRate)) Podobno kot v zgornjem primeru lahko v pogoju nastopa poljubna funkcija. 1.5 Izbira stolpcev s select() S funkcijo select() izbiramo podmnoico stolpcev. Osnovna sintaksa je: filter(&lt;tibble&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ...) Izberimo sedaj stolpce Country, Age in EmploymentStatus. select(ds_jobs, Country, Age, EmploymentStatus) ## # A tibble: 3,781 x 3 ## Country Age EmploymentStatus ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Australia 43 Employed full-time ## 2 Russia 33 Employed full-time ## 3 Taiwan 26 Employed full-time ## 4 United States 25 Employed part-time ## 5 United States 33 Employed full-time ## 6 Czech Republic 21 Employed part-time ## 7 Russia 22 Employed full-time ## 8 Colombia 34 Employed full-time ## 9 Germany 41 Independent contractor, freelancer, or self-employed ## 10 Poland 29 Employed full-time ## # ... with 3,771 more rows Izberimo vse stolpce razen teh treh stolpcev. Za to enostavno dodamo minus pred imenom stolpca, ki ga elimo izloiti: select(ds_jobs, -Country, -Age, -EmploymentStatus) ## # A tibble: 3,781 x 14 ## Gender CurrentJobTitle LanguageRecommen~ FormalEducation Major ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Business Analyst Python Bachelor&#39;s degree &quot;&quot; ## 2 Male Software Develope~ Python Bachelor&#39;s degree &quot;Other&quot; ## 3 Male Software Develope~ Python Master&#39;s degree &quot;Computer ~ ## 4 Male Researcher Python Bachelor&#39;s degree &quot;Physics&quot; ## 5 Male Scientist/Researc~ Matlab Doctoral degree &quot;Electrica~ ## 6 Male Other Python Some college/univers~ &quot;Computer ~ ## 7 Male Data Analyst Python Bachelor&#39;s degree &quot;Informati~ ## 8 Male Data Scientist Python Master&#39;s degree &quot;Computer ~ ## 9 Male Data Scientist Python I did not complete a~ &quot;&quot; ## 10 Male Software Develope~ Python Master&#39;s degree &quot;Computer ~ ## # ... with 3,771 more rows, and 9 more variables: CompensationAmount &lt;dbl&gt;, ## # CompensationCurrency &lt;chr&gt;, TimeGatheringData &lt;int&gt;, ## # TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, TimeVisualizing &lt;dbl&gt;, ## # TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ExchangeRate &lt;dbl&gt; Izberimo vse stolpce med Country in Major. Podobno kot v R 1:10 nateje vsa cela tevila med 1 in 10, operator : v tidyverse izbere vse stolpce med Country in Major: select(ds_jobs, Country:Major) ## # A tibble: 3,781 x 7 ## Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Australia 43 Employed full-time Business Analyst Python ## 2 Russia 33 Employed full-time Software Developer~ Python ## 3 Taiwan 26 Employed full-time Software Developer~ Python ## 4 United S~ 25 Employed part-time Researcher Python ## 5 United S~ 33 Employed full-time Scientist/Research~ Matlab ## 6 Czech Re~ 21 Employed part-time Other Python ## 7 Russia 22 Employed full-time Data Analyst Python ## 8 Colombia 34 Employed full-time Data Scientist Python ## 9 Germany 41 Independent contractor~ Data Scientist Python ## 10 Poland 29 Employed full-time Software Developer~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; Izberimo vse stolpce, ki se zanejo z besedo Time. Za to bomo uporabili funkcijo starts_with(). Ta funkcija je t. i. selection helper, kar pomeni, da jo lahko uporabimo le znotraj funkcij, ki omogoajo urejeno izbiro in nam omogoa lajo izbiro na podlagi nekega pogoja. V tem primeru je ta pogoj, da se beseda zane na doloen niz: select(ds_jobs, starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 6 ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 60 10 5 15 ## 2 40 30 15 10 ## 3 35 20 25 10 ## 4 0 80 0 20 ## 5 0 0 0 0 ## 6 20 60 20 0 ## 7 50 20 10 5 ## 8 60 10 20 5 ## 9 50 10 20 10 ## 10 25 20 25 20 ## # ... with 3,771 more rows, and 2 more variables: TimeFindingInsights &lt;dbl&gt;, ## # TimeOtherSelect &lt;int&gt; Poleg starts_with() dplyr vsebuje e ve taknih funkcij: ends_with() Ali se ime stolpca kona na doloen niz? contains() Ali ime stolpca vsebuje niz? matches() Ali ime stolpca ustreza regularnemu izrazu? Ve o regularnih izrazih bomo povedali v 3. predavanju. num_range() Ali ime stolpca vsebuje tevila znotraj mnoice tevil? Na primer, e imamo stolpce, ki v imenu vsebujejo tevila  stolpec1, stolpec2, in tako naprej. 1.6 Urejanje vrstic z arrange() Vrstice lahko tudi uredimo glede na vrednosti v posameznih stolpcih. Za to uporabimo funkcijo arrange(). Sintaksa te funkcije je: arrange(&lt;tibble&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ...) kjer stolpci predstavljajo vrednosti, po katerih elimo urediti tibble. Ustvarimo najprej nov tibble, v katerem bomo izbrali podmnoico stolpcev. ds_jobs_tmp &lt;- select(ds_jobs, CurrentJobTitle, Country, CompensationCurrency, Age, CompensationAmount) Uredimo sedaj podatke glede na leta: arrange(ds_jobs_tmp, Age) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Predictive Modeler Australia AUD 0 78000 ## 2 Scientist/Researcher United St~ USD 1 100000 ## 3 Programmer Other GBP 11 0 ## 4 Data Scientist United St~ USD 16 50000 ## 5 Software Developer/Soft~ Russia USD 18 40000 ## 6 Programmer Other USD 18 1000 ## 7 Machine Learning Engine~ Other USD 19 30000 ## 8 Programmer Russia USD 19 40000 ## 9 Scientist/Researcher Canada CAD 19 0 ## 10 Computer Scientist Brazil BRL 19 400 ## # ... with 3,771 more rows Opazimo, da imamo nekaj neveljavnih starosti, na primer 0 in 1, najverjetneje tudi 11. Prav tako imamo nekaj nesmiselnih vrednosti v stolpcu o plai. Pri celostni analizi bi seveda raziskali, zakaj je prilo do takih vrednosti, oziroma bi jih izloili iz analize. Za namen spoznavanja ravnanja s podatki in dplyr to ni pomembno, tako da temu ne bomo posveali pozornosti. Bralcem pa predlagamo, naj razmislijo, kako bi se tega lotili z e nauenimi koncepti. e elimo podatke urediti padajoe, potem uporabimo funkcijo desc(): arrange(ds_jobs_tmp, desc(Age)) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Statistician United Ki~ ILS 100 100000000000 ## 2 Other Other EUR 99 15000 ## 3 Researcher Portugal EUR 78 63000 ## 4 Data Scientist Canada USD 75 110 ## 5 Software Developer/Soft~ Netherlan~ EUR 73 40000 ## 6 Data Analyst Russia USD 70 14000 ## 7 Business Analyst United St~ USD 70 130000 ## 8 Machine Learning Engine~ United Ki~ GBP 70 40000 ## 9 Scientist/Researcher United St~ USD 69 200000 ## 10 Business Analyst United St~ USD 68 125000 ## # ... with 3,771 more rows Uredimo lahko tudi glede na ve stolpcev, kjer se najprej uredi po prvem zapisanem, nato drugem, itd.: arrange(ds_jobs_tmp, Age, CompensationAmount) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Predictive Modeler Australia AUD 0 78000 ## 2 Scientist/Researcher United St~ USD 1 100000 ## 3 Programmer Other GBP 11 0 ## 4 Data Scientist United St~ USD 16 50000 ## 5 Programmer Other USD 18 1000 ## 6 Software Developer/Soft~ Russia USD 18 40000 ## 7 Scientist/Researcher Canada CAD 19 0 ## 8 Computer Scientist Brazil BRL 19 400 ## 9 Machine Learning Engine~ Other USD 19 30000 ## 10 Programmer Russia USD 19 40000 ## # ... with 3,771 more rows 1.7 Dodajanje novih spremenljivk z mutate() Pogosto elimo ustvariti nove stolpce, ki so izpeljani iz obstojeih stolpcev. Pri naih podatkih imamo stolpec CompensationAmount, ki predstavlja letno plao in ExchangeRate, ki predstavlja menjalni teaj lokalne valute v ameriki dolar. e elimo imeti primerljive podatke, moramo izraunati vrednosti v dolarjih za vse podatke. Za to uporabimo funkcijo mutate(), ki doda stolpec (ali ve stolpcev). Sintaksa funkcije je: &lt;tibble&gt; &lt;- mutate(&lt;tibble&gt;, &lt;ime-novega-stolpca&gt; = &lt;funkcija-obstojeih-stolpcev&gt;, ...) Dodajmo stolpec CompensationUSD, ki bo prikazal letno plao v USD: ds_jobs &lt;- mutate(ds_jobs, CompensationUSD = CompensationAmount * ExchangeRate) select(ds_jobs, CompensationAmount, ExchangeRate, CompensationUSD) ## # A tibble: 3,781 x 3 ## CompensationAmount ExchangeRate CompensationUSD ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 80000 0.802 64185. ## 2 1200000 0.0174 20882. ## 3 1100000 0.0333 36634. ## 4 20000 1 20000 ## 5 100000 1 100000 ## 6 20000 0.0458 916. ## 7 624000 0.0174 10859. ## 8 156000000 0.000342 53352 ## 9 150000 1.20 179374. ## 10 126000 0.281 35419. ## # ... with 3,771 more rows Znotraj klica mutate() lahko uporabimo stolpce, ki smo jih ustvarili v istem klicu v preteklih vrsticah. Recimo, da elimo poleg plae v USD izraunati e meseno plao v USD: ds_jobs &lt;- mutate(ds_jobs, CompensationUSD = CompensationAmount * ExchangeRate, MonthlyCompUSD = CompensationUSD / 12) select(ds_jobs, CompensationAmount, ExchangeRate, CompensationUSD, MonthlyCompUSD) ## # A tibble: 3,781 x 4 ## CompensationAmount ExchangeRate CompensationUSD MonthlyCompUSD ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 80000 0.802 64185. 5349. ## 2 1200000 0.0174 20882. 1740. ## 3 1100000 0.0333 36634. 3053. ## 4 20000 1 20000 1667. ## 5 100000 1 100000 8333. ## 6 20000 0.0458 916. 76.4 ## 7 624000 0.0174 10859. 905. ## 8 156000000 0.000342 53352 4446 ## 9 150000 1.20 179374. 14948. ## 10 126000 0.281 35419. 2952. ## # ... with 3,771 more rows 1.8 Povzemanje vrednosti s summarise() Funkcija summarise() se uporablja za povzemanje vrednosti (na primer povpreja, vsote, tevci, ). Sintaksa funkcije je: summarise(&lt;tibble&gt;, &lt;ime-povzetka&gt; = &lt;funkcija-ki-povzame-stolpec&gt;, ...) Najprej poglejmo delovanje te funkcije, tako da povzamemo povpreen as priprave podatkov: summarise(ds_jobs, MeanDataCleaning = mean(TimeGatheringData)) ## # A tibble: 1 x 1 ## MeanDataCleaning ## &lt;dbl&gt; ## 1 37.3 Funkcija enostavno vrne povpreje stolpca TimeGatheringData. Ta informacija je sicer uporabna, ampak to ni edina funkcionalnost te funkcije in je obiajno ne uporabljamo v tej obliki. Njena mo se izrazi, ko jo uporabimo v kombinaciji z ukazom group_by(). Ta ukaz zdrui vrstice glede na vrednosti v podanih stolpcih. Zdruene vrednosti imajo posebno funkcijo v paketu dplyr in vplivajo na funkcionalnosti funkcij summarise(), mutate() in filter(). Vpliv grupiranja na mutate() in filter() si bomo ogledali nekoliko kasneje, poglejmo sedaj vpliv na summarise(). Recimo, da nas zanima, v katerih slubah je potrebnega najve ienja podatkov. Najprej podatke zdruimo po stolpcu CurrentJobTitle, potem pa uporabimo summarise(): ds_jobs_grouped &lt;- group_by(ds_jobs, CurrentJobTitle) summarise(ds_jobs_grouped, MeanDataCleaning = mean(TimeGatheringData)) ## # A tibble: 17 x 2 ## CurrentJobTitle MeanDataCleaning ## &lt;chr&gt; &lt;dbl&gt; ## 1 &quot;&quot; 40 ## 2 &quot;Business Analyst&quot; 37.9 ## 3 &quot;Computer Scientist&quot; 33.3 ## 4 &quot;Data Analyst&quot; 41.2 ## 5 &quot;Data Miner&quot; 48.0 ## 6 &quot;Data Scientist&quot; 39.4 ## 7 &quot;DBA/Database Engineer&quot; 37.7 ## 8 &quot;Engineer&quot; 36.4 ## 9 &quot;Machine Learning Engineer&quot; 34.7 ## 10 &quot;Operations Research Practitioner&quot; 37.8 ## 11 &quot;Other&quot; 36.3 ## 12 &quot;Predictive Modeler&quot; 37.1 ## 13 &quot;Programmer&quot; 35.8 ## 14 &quot;Researcher&quot; 31.3 ## 15 &quot;Scientist/Researcher&quot; 33.5 ## 16 &quot;Software Developer/Software Engineer&quot; 36.9 ## 17 &quot;Statistician&quot; 34.7 Izgleda, da so povpreja kar blizu  as ienja podatkov je relativno neodvisen od delovnega mesta. Povzemamo lahko tudi preko veih stolpcev. Poglejmo si tevilo ljudi z razlinimi statusi zaposlitve v kombinaciji z izobrazbo. Da pretejemo tevilo vrstic, ki ustrezajo grupiranju, uporabimo funkcijo n(): ds_jobs_grouped &lt;- group_by(ds_jobs, FormalEducation, EmploymentStatus) summarise(ds_jobs_grouped, Count = n()) ## # A tibble: 21 x 3 ## # Groups: FormalEducation [8] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows Ker je tetje primerov zelo pogosta operacija, obstaja tudi funkcija count(), ki naredi enako kot kombinacija group_by() in summarise(): count(ds_jobs, FormalEducation, EmploymentStatus) ## # A tibble: 21 x 3 ## FormalEducation EmploymentStatus n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows 1.9 Pipe V praksi ravnanje s podatki zajame veino, e ne kar vseh funkcij, ki smo jih predstavili do sedaj. e elimo sproti shranjevati nae spremembe, moramo po vsaki uporabi funkcije spremenjene podatke ponovno shraniti v spremenljivko. To lahko postane nekoliko nepregledno. Poglejmo si potek dela, kjer bomo nad osnovnimi podatki izvedli te operacije: Izbrali bomo vrstice, kjer so osebe stareje od 30 let in drava ni Other ali prazen niz. Izloili vse stolpce, ki vsebujejo niz Time. Izraunali stolpec s plao v amerikih dolarjih. Povzeli plao glede na dravo. Z uporabo shranjevanja podatkov v spremenljivko, kot smo navajeni iz osnovne razliice R, bi s funkcijami iz dplyr izgledalo takole: ds_jobs2 &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs2 &lt;- as_tibble(ds_jobs2) ds_jobs2 &lt;- filter(ds_jobs2, Age &gt; 30, !(Country %in% c(&quot;Other&quot;, &quot;&quot;))) ds_jobs2 &lt;- select(ds_jobs2, -contains(&quot;Time&quot;)) ds_jobs2 &lt;- mutate(ds_jobs2, CompensationUSD = CompensationAmount * ExchangeRate) ds_jobs2 &lt;- group_by(ds_jobs2, Country) ds_jobs2_summarised &lt;- summarise(ds_jobs2, MeanCompensation = mean(CompensationUSD, na.rm = T)) ds_jobs2_summarised ## # A tibble: 51 x 2 ## Country MeanCompensation ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 39282. ## 2 Australia 112800. ## 3 Belarus 33500 ## 4 Belgium 74141. ## 5 Brazil 47799. ## 6 Canada 85471. ## 7 Chile 44152. ## 8 Colombia 43303. ## 9 Czech Republic 50223. ## 10 Denmark 88136. ## # ... with 41 more rows Pri raunanju povpreja smo uporabili argument na.rm = T, s katerim smo manjkajoe vrednosti ignorirali. Celoten postopek je vseboval kar nekaj prepisovanja. Predvsem spremenljivko ds_jobs2 smo morali prepisati kar 6-krat. Dplyr pa vsebuje poseben operator, ki ga imenujemo pipe in ga oznaimo z %&gt;%. S tem operatorjem funkcije poveemo v sosledje. Poglejmo si, kako deluje: ds_jobs2 &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs2_summarised &lt;- ds_jobs2 %&gt;% filter(Age &gt; 30, !(Country %in% c(&quot;Other&quot;, &quot;&quot;))) %&gt;% select(-contains(&quot;Time&quot;)) %&gt;% mutate(CompensationUSD = CompensationAmount * ExchangeRate) %&gt;% group_by(Country) %&gt;% summarise(MeanCompensation = mean(CompensationUSD, na.rm = T)) ds_jobs2_summarised ## # A tibble: 51 x 2 ## Country MeanCompensation ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 39282. ## 2 Australia 112800. ## 3 Belarus 33500 ## 4 Belgium 74141. ## 5 Brazil 47799. ## 6 Canada 85471. ## 7 Chile 44152. ## 8 Colombia 43303. ## 9 Czech Republic 50223. ## 10 Denmark 88136. ## # ... with 41 more rows Sedaj smo do povzetka prili z zaporednim izvajanjem operacij nad spremenljivko ds_jobs. Ta nain je bolj pregleden, saj bralec kode takoj opazi, da se je vse izvajalo nad istimi podatki. Opazimo tudi, zakaj gre za slovnico ravnanja s podatki. Programska koda zapisana zgoraj se bere skoraj kot naravni jezik. Na primer, izberi vrstice, kjer so leta veja od 30 in drava ni v ustrezni mnoici. Zatem izberi stolpce, ki ne vsebujejo besede Time. Dodaj novo spremenljivko, zdrui podatke in jih povzemi. 1.10 filter() in mutate() na zdruenih podatkih Spoznali smo, kako funkcija group_by() vpliva na povzemanje podatkov. Uporabimo pa jo lahko tudi v povezavi s filter() in mutate(). Kombinacija z izbiro vrstic pride prav, kadar elimo pogojno izbiro na nek drugi stolpec. Kot primer si poglejmo, kako bi iz podatkov za vsako dravo filtrirali top 3 anketirance, ki prejmejo najvijo plao. Najprej bomo podatke grupirali, nato pa uporabili filter: ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country) %&gt;% filter(rank(desc(CompensationUSD)) &lt;= 3) %&gt;% arrange(Country) ## # A tibble: 154 x 4 ## # Groups: Country [53] ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 &quot;&quot; NA Data Scientist 107624. ## 2 &quot;&quot; 63 Machine Learning Engineer 160000 ## 3 &quot;&quot; NA Operations Research Practitioner 120000 ## 4 &quot;Argentina&quot; 55 Data Scientist 100000 ## 5 &quot;Argentina&quot; 26 Data Scientist 65000 ## 6 &quot;Argentina&quot; 26 Data Scientist 80000 ## 7 &quot;Australia&quot; 39 Data Scientist 280808. ## 8 &quot;Australia&quot; 50 Data Miner 248716. ## 9 &quot;Australia&quot; 37 Software Developer/Software Engineer 400000 ## 10 &quot;Belarus&quot; 22 Data Scientist 10800 ## # ... with 144 more rows Kombinacija group_by() in mutate() je uporabna, kadar elimo ustvariti novo spremenljivko, pri kateri bomo pri izraunu potrebovali kak povzetek vrednosti znotraj posamezne skupine. Primer takne transformacije je na primer standardiziranje znotraj skupine. Standardna ocena je: \\[ z_i = \\frac{x_i - \\bar{x}}{S_x}, \\] kjer je \\(\\bar{x}\\) povpreje vektorja \\(x\\) in \\(S_x\\) njegov vzorni standardni odklon. Poskusimo za vsako dravo izraunati vzorno povpreno vrednost in standardni odklon, ter s tema vrednostima ustrezno transformirati plao v USD. Da pa bo funkcija mutate() vedela, katere vrednosti naj vzame za raunanje teh dveh statistie moramo podatke najprej grupirati glede na dravo: ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country) %&gt;% mutate(CompensationStand = (CompensationUSD - mean(CompensationUSD)) / sd(CompensationUSD)) ## # A tibble: 3,781 x 5 ## # Groups: Country [53] ## Country Age CurrentJobTitle CompensationUSD CompensationSta~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. -0.617 ## 2 Russia 33 Software Developer/Softwa~ 20882. -0.136 ## 3 Taiwan 26 Software Developer/Softwa~ 36634. 0.0566 ## 4 United Sta~ 25 Researcher 20000 -0.0468 ## 5 United Sta~ 33 Scientist/Researcher 100000 -0.0347 ## 6 Czech Repu~ 21 Other 916. -0.907 ## 7 Russia 22 Data Analyst 10859. -0.417 ## 8 Colombia 34 Data Scientist 53352 0.770 ## 9 Germany 41 Data Scientist 179374. 2.35 ## 10 Poland 29 Software Developer/Softwa~ 35419. 0.486 ## # ... with 3,771 more rows e ta tibble shranimo v novo spremenljivko, se bo informacija o zdruevanju ohranila. ds_jobs_grouped &lt;- ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country, CurrentJobTitle) ds_jobs_grouped ## # A tibble: 3,781 x 4 ## # Groups: Country, CurrentJobTitle [543] ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. ## 2 Russia 33 Software Developer/Software Engineer 20882. ## 3 Taiwan 26 Software Developer/Software Engineer 36634. ## 4 United States 25 Researcher 20000 ## 5 United States 33 Scientist/Researcher 100000 ## 6 Czech Republic 21 Other 916. ## 7 Russia 22 Data Analyst 10859. ## 8 Colombia 34 Data Scientist 53352 ## 9 Germany 41 Data Scientist 179374. ## 10 Poland 29 Software Developer/Software Engineer 35419. ## # ... with 3,771 more rows Opazimo, da ima ta tibble dodatno informacijo v drugi vrstici, ki nam sporoa, da je zdruen glede na spremenljivki Country in CurrentJobTitle. Poleg tega je v oglatih oklepajih zapisano tevilo unikatnih skupin. Pri tem so vsi pari drave in trenutne pozicije, za katere nimamo nobenega podatka, izpueni. Informacija o tem, da je ta tibble grupiran, je pomembna, saj se bodo vse nadaljnje operacije nad njim izvajale nad skupinami. e tega ne elimo, lahko uporabimo funkcijo ungroup(). ds_jobs_ungrouped &lt;- ds_jobs_grouped %&gt;% ungroup() ds_jobs_ungrouped ## # A tibble: 3,781 x 4 ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. ## 2 Russia 33 Software Developer/Software Engineer 20882. ## 3 Taiwan 26 Software Developer/Software Engineer 36634. ## 4 United States 25 Researcher 20000 ## 5 United States 33 Scientist/Researcher 100000 ## 6 Czech Republic 21 Other 916. ## 7 Russia 22 Data Analyst 10859. ## 8 Colombia 34 Data Scientist 53352 ## 9 Germany 41 Data Scientist 179374. ## 10 Poland 29 Software Developer/Software Engineer 35419. ## # ... with 3,771 more rows 1.11 Izvajanje operacij nad veimi stolpci z across() S kombinacijo funkcij mutate() in across() lahko izvajamo isto operacijo hkrati na ve stolpcih. Znotraj funkcije across() lahko uporabljamo iste funkcije za izbiro kot znotraj select(). Spremenimo vrednosti stolpcev, ki se zanejo s Time, v delee tako, da jih pomnoimo z 0.01. Na tem mestu bomo uporabili dva nova operatorja: . in ~. Operator . v dplyr igra vlogo podatkov, nad katerimi operiramo. Operator ~ je nekakna blinjica, ki ustvari funkcijo. Na primer ~ x^2 je blinjica za zapis function(x) {x^2}. To je uporabno predvsem, ko funkcijo potrebujemo samo na enem mestu znotraj naega poteka dela in jo tako lahko na kraji nain zapiemo. Poglejmo si sedaj spremembo stolpcev v delee: ds_jobs %&gt;% mutate(across(starts_with(&quot;Time&quot;), ~ . * 0.01)) %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 8 ## Country CurrentJobTitle TimeGatheringDa~ TimeModelBuildi~ TimeProduction ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 0.6 0.1 0.05 ## 2 Russia Software Develope~ 0.4 0.3 0.15 ## 3 Taiwan Software Develope~ 0.35 0.2 0.25 ## 4 United S~ Researcher 0 0.8 0 ## 5 United S~ Scientist/Researc~ 0 0 0 ## 6 Czech Re~ Other 0.2 0.6 0.2 ## 7 Russia Data Analyst 0.5 0.2 0.1 ## 8 Colombia Data Scientist 0.6 0.1 0.2 ## 9 Germany Data Scientist 0.5 0.1 0.2 ## 10 Poland Software Develope~ 0.25 0.2 0.25 ## # ... with 3,771 more rows, and 3 more variables: TimeVisualizing &lt;dbl&gt;, ## # TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;dbl&gt; Funkciji across() smo najprej podali stolpce, na katerih elimo izvajati izraune, nato pa funkcijo, ki jo elimo izvesti. 1.12 Povzemanje stolpcev Pogosto elimo dobiti numerine povzetke glede na vrednosti v stolpcih. Z uporabo osnovne razliice R to lahko naredimo s funkcijo apply(), ki ji podamo tibble numerinih vrednosti (lahko tudi data.frame ali matriko), doloimo dimenzijo 2, ki predstavlja stolpce, ter podamo kateri povzetek elimo (na primer povpreje, varianco, maksimalno vrednost, ). Izraunajmo povpreja in standardne odklone stolpcev, ki se zanejo s Time: ds_jobs_times &lt;- ds_jobs %&gt;% select(starts_with(&quot;Time&quot;)) apply(ds_jobs_times, 2, mean, na.rm = T) ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 37.341973 21.085472 11.172853 14.190924 ## TimeFindingInsights TimeOtherSelect ## 13.375298 2.202176 apply(ds_jobs_times, 2, sd, na.rm = T) ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 20.96041 15.19101 12.03243 10.99431 ## TimeFindingInsights TimeOtherSelect ## 12.01139 11.18898 apply() nam v teh primerih vrne vektor, eprav smo operacijo izvajali na tibble. Ideja paketa tidyverse je, da so izhodni podatki enakega tipa kot vhodni  v tem primeru tibble. e elimo izraunati povzetke za vsak stolpec, lahko v paketu dplyr uporabimo kombinacijo funkcije summarise() in across(). Kot smo e spoznali, nam funkcija across() omogoa izvajanje operacij nad veimi stolpci. ds_jobs %&gt;% summarise(across(starts_with(&quot;Time&quot;), mean, na.rm = T)) ## # A tibble: 1 x 6 ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 37.3 21.1 11.2 14.2 ## # ... with 2 more variables: TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;dbl&gt; Povzetke lahko enostavno izraunamo tudi za razline skupine z uporabo funkcije group_by(): ds_jobs %&gt;% group_by(EmploymentStatus) %&gt;% summarise(across(starts_with(&quot;Time&quot;), mean, na.rm = T)) ## # A tibble: 3 x 7 ## EmploymentStatus TimeGatheringDa~ TimeModelBuildi~ TimeProduction ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Employed full-time 37.6 20.6 11.0 ## 2 Employed part-time 37.4 26.1 10.3 ## 3 Independent contractor, free~ 34.8 23.0 12.8 ## # ... with 3 more variables: TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, ## # TimeOtherSelect &lt;dbl&gt; 1.13 Povzemanje vrstic Kadar analiziramo podatke, preverimo, ali so vneeni podatki smiselni. Na primer, v stolpcih, ki se zanejo s Time, so odstotkovne vrednosti asa, ki ga anketiranci porabijo za posamezne naloge. Te bi se morale seteti v 100 in v primeru, ko se ne, se lahko odloimo, da takne vrstice izbriemo. Na tem primeru si bomo sedaj pogledali e operacije nad stolpci. Na cilj bo, da dodamo temu tibblu e en stolpec, v katerem bomo seteli vse te stolpce. Funkcija apply deluje tudi nad stolpci, e spremenimo drugi argument: tmp &lt;- ds_jobs %&gt;% select(starts_with(&quot;Time&quot;)) head(apply(tmp, 1, sum, na.rm = T)) ## [1] 100 100 100 100 0 100 Kako pa to naredimo z dplyr, tako da se bo naravno vkljuilo v potek dela? Prva ideja bi morda bila, da enostavno natejemo vse stolpce. ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TotalTime = TimeGatheringData + TimeModelBuilding + TimeProduction + TimeVisualizing + TimeFindingInsights + TimeOtherSelect) %&gt;% select(!starts_with(&quot;Time&quot;)) # Ta vrstica je samo za lepi izpis. ## # A tibble: 3,781 x 3 ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 100 ## 2 Russia Software Developer/Software Engineer 100 ## 3 Taiwan Software Developer/Software Engineer 100 ## 4 United States Researcher 100 ## 5 United States Scientist/Researcher 0 ## 6 Czech Republic Other 100 ## 7 Russia Data Analyst 100 ## 8 Colombia Data Scientist 100 ## 9 Germany Data Scientist 100 ## 10 Poland Software Developer/Software Engineer 100 ## # ... with 3,771 more rows Sicer je to v naem primeru bilo izvedljivo, saj smo imeli samo 6 stolpcev. Kako pa bi to naredili z veimi stolpci? Morda lahko uporabimo starts_with(): ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TimeTotal = sum(starts_with(&quot;Time&quot;), na.rm = T)) ## Error: Problem with `mutate()` column `TimeTotal`. ## i `TimeTotal = sum(starts_with(&quot;Time&quot;), na.rm = T)`. ## x `starts_with()` must be used within a *selecting* function. ## i See &lt;https://tidyselect.r-lib.org/reference/faq-selection-context.html&gt;. R vrne napako in nas opozori, da se lahko starts_with() uporabi le znotraj izbire. e elimo v tem primeru omogoiti urejeno izbiro stolpcev, uporabimo funkcijo c_across(). Ta funkcija je po funkcionalnosti bolj podobna funkciji c() ali select(), kot pa funkciji across(), tako da jih ne smemo zamenjati: ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TotalTime = sum(c_across(starts_with(&quot;Time&quot;)), na.rm = T)) %&gt;% select(!starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 3 ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 375462 ## 2 Russia Software Developer/Software Engineer 375462 ## 3 Taiwan Software Developer/Software Engineer 375462 ## 4 United States Researcher 375462 ## 5 United States Scientist/Researcher 375462 ## 6 Czech Republic Other 375462 ## 7 Russia Data Analyst 375462 ## 8 Colombia Data Scientist 375462 ## 9 Germany Data Scientist 375462 ## 10 Poland Software Developer/Software Engineer 375462 ## # ... with 3,771 more rows Sedaj smo dobili nek rezultat, ki pa e vedno ni pravilen. V em je teava? e sum() uporabimo znotraj mutate(), ta vrne vsoto znotraj skupin, doloenih z group_by(). Ker podatkov nismo grupirali, vrne vsoto kar ez celotne podatke. Reitev se torej skriva v ustreznem zdruevanju vrstic. V dplyr obstaja funkcija, ki celoten tibble grupira po posameznih vrsticah in to je rowwise(): ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% rowwise() %&gt;% mutate(TotalTime = sum(c_across(starts_with(&quot;Time&quot;)), na.rm = T)) %&gt;% select(!starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 3 ## # Rowwise: ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 100 ## 2 Russia Software Developer/Software Engineer 100 ## 3 Taiwan Software Developer/Software Engineer 100 ## 4 United States Researcher 100 ## 5 United States Scientist/Researcher 0 ## 6 Czech Republic Other 100 ## 7 Russia Data Analyst 100 ## 8 Colombia Data Scientist 100 ## 9 Germany Data Scientist 100 ## 10 Poland Software Developer/Software Engineer 100 ## # ... with 3,771 more rows 1.14 Dodatek 1.14.1 Zamenjava vrstnega reda stolpcev Vrstni red stolpcev zamenjamo s funkcijo relocate(). Ustvarimo najprej manji tibble: ds_jobs_select &lt;- ds_jobs %&gt;% select(Gender:Major) ds_jobs_select ## # A tibble: 3,781 x 8 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; e elimo doloene stolpce premakniti na zaetek, jih enostavno podamo funkciji relocate(). Dajmo na prvo mesto stolpca Major in Age: ds_jobs_select %&gt;% relocate(Major, Age) ## # A tibble: 3,781 x 8 ## Major Age Gender Country EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;&quot; 43 Female Austra~ Employed full-t~ Business Analy~ Python ## 2 &quot;Othe~ 33 Male Russia Employed full-t~ Software Devel~ Python ## 3 &quot;Comp~ 26 Male Taiwan Employed full-t~ Software Devel~ Python ## 4 &quot;Phys~ 25 Male United~ Employed part-t~ Researcher Python ## 5 &quot;Elec~ 33 Male United~ Employed full-t~ Scientist/Rese~ Matlab ## 6 &quot;Comp~ 21 Male Czech ~ Employed part-t~ Other Python ## 7 &quot;Info~ 22 Male Russia Employed full-t~ Data Analyst Python ## 8 &quot;Comp~ 34 Male Colomb~ Employed full-t~ Data Scientist Python ## 9 &quot;&quot; 41 Male Germany Independent con~ Data Scientist Python ## 10 &quot;Comp~ 29 Male Poland Employed full-t~ Software Devel~ Python ## # ... with 3,771 more rows, and 1 more variable: FormalEducation &lt;chr&gt; Poljubno ureditev dobimo tako, da enostavno zapiemo vrstni red stolpcev, kot ga elimo. Funkcija relocate() omogoa e nekatere monosti urejanja, kot na primer, glede na tip spremenljivke. Za ve informacij o razlinih nainih urejanja stolpcev bralcu predlagamo uporabo pomoi ?relocate. 1.14.2 Preimenovanje stolpcev Stolpce preimenujemo s funkcijo rename(). ds_jobs_select %&gt;% rename(employment_status = EmploymentStatus, current_job_title = CurrentJobTitle) ## # A tibble: 3,781 x 8 ## Gender Country Age employment_status current_job_title LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; Tibble lahko vsebuje tudi imena stolpcev, ki niso veljavna za spremenljivke v R. V tem primeru jih moramo zapisati znotraj `. Na primer, spremenljivki v R ne moremo prirediti imena z minusom. Poizkusimo to narediti v tibblu: ds_jobs_select %&gt;% rename(`employment-status` = EmploymentStatus, `current-job-title` = CurrentJobTitle) ## # A tibble: 3,781 x 8 ## Gender Country Age `employment-status` `current-job-tit~ LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; 1.14.3 Summarise in group unpeeling Kot smo e spoznali je funkcija summarise() najbolj uporabna v kombinaciji z group_by(). Pogljemo si sedaj bolj podrobno, kaken tibble je rezultat te kombinacije. Najprej samo grupirajmo ds_jobs: ds_jobs_grouped &lt;- ds_jobs %&gt;% group_by(FormalEducation, EmploymentStatus) ds_jobs_grouped ## # A tibble: 3,781 x 19 ## # Groups: FormalEducation, EmploymentStatus [21] ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 13 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt;, CompensationUSD &lt;dbl&gt;, MonthlyCompUSD &lt;dbl&gt; V drugi vrstici vidimo, da je ta tibble grupiran po spremenljivkah FormalEducation in EmploymentStatus. Poglejmo kaj se zgodi, ko uporabimo summarise(): ds_jobs_summarised &lt;- ds_jobs_grouped %&gt;% summarise(Count = n()) ds_jobs_summarised ## # A tibble: 21 x 3 ## # Groups: FormalEducation [8] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows Opazimo, da je ta novi tibble grupiran samo po spremenljivki FormalEducation. Privzeto summarise() vedno odstrani zadnje grupiranje. e tega ne elimo, lahko uporabimo dodaten parameter .groups = \"keep\". ds_jobs_summarised &lt;- ds_jobs_grouped %&gt;% summarise(Count = n(), .groups = &quot;keep&quot;) ds_jobs_summarised ## # A tibble: 21 x 3 ## # Groups: FormalEducation, EmploymentStatus [21] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows 1.15 Ali elite izvedeti ve? V tem poglavju smo spoznali temeljne operacije nad podatki in njihovo implementacijo v R paketu dplyr. Opis vseh funkcij v dplyr najdemo tukaj: https://dplyr.tidyverse.org/reference/index.html. Jedrnat povzetek pa je na voljo tukaj, pod poglavjem Data Transformation Cheatsheet: https://www.rstudio.com/resources/cheatsheets/. 1.16 Domaa naloga Zaeli bomo z relativno preprosto nalogo, kjer bomo ponovili osnovne ukaze iz slovnice ravnanja s podatki. Osnovna razliica programskega jezika R e vsebuje nekatere podatkovne zbirke. Z ukazom data() dobimo opis vseh zbirk. V tej nalogi bomo uporabili podatkovno zbirko mtcars: head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Za podrobneji opis podatkov uporabite pomo ?mtcars. Najprej ustvarite novo spremenljivko mtcars_tib, v katero shranite razpredelnico mtcars kot tibble. Nato vsako izmed spodnjih nalog izvedite posebej (torej v vsaki toki izvedite ukaz na mtcars_tib, ampak tako spremenjenega tibbla ne shranite nazaj v to spremenljivko), razen e je v nalogi eksplicitno navedeno drugae. Vae naloge so sledee: Ustvarite novo spremenljivko mtcars_tib, v katero shranite razpredelnico mtcars kot tibble. Izberite vse vrstice avtomobilov z avtomatskim menjalnikom. ## # A tibble: 19 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 2 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 3 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 5 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 6 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 7 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 8 17.8 6 168. 123 3.92 3.44 18.9 1 0 4 4 ## 9 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 10 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## 11 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 ## 12 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 13 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 14 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## 15 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 16 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 ## 17 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 ## 18 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 19 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 Izberite vse vrstice, kjer je poraba manja od 15 galon na miljo ali veja od 20 galon na miljo in je motor oblike V. ## # A tibble: 8 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 4 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 5 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 6 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## 7 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 8 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 Izberite vse stolpce, kjer ime stolpca vsebuje rko a. ## # A tibble: 32 x 4 ## drat am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.9 1 4 4 ## 2 3.9 1 4 4 ## 3 3.85 1 4 1 ## 4 3.08 0 3 1 ## 5 3.15 0 3 2 ## 6 2.76 0 3 1 ## 7 3.21 0 3 4 ## 8 3.69 0 4 2 ## 9 3.92 0 4 2 ## 10 3.92 0 4 4 ## # ... with 22 more rows Izberite zadnje 4 stolpce. ## # A tibble: 32 x 4 ## vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 1 4 4 ## 2 0 1 4 4 ## 3 1 1 4 1 ## 4 1 0 3 1 ## 5 0 0 3 2 ## 6 1 0 3 1 ## 7 0 0 3 4 ## 8 1 0 4 2 ## 9 1 0 4 2 ## 10 1 0 4 4 ## # ... with 22 more rows V tibble mtcars_tib dodajte stolpca, kjer bosta izraunani tevilo litrov na 100 kilometrov in tea v kilogramih (v tisoicah). 1 milja je priblino 1.61 kilometra, 1 galona 3.79 litra in 1 funt 0.45 kilograma. ## # A tibble: 32 x 4 ## mpg wt lp100km wt_in_kg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 2.62 11.2 1.18 ## 2 21 2.88 11.2 1.29 ## 3 22.8 2.32 10.3 1.04 ## 4 21.4 3.22 11.0 1.45 ## 5 18.7 3.44 12.6 1.55 ## 6 18.1 3.46 13.0 1.56 ## 7 14.3 3.57 16.5 1.61 ## 8 24.4 3.19 9.65 1.44 ## 9 22.8 3.15 10.3 1.42 ## 10 19.2 3.44 12.3 1.55 ## # ... with 22 more rows Izraunajte povpreno porabo avtomobilov v odvisnosti tevila cilindrov. ## # A tibble: 3 x 2 ## cyl mean_mpg ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 Izraunajte povpreno konjsko mo v odvisnosti od oblike motorja in ali je avtomobil avtomatik ali ne. ## # A tibble: 4 x 3 ## # Groups: vs [2] ## vs am mean_hp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 194. ## 2 0 1 181. ## 3 1 0 102. ## 4 1 1 80.6 Normalizirajte vse stolpce, ki vsebujejo decimalna tevila, na interval [0, 1]. To naredimo tako, da vrednostim odtejemo minimalno vrednost in delimo z razliko med maksimalno in minimalno vrednostjo: \\[ x_i&#39; = \\frac{x_i - \\min(x)}{\\max(x) - \\min(x)}. \\] ## # A tibble: 32 x 13 ## mpg cyl disp hp drat wt qsec vs am gear carb lp100km ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.451 6 0.222 110 0.525 0.283 0.233 0 1 4 4 0.272 ## 2 0.451 6 0.222 110 0.525 0.348 0.3 0 1 4 4 0.272 ## 3 0.528 4 0.0920 93 0.502 0.206 0.489 1 1 4 1 0.215 ## 4 0.468 6 0.466 110 0.147 0.435 0.588 1 0 3 1 0.259 ## 5 0.353 8 0.721 175 0.180 0.493 0.3 0 0 3 2 0.360 ## 6 0.328 6 0.384 105 0 0.498 0.681 1 0 3 1 0.386 ## 7 0.166 8 0.721 245 0.207 0.526 0.160 0 0 3 4 0.607 ## 8 0.596 4 0.189 62 0.429 0.429 0.655 1 0 4 2 0.172 ## 9 0.528 4 0.174 95 0.535 0.419 1 1 0 4 2 0.215 ## 10 0.374 6 0.241 123 0.535 0.493 0.452 1 0 4 4 0.339 ## # ... with 22 more rows, and 1 more variable: wt_in_kg &lt;dbl&gt; Izraunajte povprene vrednosti vseh stolpcev. ## # A tibble: 1 x 13 ## mpg cyl disp hp drat wt qsec vs am gear carb lp100km ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20.1 6.19 231. 147. 3.60 3.22 17.8 0.438 0.406 3.69 2.81 12.8 ## # ... with 1 more variable: wt_in_kg &lt;dbl&gt; Teja naloga. V mapi data-raw se nahajajo podatki o gozdnih poarih na Portugalskem. Podatki so bili uporabljeni v znanstvenem lanku (Cortez and Morais 2007), kjer so napovedovali velikost poganega obmoja v odvisnosti od meteorolokih in drugih podatkov. Vrednosti 0 za pogano obmoje predstavljajo poare, kjer je pogorelo manj kot 100 kvadratnih metrov. Preberite podatke in jih shranite kot tibble. Preverite, v katerem mesecu je najve poarov in jih uredite padajoe od tistega z najve poari do tistega z najmanj. ## # A tibble: 12 x 2 ## month n ## &lt;chr&gt; &lt;int&gt; ## 1 aug 184 ## 2 sep 172 ## 3 mar 54 ## 4 jul 32 ## 5 feb 20 ## 6 jun 17 ## 7 oct 15 ## 8 apr 9 ## 9 dec 9 ## 10 jan 2 ## 11 may 2 ## 12 nov 1 Preverite, ali obstajajo obmoja v parku, kjer se bolj pogosto pojavljajo poari. Za vsako kombinacijo koordinat bomo torej izraunali tevilo poarov. Rezultat lahko predstavimo z razpredelnico. Glede na to, da imamo dvodimenzionalne podatke, bi jih morda bilo smiselno predstaviti vizualno. V kolikor poznate paket ggplot2, predlagamo da si pogledate funkcijo geom_tile(). ## # A tibble: 36 x 3 ## X Y n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2 19 ## 2 1 3 10 ## 3 1 4 15 ## 4 1 5 4 ## 5 2 2 25 ## 6 2 3 1 ## 7 2 4 27 ## 8 2 5 20 ## 9 3 3 1 ## 10 3 4 43 ## # ... with 26 more rows Dodajte stolpec, ki bo za vsak poar izraunal dele poganega obmoja glede na vse poare na posameznih koordinatah. Za tem smiselno filtrirajte podatke (ali smo v novem stolpcu dobili kakne nepriakovane, oziroma neveljavne vrednosti?). ## # A tibble: 509 x 5 ## X Y month day area_by_coord ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 7 5 mar fri 0 ## 2 7 4 oct tue 0 ## 3 7 4 oct sat 0 ## 4 8 6 mar fri 0 ## 5 8 6 mar sun 0 ## 6 8 6 aug sun 0 ## 7 8 6 aug mon 0 ## 8 8 6 aug mon 0 ## 9 8 6 sep tue 0 ## 10 7 5 sep sat 0 ## # ... with 499 more rows Preverite, ali ob vroem vremenu in nizki vlanosti pogori veji dele obmoja, ki smo ga izraunali v prejnji toki, tako da izberete vrstice, kjer je temperatura vija od 0.8 kvantila temperature in vlanost nija od 0.2 kvantila vlanosti ter izraunate povpreje. \\(q\\)-ti kvantil je ocena tevila, za katerega velja, da je \\(q\\) vrednosti manjih od tega tevila. Za raunanje kvantilov uporabite funkcijo quantile(). Za primerjavo izraunajte e povpreje te spremenljivke za vse preostale vrstice. Ali se rezultati skladajo z vao intuicijo? ## # A tibble: 1 x 1 ## mean_area_by_coord ## &lt;dbl&gt; ## 1 0.153 ## # A tibble: 1 x 1 ## mean_area_by_coord ## &lt;dbl&gt; ## 1 0.0555 Izraunajte povpreje standardiziranih indeksov in ga vstavite kot stolpec pred prvo spremenljivko, ki predstavlja indeks. ## # A tibble: 509 x 15 ## # Rowwise: ## X Y month day mean_indices FFMC_index DMC_index DC_index ISI_index ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 5 mar fri -1.21 -0.796 -1.32 -1.86 -0.859 ## 2 7 4 oct tue -0.304 -0.00502 -1.18 0.480 -0.510 ## 3 7 4 oct sat -0.254 -0.00502 -1.05 0.552 -0.510 ## 4 8 6 mar fri -0.739 0.193 -1.21 -1.92 -0.00890 ## 5 8 6 mar sun -0.719 -0.239 -0.934 -1.82 0.122 ## 6 8 6 aug sun 0.218 0.301 -0.405 -0.256 1.23 ## 7 8 6 aug mon -0.0979 0.301 -0.349 -0.225 -0.118 ## 8 8 6 aug mon 0.320 0.157 0.530 0.232 0.361 ## 9 8 6 sep tue 0.120 0.0669 0.283 0.575 -0.445 ## 10 7 5 sep sat 0.0375 0.337 -0.363 0.599 -0.423 ## # ... with 499 more rows, and 6 more variables: temp &lt;dbl&gt;, RH &lt;dbl&gt;, ## # wind &lt;dbl&gt;, rain &lt;dbl&gt;, area &lt;dbl&gt;, area_by_coord &lt;dbl&gt; "],["urejeni-in-relacijski-podatki.html", "Poglavje 2 Urejeni in relacijski podatki 2.1 Priprava 2.2 Urejeni podatki 2.3 pivot_longer(): pretvorba v daljo obliko 2.4 pivot_wider(): pretvorba v iro obliko 2.5 separate() in unite(): deljenje in zdruevanje stolpcev 2.6 Relacijske zbirke podatkov 2.7 Primer: Banni podatki 2.8 Kljui 2.9 Zdruevanja 2.10 Operacije nad mnoicami 2.11 Ali elite izvedeti ve? 2.12 Domaa naloga", " Poglavje 2 Urejeni in relacijski podatki Pri kakrnemkoli delu smo obiajno zelo ciljno naravnani. Dobimo nalogo in jo elimo imprej in imbolje opraviti. Z namenom uinkovitosti se obiajno posluimo znanih orodij in postopkov, ki jih prilagodimo samemu problemu. Pri delu s podatki se ciljna naravnanost obiajno izrazi tako, da elimo imprej priti do analize in zakljukov, samemu urejanju podatkov pa ne posvetimo pretirane pozornosti, oziroma le toliko, kot je nujno potrebno (kar je e vedno lahko dolgotrajno). Na kratek rok to deluje v redu in celo prihranimo nekaj asa. Na dolgi rok pa obiajno zahteva veliko ve asa, saj se moramo pri vsaki novi nalogi na novo prilagajati podatkom. Bolji pristop bi bil, da bi problem prilagodili ustaljenemu postopku. Obiajno lahko veino podatkov uredimo do te mere, da so si po obliki podobni. V kolikor se nauimo narediti to za neko splono podatkovno zbirko, lahko potem vsaki pristopimo do nadaljnjega dela na podoben nain. V praksi s tem na dolgi rok prihranimo veliko asa. Koncept urejenih podatkov (ang. tidy data), ki ga bomo spoznali v tem poglavju, je formalizacija intuitivne predstavke kaj podatki so. Podatke, ki so urejeni, lahko veliko laje transformiramo in pripravimo na nadaljnjo analizo. Tudi funkcije v tidyverse so implementirane tako, da na vhod prejmejo urejene podatke in takne tudi vrnejo. Z drugimi besedami ohranjajo urejenost. Relacijski podatki pa so podatki o razlinih entitetah (na primer podjetje, delavec, slubeno vozilo, klient), ki so shranjeni v razlinih razpredelnicah. Kadar elimo analizirati relacijske podatke moramo razumeti povezave med njimi in kako delati z njimi. Spoznali bomo koncept relacijskih podatkovnih zbirk in kako uporabiti tidyverse za delo z njimi. 2.1 Priprava V tem poglavju bomo spoznali, kako podatke pretvorimo iz dalje v krajo obliko (in obratno) ter kako delamo z relacijskimi podatki. Kaj vsi ti koncepti pomenijo in kako so povezani z urejenimi podatki, bomo predelali v jedru poglavja. Pri pretvorbi podatkov v daljo obliko gre za pretvorbo, kjer vrednosti veih stolpcev zdruimo v en stolpec. Poglejmo si razpredelnico, kjer imamo shranjene podatke za ve let: df &lt;- tibble( ime = c(&quot;Mojca&quot;, &quot;Miha&quot;, &quot;Mateja&quot;), `2018` = c(5.5, 4.6, 8.7), `2019` = c(5.8, 4.2, 9) ) df ## # A tibble: 3 x 3 ## ime `2018` `2019` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mojca 5.5 5.8 ## 2 Miha 4.6 4.2 ## 3 Mateja 8.7 9 Recimo, da elimo stolpca z leti spraviti v en stolpec. Uporabimo funkcijo pivot_longer(). df_longer &lt;- pivot_longer(df, c(`2018`, `2019`), names_to = &quot;leto&quot;, values_to = &quot;rezultat&quot;) df_longer ## # A tibble: 6 x 3 ## ime leto rezultat ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mojca 2018 5.5 ## 2 Mojca 2019 5.8 ## 3 Miha 2018 4.6 ## 4 Miha 2019 4.2 ## 5 Mateja 2018 8.7 ## 6 Mateja 2019 9 Lahko naredimo tudi obratno transformacijo, torej da vrednosti enega stolpca razirimo v ve stolpcev. Na primer, razirimo stolpec ime: pivot_wider(df_longer, names_from = ime, values_from = rezultat) ## # A tibble: 2 x 4 ## leto Mojca Miha Mateja ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2018 5.5 4.6 8.7 ## 2 2019 5.8 4.2 9 Naloga: Spodnjo razpredelnico transformirajte v daljo obliko, tako da informacije o tevilu oddelkov shranite v 1 stolpec. df &lt;- tibble( podjetje = c(&quot;Podjetje A&quot;, &quot;Podjetje A&quot;, &quot;Podjetje B&quot;), kraj_tovarne = c(&quot;Koper&quot;, &quot;Kranj&quot;, &quot;Koper&quot;), prihodek = c(100000, 120000, 60000), razvojni_oddelki = c(2, 3, 1), prodajni_oddelki = c(3, 3, 2) ) df ## # A tibble: 3 x 5 ## podjetje kraj_tovarne prihodek razvojni_oddelki prodajni_oddelki ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Podjetje A Koper 100000 2 3 ## 2 Podjetje A Kranj 120000 3 3 ## 3 Podjetje B Koper 60000 1 2 Reitev: ## # A tibble: 6 x 5 ## podjetje kraj_tovarne prihodek oddelek stevilo_oddelkov ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Podjetje A Koper 100000 razvojni_oddelki 2 ## 2 Podjetje A Koper 100000 prodajni_oddelki 3 ## 3 Podjetje A Kranj 120000 razvojni_oddelki 3 ## 4 Podjetje A Kranj 120000 prodajni_oddelki 3 ## 5 Podjetje B Koper 60000 razvojni_oddelki 1 ## 6 Podjetje B Koper 60000 prodajni_oddelki 2 Spoznali bomo tudi relacijske podatke, pri katerih so podatki razdeljeni med ve razpredelnic. Zato bomo potrebovali ve funkcij, ki nam omogoajo zdruevanje teh razpredelnic. Poglejmo si dve razpredelnici: ekipe &lt;- tibble( id_ekipe = c(1, 2, 3, 4), ekipa = c(&quot;Liverpool&quot;, &quot;Manchester United&quot;, &quot;Arsenal&quot;, &quot;Rokova ekipa&quot;) ) igralci &lt;- tibble( id_igralca = c(1, 2, 3, 4, 5, 6, 7), ime = c(&quot;Henderson&quot;, &quot;Fernandes&quot;, &quot;Alisson&quot;, &quot;Rashford&quot;, &quot;Novak&quot;, &quot;Aubameyang&quot;, &quot;Vega&quot;), id_ekipe = c(1, 2, 1, 2, 8, 3, 8) ) ekipe ## # A tibble: 4 x 2 ## id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Liverpool ## 2 2 Manchester United ## 3 3 Arsenal ## 4 4 Rokova ekipa igralci ## # A tibble: 7 x 3 ## id_igralca ime id_ekipe ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 Henderson 1 ## 2 2 Fernandes 2 ## 3 3 Alisson 1 ## 4 4 Rashford 2 ## 5 5 Novak 8 ## 6 6 Aubameyang 3 ## 7 7 Vega 8 Za zdruevanje razpredelnic obstaja ve funkcij, vse imajo konnico _join. Poglejmo si, kako jih kliemo in kaj vsaka izmed njih naredi. Ve bomo o njih povedali na predavanju. left_join() zdrui razpredelnici tako, da obdri vse primere iz prve razpredelnice: left_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 7 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 5 Novak 8 &lt;NA&gt; ## 6 6 Aubameyang 3 Arsenal ## 7 7 Vega 8 &lt;NA&gt; right_join() zdrui razpredelnici tako, da obdri vse primere iz druge razpredelnice: right_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 6 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 6 Aubameyang 3 Arsenal ## 6 NA &lt;NA&gt; 4 Rokova ekipa inner_join() zdrui razpredelnici tako, da obdri samo primere, ki se pojavijo v obeh razpredelnicah: inner_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 5 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 6 Aubameyang 3 Arsenal full_join() zdrui razpredelnici tako, da obdri vse primere iz obeh razpredelnic: full_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 8 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 5 Novak 8 &lt;NA&gt; ## 6 6 Aubameyang 3 Arsenal ## 7 7 Vega 8 &lt;NA&gt; ## 8 NA &lt;NA&gt; 4 Rokova ekipa Naloga: Obstajata e dve operaciji zdruevanja, ki pa ne delujeta popolnoma enako kot zgornje funkcije. Pokliite funkciji semi_join() in anti_join() in poizkusite ugotoviti, kaj sta ti funkciji naredili. Sintaksa je enaka kot pri ostalih funkcijah join. Za branje podatkov iz tekstovnih datotek velikokrat uporabljamo funkcijo read.csv() ali katero od preostalih izpeljank funkcije read.table(). Tidyverse ima svojo razliico teh funkcij, ki pa imajo nekaj dodatne funkcionalnosti. Najbolj pomembna je ta, da se podatki samodejno shranijo kot tibble. To omogoa relativno enostavno branje datotek, kjer stolpci niso poimenovani v skladu s pravili programskega jezika R (na primer, lahko se zanejo s tevilom, lahko imajo minuse, presledke in podobno). Kot smo omenili shranjevanje podatkov, kjer imena stolpcev niso standardne oblike, ni dobra praksa. Vsekakor pa se pri realnih podatkih velikokrat zgodi, da imamo takna imena. V tem primeru je bolje, da jih prebermo takna kot so in jih programsko spremenimo, saj s tem ne posegamo v izvirne podatke. Je pa potrebno pri teh funkcijah dodatno nastaviti kodiranje, da znajo prebrati umnike. Poglejmo si uporabo funkcije read_csv2() paketa readr, kjer bomo ustrezno nastavili kodiranje. df &lt;- read_csv2(&quot;./data-raw/SLO-gradbena-dovoljenja-messy1.csv&quot;, locale = readr::locale(encoding = &quot;cp1250&quot;)) Ve o kodiranjih bomo povedali na zadnjem predavanju. 2.2 Urejeni podatki Omenili smo e, da se v praksi sreamo z najrazlinejimi oblikami zapisov podatkov. Skupek paketov tidyverse je namenjen delu s tako imenovanimi urejenimi podatki (ang. tidy data). Ideja je, da se ustvari enoten standard za obliko podatkov, s katero je laje delati. V kolikor se drimo tega standarda pri vseh naih analizah, nam to omogoa, da vedno uporabljamo ista orodja (na primer, ggplot2) in se nam ni potrebno uiti novih orodij za vsako analizo. Standard lahko povzamemo s 3 lastnostmi: vsak stolpec je spremenljivka, vsaka vrstica je primer podatka, vsaka vrednost ima svojo celico. Morda se na tej toki to slii nekoliko abstraktno. Poglejmo si praktien primer. Nabrali smo podatke o tevilu izdanih gradbenih dovoljenj v Sloveniji, razdeljeno glede na obine. Podatke smo prenesli s spletne strani statistinega urada Slovenije https://pxweb.stat.si/SiStat/slshranili in jih shranili na ve nainov. Najprej si poglejmo podatke v takni obliki, kot smo jih dobili naravnost iz vira. ## # A tibble: 424 x 16 ## OBINE TIP.STAVBE `2007` `2008` `2009` `2010` `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdov~ Stanovanjsk~ 52 55 45 33 52 40 29 30 ## 2 Ajdov~ Nestanovanj~ 19 9 22 15 27 11 23 11 ## 3 Ankaran~ Stanovanjsk~ NA NA NA NA NA NA NA NA ## 4 Ankaran~ Nestanovanj~ NA NA NA NA NA NA NA NA ## 5 Apae Stanovanjsk~ 10 11 22 12 7 5 9 10 ## 6 Apae Nestanovanj~ 3 3 8 3 4 6 2 3 ## 7 Beltinci Stanovanjsk~ 16 19 11 15 19 14 5 13 ## 8 Beltinci Nestanovanj~ 4 6 1 3 8 4 4 5 ## 9 Benedikt Stanovanjsk~ 11 12 6 9 7 3 16 10 ## 10 Benedikt Nestanovanj~ 3 2 1 3 5 3 4 3 ## # ... with 414 more rows, and 6 more variables: 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt;, ## # 2017 &lt;dbl&gt;, 2018 &lt;dbl&gt;, 2019 &lt;dbl&gt;, 2020 &lt;dbl&gt; Najprej imamo na voljo spremenljivki OBINE in TIP.STAVBE. Potem pa imamo za vsako leto natete vrednosti, oziroma tevila gradbenih dovoljenj. Podatki so velikokrat shranjeni v taknem formatu, saj ima doloene prednosti. Tak format je bolj prijazen za prikaz loveku, saj lahko samo s pogledom na razpredelnico hitro oceni, ali obstaja trend v posamezni vrstici. Format pa ni najbolji za delo s podatki. Govorili smo e o istih podatkih in da vse funkcije v tidyverse podpirajo operacije nad taknimi podatki. Kot vhod bo veina teh funkcij prejela iste podatke in takne potem tudi vrnila. Kaj je razlog, da ti podatki niso isti? Ne dri, da imamo v vsakem stolpcu spremenljivko, saj imamo eno spremenljivko razvleeno ez ve stolpcev  leto. Ta podatek vsekakor predstavlja spremenljivko, torej bi moral imeti enoten stolpec. Poglejmo si te podatke e v dveh neistih formatih. ## # A tibble: 28 x 214 ## TIP.STAVBE Leto Ajdovina `Ankaran/Ancaran~ Apae Beltinci Benedikt ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Stanovanjske stav~ 2007 52 NA 10 16 11 ## 2 Stanovanjske stav~ 2008 55 NA 11 19 12 ## 3 Stanovanjske stav~ 2009 45 NA 22 11 6 ## 4 Stanovanjske stav~ 2010 33 NA 12 15 9 ## 5 Stanovanjske stav~ 2011 52 NA 7 19 7 ## 6 Stanovanjske stav~ 2012 40 NA 5 14 3 ## 7 Stanovanjske stav~ 2013 29 NA 9 5 16 ## 8 Stanovanjske stav~ 2014 30 NA 10 13 10 ## 9 Stanovanjske stav~ 2015 38 3 12 23 13 ## 10 Stanovanjske stav~ 2016 31 1 10 22 15 ## # ... with 18 more rows, and 207 more variables: Bistrica ob Sotli &lt;dbl&gt;, ## # Bled &lt;dbl&gt;, Bloke &lt;dbl&gt;, Bohinj &lt;dbl&gt;, Borovnica &lt;dbl&gt;, Bovec &lt;dbl&gt;, ## # Braslove &lt;dbl&gt;, Brda &lt;dbl&gt;, Brezovica &lt;dbl&gt;, Breice &lt;dbl&gt;, Cankova &lt;dbl&gt;, ## # Celje &lt;dbl&gt;, Cerklje na Gorenjskem &lt;dbl&gt;, Cerknica &lt;dbl&gt;, Cerkno &lt;dbl&gt;, ## # Cerkvenjak &lt;dbl&gt;, Cirkulane &lt;dbl&gt;, renovci &lt;dbl&gt;, rna na Korokem &lt;dbl&gt;, ## # rnomelj &lt;dbl&gt;, Destrnik &lt;dbl&gt;, Divaa &lt;dbl&gt;, Dobje &lt;dbl&gt;, ## # Dobrepolje &lt;dbl&gt;, Dobrna &lt;dbl&gt;, Dobrova - Polhov Gradec &lt;dbl&gt;, ## # Dobrovnik/Dobronak &lt;dbl&gt;, Dol pri Ljubljani &lt;dbl&gt;, Dolenjske Toplice &lt;dbl&gt;, ## # Domale &lt;dbl&gt;, Dornava &lt;dbl&gt;, Dravograd &lt;dbl&gt;, Duplek &lt;dbl&gt;, ## # Gorenja vas - Poljane &lt;dbl&gt;, Gorinica &lt;dbl&gt;, Gorje &lt;dbl&gt;, ## # Gornja Radgona &lt;dbl&gt;, Gornji Grad &lt;dbl&gt;, Gornji Petrovci &lt;dbl&gt;, Grad &lt;dbl&gt;, ## # Grosuplje &lt;dbl&gt;, Hajdina &lt;dbl&gt;, Hoe - Slivnica &lt;dbl&gt;, Hodo/Hodos &lt;dbl&gt;, ## # Horjul &lt;dbl&gt;, Hrastnik &lt;dbl&gt;, Hrpelje - Kozina &lt;dbl&gt;, Idrija &lt;dbl&gt;, ## # Ig &lt;dbl&gt;, Ilirska Bistrica &lt;dbl&gt;, Ivanna Gorica &lt;dbl&gt;, Izola/Isola &lt;dbl&gt;, ## # Jesenice &lt;dbl&gt;, Jezersko &lt;dbl&gt;, Jurinci &lt;dbl&gt;, Kamnik &lt;dbl&gt;, Kanal &lt;dbl&gt;, ## # Kidrievo &lt;dbl&gt;, Kobarid &lt;dbl&gt;, Kobilje &lt;dbl&gt;, Koevje &lt;dbl&gt;, Komen &lt;dbl&gt;, ## # Komenda &lt;dbl&gt;, Koper/Capodistria &lt;dbl&gt;, Kostanjevica na Krki &lt;dbl&gt;, ## # Kostel &lt;dbl&gt;, Kozje &lt;dbl&gt;, Kranj &lt;dbl&gt;, Kranjska Gora &lt;dbl&gt;, ## # Krievci &lt;dbl&gt;, Krko &lt;dbl&gt;, Kungota &lt;dbl&gt;, Kuzma &lt;dbl&gt;, Lako &lt;dbl&gt;, ## # Lenart &lt;dbl&gt;, Lendava/Lendva &lt;dbl&gt;, Litija &lt;dbl&gt;, Ljubljana &lt;dbl&gt;, ## # Ljubno &lt;dbl&gt;, Ljutomer &lt;dbl&gt;, Log - Dragomer &lt;dbl&gt;, Logatec &lt;dbl&gt;, ## # Loka dolina &lt;dbl&gt;, Loki Potok &lt;dbl&gt;, Lovrenc na Pohorju &lt;dbl&gt;, ## # Lue &lt;dbl&gt;, Lukovica &lt;dbl&gt;, Majperk &lt;dbl&gt;, Makole &lt;dbl&gt;, Maribor &lt;dbl&gt;, ## # Markovci &lt;dbl&gt;, Medvode &lt;dbl&gt;, Menge &lt;dbl&gt;, Metlika &lt;dbl&gt;, Meica &lt;dbl&gt;, ## # Miklav na Dravskem polju &lt;dbl&gt;, Miren - Kostanjevica &lt;dbl&gt;, Mirna &lt;dbl&gt;, ## # Mirna Pe &lt;dbl&gt;, Mislinja &lt;dbl&gt;, ... Sedaj imamo podobno situacijo kot prej  ena spremenljivka je razvleena preko ve stolpcev  v tem primeru je to obina. Kot smo e omenili, so vsaki neisti podatki neisti na svoj nain. Podatki so popolnoma enaki kot v prejnjem prikazu, ampak razpredelnica izgleda popolnoma drugae. isti podatki pa imajo samo eno pravilno obliko, torej ne more priti do taknih dvoumnih prikazov. Poglejmo si e tretji format: ## # A tibble: 5,936 x 3 ## OBINA_TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina_Stanovanjske stavbe 2007 52 ## 2 Ajdovina_Stanovanjske stavbe 2008 55 ## 3 Ajdovina_Stanovanjske stavbe 2009 45 ## 4 Ajdovina_Stanovanjske stavbe 2010 33 ## 5 Ajdovina_Stanovanjske stavbe 2011 52 ## 6 Ajdovina_Stanovanjske stavbe 2012 40 ## 7 Ajdovina_Stanovanjske stavbe 2013 29 ## 8 Ajdovina_Stanovanjske stavbe 2014 30 ## 9 Ajdovina_Stanovanjske stavbe 2015 38 ## 10 Ajdovina_Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Ta je morda nekoliko blije istim podatkom, kot prejnja dva, ampak e vedno ni v popolnoma pravilni obliki. V em je teava? Dve spremenljivki imamo podani v enem stolpcu  obino in tip. Ker gre za razlini spremenljivki, bi bilo dobro, da se pojavita v razlinih stolpcih. Poglejmo si sedaj e iste podatke: ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Sedaj ima vsaka spremenljivka (obina, tip in leto) svoj stolpec, zadnji stolpec pa je namenjen vrednostim. V tem poglavju se bomo nauili neiste podatke spremeniti v iste. isti podatki imajo obiajno ve vrstic kot neisti in jim zato pravimo da so dalji (ang. longer). Neisti pa so obiajno iri (ang. wider). Izogibamo se besedam dolgi in iroki, saj je ta definicija relativna, se pravi lahko uporabimo transformacijo, ki naredi podatke dalje, ne pa nujno dolge, saj morda obstaja e kakna operacija, ki jih bo naredila e dalje. 2.3 pivot_longer(): pretvorba v daljo obliko Funkcija pivot_longer() podatke spremeni v daljo obliko. Ta trasformacija je pri delu s podatki bolj pogosta kot sprememba v iro. Obiajno uporabljamo to transformacijo, ko preurejamo podatke v iste. Poglejmo si ponovno neiste podatke, ki smo jih dobili naravnost iz vira: ## # A tibble: 424 x 16 ## OBINE TIP.STAVBE `2007` `2008` `2009` `2010` `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdov~ Stanovanjsk~ 52 55 45 33 52 40 29 30 ## 2 Ajdov~ Nestanovanj~ 19 9 22 15 27 11 23 11 ## 3 Ankaran~ Stanovanjsk~ NA NA NA NA NA NA NA NA ## 4 Ankaran~ Nestanovanj~ NA NA NA NA NA NA NA NA ## 5 Apae Stanovanjsk~ 10 11 22 12 7 5 9 10 ## 6 Apae Nestanovanj~ 3 3 8 3 4 6 2 3 ## 7 Beltinci Stanovanjsk~ 16 19 11 15 19 14 5 13 ## 8 Beltinci Nestanovanj~ 4 6 1 3 8 4 4 5 ## 9 Benedikt Stanovanjsk~ 11 12 6 9 7 3 16 10 ## 10 Benedikt Nestanovanj~ 3 2 1 3 5 3 4 3 ## # ... with 414 more rows, and 6 more variables: 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt;, ## # 2017 &lt;dbl&gt;, 2018 &lt;dbl&gt;, 2019 &lt;dbl&gt;, 2020 &lt;dbl&gt; Sedaj elimo te podatke spremeniti v isto obliko. Vse stolpce, ki prikazujejo razline vrednosti spremenljivke leto, moramo zapisati v 1 stolpec. Uporabimo funkcijo pivot_longer(), ki prejme argumente: data. Katere podatke elimo spremeniti. cols. V katerih stolpcih imamo vrednosti spremenljivke, ki jo elimo shraniti v 1 stolpec. df %&gt;% pivot_longer(cols = `2007`:`2020`) ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Sedaj imamo leta shranjena v stolpcu, prav tako pa vrednosti. Stolpca sta dobila privzeti meni name in value. Funkcija pivot_longer() pa lahko prejme e ve opcijskih argumentov, za nas bosta najbolj pomembna 2: names_to. Ime stolpca, v katerega bomo shranili spremenljivko. value_to. Ime stolpca, v katerega bomo shranili vrednosti. Uporabimo sedaj e ta 2 parametra: df_longer &lt;- df %&gt;% pivot_longer(cols = `2007`:`2020`, names_to = &quot;Leto&quot;, values_to = &quot;tevilo&quot;) df_longer ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE Leto tevilo ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows 2.4 pivot_wider(): pretvorba v iro obliko Obiajno bo ta transformacija naredila podatke neiste, vendar s tem ni ni narobe, saj imajo tudi takni podatki svoje prednosti: Podatki v iri obliki so loveku laje berljivi. Nekatera podjetja in podroja imajo razvite standarde, v katerih potrebujemo podatke v iri obliki. Nekatere metode, predvsem gre tukaj za metode strojnega uenja, delujejo bolje ali izkljuno s podatki v iri obliki. e elimo podatke pretvoriti v matriko. Za pretvorbo podatkov v iro obliko uporabimo funkcijo pivot_wider(), ki prejme dva argumenta: names_from. Ime stolpca, katerga elimo raztegniti v iro obliko. values_from. Ime stolpca, v katerem so shranjene vrednosti. Pretvorimo sedaj df_longer v iro obliko glede na stolpec TIP.STAVBE. df_wider &lt;- df_longer %&gt;% pivot_wider(names_from = TIP.STAVBE, values_from = tevilo) df_wider[1:14, ] ## # A tibble: 14 x 4 ## OBINE Leto `Stanovanjske stavbe` `Nestanovanjske stavbe` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina 2007 52 19 ## 2 Ajdovina 2008 55 9 ## 3 Ajdovina 2009 45 22 ## 4 Ajdovina 2010 33 15 ## 5 Ajdovina 2011 52 27 ## 6 Ajdovina 2012 40 11 ## 7 Ajdovina 2013 29 23 ## 8 Ajdovina 2014 30 11 ## 9 Ajdovina 2015 38 49 ## 10 Ajdovina 2016 31 66 ## 11 Ajdovina 2017 33 60 ## 12 Ajdovina 2018 42 36 ## 13 Ajdovina 2019 38 39 ## 14 Ajdovina 2020 42 46 S taknim prikazom lahko relativno hitro opazimo doloene trende. Na primer v Ajdovini se je gradilo veliko ve stanovanjskih stavb med leti 2007 in 2014, leta 2015 pa se je oitno zaelo graditi ve nestanovanjskih stavb, kar bi lahko nakazovalo na gospodarsko rast tega mesta. Za loveka je torej tak prikaz bolji. Vsekakor pa bi v tem primeru raje uporabili vizualizacijo. 2.5 separate() in unite(): deljenje in zdruevanje stolpcev V uvodu tega poglavja smo prikazali podatke, kjer sta bili dve spremenljivki shranjeni v enem stolpcu. Poglejmo si te podatke e enkrat: df &lt;- read_csv2(&quot;./data-raw/SLO-gradbena-dovoljenja-messy2.csv&quot;, locale = readr::locale(encoding = &quot;cp1250&quot;)) df ## # A tibble: 5,936 x 3 ## OBINA_TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina_Stanovanjske stavbe 2007 52 ## 2 Ajdovina_Stanovanjske stavbe 2008 55 ## 3 Ajdovina_Stanovanjske stavbe 2009 45 ## 4 Ajdovina_Stanovanjske stavbe 2010 33 ## 5 Ajdovina_Stanovanjske stavbe 2011 52 ## 6 Ajdovina_Stanovanjske stavbe 2012 40 ## 7 Ajdovina_Stanovanjske stavbe 2013 29 ## 8 Ajdovina_Stanovanjske stavbe 2014 30 ## 9 Ajdovina_Stanovanjske stavbe 2015 38 ## 10 Ajdovina_Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Vasih se sreamo celo z dvema vrednostima v istem stolpcu. Da loimo ti spremenljivki na dva stolpca uporabimo funkcijo separate(): separate(&lt;podatki&gt;, col = &lt;ime-stolpca&gt;, into = &lt;ime-novih-stolpcev&gt;, sep = &lt;znak-ki-locuje&gt;) Uporabimo sedaj to funkcijo da pretvorimo df v isto obliko: df_tidy &lt;- df %&gt;% separate(col = &quot;OBINA_TIP&quot;, into = c(&quot;OBINA&quot;, &quot;TIP&quot;), sep = &quot;_&quot;) df_tidy ## # A tibble: 5,936 x 4 ## OBINA TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Obstaja pa tudi obratna operacija unite(), ki zdrui dva stolpca: unite(&lt;podatki&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ..., sep = &lt;znak-ki-locuje&gt;) Pri tem tri pikice prestavljajo morebitne preostale stolpce, saj jih lahko zdruimo ve. Za primer si poglejmo, kako bi v eno spremenljivko shranili podatke o tevilu stanovanjskih in nestanovanjskih gradbenih dovoljenj. Najprej pretvorimo podatke v iro obliko glede na tip, potem pa ta nova stolpca zdruimo s funkcijo unite(). df_wider &lt;- df_tidy %&gt;% pivot_wider(names_from = TIP, values_from = tevilo.gradbenih.dovoljenj) %&gt;% unite(&quot;Stanovanjske/Nestanovanjske&quot;, &quot;Stanovanjske stavbe&quot;, &quot;Nestanovanjske stavbe&quot;, sep = &quot;/&quot;) df_wider ## # A tibble: 2,968 x 3 ## OBINA Leto `Stanovanjske/Nestanovanjske` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Ajdovina 2007 52/19 ## 2 Ajdovina 2008 55/9 ## 3 Ajdovina 2009 45/22 ## 4 Ajdovina 2010 33/15 ## 5 Ajdovina 2011 52/27 ## 6 Ajdovina 2012 40/11 ## 7 Ajdovina 2013 29/23 ## 8 Ajdovina 2014 30/11 ## 9 Ajdovina 2015 38/49 ## 10 Ajdovina 2016 31/66 ## # ... with 2,958 more rows 2.6 Relacijske zbirke podatkov Pogosto se pri analizi podatkov sreamo z razpredelnicami, ki so med seboj logino povezane. Nekaj primerov: V spletni trgovini lahko hranimo podatke v 3 razpredelnicah o produktih, kupcih in nakupih. Razpredelnice so med seboj povezane, na primer razpredelnica o nakupih vsebuje ID kupca in produkta. Baze podatkov o filmih, kot je IMDB, imajo na primer podatke o filmih, ocenjevalcih, igralcih in ocenah. Filmi povezujejo vse preostale razpredelnice. Bioloke podatkovne zbirke lahko imajo razpredelnice atomov, molekul in vezi. Pri eleznikem omreju imamo razpredelnice z vlaki, vagoni, eleznikimi postajami, prihodi in odhodi. Pri nogometu imamo razpredelnice z igralci, klubi in odigranimi tekmami. Taknim podatkovnim zbirkam pravimo relacijske zbirke podatkov, saj so poleg podatkov v razpredelnicah pomembne tudi relacije oziroma povezave med razpredelnicami. Zaenkrat smo se nauili, kako urejati podatke v eni razpredelnici. e elimo analizirati relacijske podatke, moramo znati upotevati tudi povezave med njimi in jih ustrezno zdruevati. V tem poglavju bomo predelali operacije, ki nam to omogoajo. Morda ste se e sreali z jezikom SQL, ki se obiajno uporablja za urejanje podatkov v sistemih za upravljanje relacijskih podatkovnih baz (ang. relational database management systems, RDBMS). Paket dplyr ima podobno sintakso kot SQL, vendar pa ni popolnoma enaka. Je tudi enostavneji za uporabo pri analizi podatkov, saj je ustvarjen prav s tem namenom. 2.7 Primer: Banni podatki V tem poglavju bomo delali s podatki eke banke (https://data.world/lpetrocelli/czech-financial-dataset-real-anonymized-transactions, https://relational.fit.cvut.cz/dataset/Financial). Gre za realno anonimizirano podatkovno zbirko, ki je bila uporabljena v izzivu PKDD99 Discovery Challenge (https://sorry.vse.cz/~berka/challenge/pkdd1999/berka.htm). Cilj izziva je bil odkriti dobre in slabe kliente z namenom izboljanja ponudbe. Mi bomo te podatke uporabili za ilustracijo operacij na relacijski zbirki podatkov. V mapi data_raw/financial se nahaja 5 razpredelnic v csv formatu: account.csv, client.csv, disp.csv, loan.csv in transaction-smaller.csv. Izvirni podatki vsebujejo e nekaj razpredelnic, vendar jih bomo z namenom uinkovitega prikaza izpustili. Prav tako smo pri razpredelnici transaction.csv nakljuno izbrali 20000 vrstic, saj originalna datoteka vsebuje preko milijon vrstic, kar bi upoasnilo izvajanje ukazov in zasedlo veliko prostora na repozitoriju. V kolikor elite raziskati celotno zbirko, predlagamo, da si podatke prenesete iz vira. Poglejmo si sedaj vsako izmed razpredelnic. Razpredelnica account vsebuje podatke o raunih na banki. account &lt;- read_csv2(&quot;./data-raw/financial/account.csv&quot;) account ## # A tibble: 4,500 x 4 ## account_id district_id frequency date ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; ## 1 1 18 monthly payment 1995-03-24 ## 2 2 1 monthly payment 1993-02-26 ## 3 3 5 monthly payment 1997-07-07 ## 4 4 12 monthly payment 1996-02-21 ## 5 5 15 monthly payment 1997-05-30 ## 6 6 51 monthly payment 1994-09-27 ## 7 7 60 monthly payment 1996-11-24 ## 8 8 57 monthly payment 1995-09-21 ## 9 9 70 monthly payment 1993-01-27 ## 10 10 54 monthly payment 1996-08-28 ## # ... with 4,490 more rows Razpredelnica client vsebuje podatke o strankah. client &lt;- read_csv2(&quot;./data-raw/financial/client.csv&quot;) client ## # A tibble: 5,369 x 4 ## client_id gender birth_date district_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 1 F 1970-12-13 18 ## 2 2 M 1945-02-04 1 ## 3 3 F 1940-10-09 1 ## 4 4 M 1956-12-01 5 ## 5 5 F 1960-07-03 5 ## 6 6 M 1919-09-22 12 ## 7 7 M 1929-01-25 15 ## 8 8 F 1938-02-21 51 ## 9 9 M 1935-10-16 60 ## 10 10 M 1943-05-01 57 ## # ... with 5,359 more rows Razpredelnica disp povee podatke o osebah in raunih, torej, katere osebe imajo pravico opravljati s katerimi rauni. disp &lt;- read_csv2(&quot;./data-raw/financial/disp.csv&quot;) disp ## # A tibble: 5,369 x 4 ## disp_id client_id account_id type ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 1 1 OWNER ## 2 2 2 2 OWNER ## 3 3 3 2 DISPONENT ## 4 4 4 3 OWNER ## 5 5 5 3 DISPONENT ## 6 6 6 4 OWNER ## 7 7 7 5 OWNER ## 8 8 8 6 OWNER ## 9 9 9 7 OWNER ## 10 10 10 8 OWNER ## # ... with 5,359 more rows Razpredelnica loan vsebuje podatke o posojilih. loan &lt;- read_csv2(&quot;./data-raw/financial/loan.csv&quot;) loan ## # A tibble: 682 x 7 ## loan_id account_id date amount duration payments status ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 4959 2 1994-01-05 80952 24 3373 A ## 2 4961 19 1996-04-29 30276 12 2523 B ## 3 4962 25 1997-12-08 30276 12 2523 A ## 4 4967 37 1998-10-14 318480 60 5308 D ## 5 4968 38 1998-04-19 110736 48 2307 C ## 6 4973 67 1996-05-02 165960 24 6915 A ## 7 4986 97 1997-08-10 102876 12 8573 A ## 8 4988 103 1997-12-06 265320 36 7370 D ## 9 4989 105 1998-12-05 352704 48 7348 C ## 10 4990 110 1997-09-08 162576 36 4516 C ## # ... with 672 more rows Razpredelnica trans vsebuje podatke o transakcijah. trans &lt;- read_csv2(&quot;./data-raw/financial/transaction-smaller.csv&quot;) trans ## # A tibble: 20,000 x 10 ## trans_id account_id date type operation amount balance k_symbol bank ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 736882 2517 1997-07-17 CHOICE CHOICE 21992 22279 &lt;NA&gt; &lt;NA&gt; ## 2 201830 686 1997-05-08 INCOME DEPOSIT 10533 18473 &lt;NA&gt; &lt;NA&gt; ## 3 3158278 10478 1998-01-29 EXPEN~ CHOICE 2100 8821 &lt;NA&gt; &lt;NA&gt; ## 4 41116 135 1994-05-09 EXPEN~ CHOICE 2900 21513 &lt;NA&gt; &lt;NA&gt; ## 5 1046207 3578 1996-09-08 EXPEN~ TRANSFER~ 4051 51755 SIPO KL ## 6 875501 2982 1997-04-30 EXPEN~ CHOICE 12100 41859 &lt;NA&gt; &lt;NA&gt; ## 7 893918 3047 1996-11-30 EXPEN~ CHOICE 15 24788 SERVICES &lt;NA&gt; ## 8 3442751 1543 1998-07-31 INCOME &lt;NA&gt; 71 17153 UROK &lt;NA&gt; ## 9 462371 1571 1998-08-25 EXPEN~ CHOICE 2760 25770 &lt;NA&gt; &lt;NA&gt; ## 10 1028586 3513 1993-10-12 EXPEN~ TRANSFER~ 4507 31227 SIPO KL ## # ... with 19,990 more rows, and 1 more variable: account &lt;dbl&gt; Imamo 5 razpredelnice, vse pa so med seboj povezane. Razpredelnici account in client sta povezani preko razpredelnice disp. Razpredelnici loan in transsta povezani z razpredelnico account preko spremenljivke account_id. To strukturo najbolje prikaemo z relacijskim diagramom. Relacijski diagram 2.8 Kljui Spremenljivkam, ki povezujejo razpredelnice, pravimo kljui. Te spremenljivke (ali zbirke spremenljivk) edinstveno definirajo podatke. Lahko gre za eno spremenljivko, kot je na primer account_id v razpredelnici account. Lahko pa obstaja ve spremenljivk, ki definirajo en podatek. Na primer, e imamo razpredelnico s temperaturami za vsak dan in uro. Potem ni nujno, da ima vsaka vrstica svoj ID, lahko pa jih edinstveno loimo na podlagi dveh spremenljivk  dneva in ure. V tem primeru gre torej za klju, ki je sestavljen iz dveh spremenljivk. Poznamo dva glavna tipa kljuev: Primarni klju. Ta klju edinstveno definira podatek v razpredelnici. Na primer, trans_id v razpredelnici trans. V urejenih podatkih ima vsaka tabela svoj primarni klju. Tuj klju. To je klju v razpredelnici, ki je primarni klju v eni od preostalih razpredelnic. Na primer, account_id v razpredelnici trans. Vrednosti tujih kljuev se lahko podvajajo. Na primer, ve transakcij lahko ima isto vrednost tujega kljua za account_id, saj se na enem bannem raunu izvede ve transakcij. V kolikor razpredelnica nima primarnega kljua, lahko ustvarimo t. i. nadomestni klju, ki igra vlogo primarnega kljua. To lahko naredimo na primer tako, da vsaki vrstici priredimo njeno zaporedno vrednost v razpredelnici. Na primer mutate(row_number()). Primarni in tuj klju skupaj tvorita relacijo med razpredelnicama. Na primer account_id predstavlja relacijo med razpredelnicama trans in account. Relacije so lahko ena-proti-ena (ena drava ima enega predsednika in ena oseba je lahko predsednik samo ene drave), ena-proti-mnogo (en igralec lahko igra za en klub, ampak en klub ima ve igralcev) ali mnogo-proti-mnogo (en avtor lahko napie ve knjig in ena knjiga je lahko napisana s strani veih avtorjev). Kadar imamo opravka z relacijskimi podatki, je smiselno preveriti, ali je primarni klju res edinstven za vsako razpredelnico. df_list &lt;- list(account, client, disp, trans, loan) id_vec &lt;- c(&quot;account_id&quot;, &quot;client_id&quot;, &quot;disp_id&quot;, &quot;trans_id&quot;, &quot;loan_id&quot;) for (i in 1:length(df_list)) { tmp &lt;- df_list[[i]] %&gt;% group_by(.data[[id_vec[i]]]) %&gt;% summarise(n = n()) %&gt;% filter(n &gt; 1) print(tmp) } ## # A tibble: 0 x 2 ## # ... with 2 variables: account_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: client_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: disp_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: trans_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: loan_id &lt;dbl&gt;, n &lt;int&gt; V prejnjem klicu kode se pojavi nova sintaksa, in sicer .data[[id_vec[i]]]. Funkcija group_by() uporablja t. i. tidyselect, s katerim izbiramo stolpce brez da bi jih dali v narekovaje. To pa predstavlja teavo, kadar so imena stolpcev shranjena v neki spremenljivki, kot v tem primeru. Tidyverse je ustvarjen na naelu, da olaja bolj pogoste operacije (na primer, enostavno uporaba group_by() pri urejanju posamezne razpredelnice), za ceno teje izvedbe manj pogostih operacij (na primer, uporaba group_by() v zanki for). Veliko veino urejanja podatkov bomo lahko z uporabo tidyverse naredili brez uporabe zank ali naprednih lastnih funkcij. V kolikor se boste lotili bolj programerskega pristopa, pa predlagamo, da si preberete navodila za programiranje z dplyr, ki jih dobite tako, da v konzoli kliete vignette('programming'). Na tej delavnici ne bomo predstavili podrobnosti teh pristopov. Zaenkrat je dovolj, da poznamo samo zgornji klic. Torej, e imamo imena stolpcev shranjena v neki spremenljivki, potem moramo znotraj tidyselecta uporabiti .data[[&lt;spremenljivka-z-imeni-stolpcev&gt;]]. 2.9 Zdruevanja Kadar imamo opravka z veimi razpredelnicami potrebujemo orodja, s katerimi lahko posamezne pare razpredelnic zdruimo. Vei uporabniki R morda e poznajo funkcijo merge, ki je del osnovne razliice R in je namenjena splonemu zdruevanju razpredelnic. Seveda pa tidyverse premore svoje razliice podobnih funkcij, ki premorejo enake lastnosti kot preostale funkcije v tej zbirki  prejmejo in vrnejo podatke v enakem formatu in sicer tibblu. Poleg tega so funkcije iz paketa dplyr tudi hitreje od merge, kar ima pomembno vlogo, kadar imamo opravka z nekoliko vejimi podatkovnimi mnoicami. Zdruevanja podatkovnih razpredelnic lahko loimo na 3 sklope: Mutirajoa zdruevanja (ang. mutating joins). Dodajo nove stolpce k razpredelnici iz ujemajoih vrstic druge razpredelnice. Filtrirajoa zdruevanja (ang. filtering joins). Izberejo vrstice ene razpredenice glede na to, ali se te ujemajo z vrsticami v drugi razpredelnici. Operacije nad mnoicami. Operirajo nad vrsticami, kot da so ti deli mnoice. 2.9.1 Mutirajoa zdruevanja Mutirajoa zdruevanja so pogosta operacija pri delu z relacijskimi podatki. Te operacije zdruijo dve (ali ve) razpredelnici glede na vrednosti stolpcev. Obstajajo 4 takne operacije: left_join(). Ohrani vse vrstice prve (leve) razpredelnice in povee ustrezne vrstice iz druge razpredelnice s temi vrsticami. right_join(). Ohrani vse vrstice druge (desne) razpredelnice in povee ustrezne vrstice iz prve rapredelnice s temi vrsticami. full_join(). Ohrani vse vrstice obeh razpredelnic. inner_join(). Ohrani samo tiste vrstice, ki se pojavijo v obeh razpredelnicah. Prvi trije so tako imenovani zunanji stiki (outer join), saj uporabijo vrstice, ki se pojavijo vsaj v eni razpredelnici. Za laje razumevanje bomo najprej prikazali uporabo stikov na podatkih, ki jih bomo ustvarili sami. Sintaksa pri vseh zdruevanjih je: left_join(&lt;razpredelnica1&gt;, &lt;razpredelnica2&gt;) Ustvarimo dva tibbla: df1 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), x = c(4, 6, 1, 2) ) df2 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id3&quot;, &quot;id4&quot;, &quot;id5&quot;), y = c(20, 52, 11, 21) ) df1 ## # A tibble: 4 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 1 ## 4 id4 2 df2 ## # A tibble: 4 x 2 ## id y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id3 52 ## 3 id4 11 ## 4 id5 21 left_join() obdri tibble df1 taken kot je in mu pripne stolpec y iz tibbla df2, kjer so vrednosti spremenljivke id enake. Za tiste vrstice df1, ki nimajo ustreznega id v df2 se vrednosti v spremenljivki y nastavijo na NA. left_join(df1, df2) ## # A tibble: 4 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id2 6 NA ## 3 id3 1 52 ## 4 id4 2 11 right_join() obdri tibble df2 taken kot je in mu pripne stolpec x iz tibbla df1, kjer so vrednosti spremenljivke id enake. Za tiste vrstice df2, ki nimajo ustreznega id v df1, se vrednosti v spremenljivki y nastavijo na NA. right_join(df1, df2) ## # A tibble: 4 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id3 1 52 ## 3 id4 2 11 ## 4 id5 NA 21 inner_join() obdri samo tiste podatke, kjer se id nahaja v obeh razpredelnicah (torej 1, 3 in 4). Vse preostale vrstice zavre. inner_join(df1, df2) ## # A tibble: 3 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id3 1 52 ## 3 id4 2 11 full_join() obdri vse podatke iz df1 in df2. Kjer ni ustreznega id v nasprotni razpredelnici se vrednosti nastavijo na NA. full_join(df1, df2) ## # A tibble: 5 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id2 6 NA ## 3 id3 1 52 ## 4 id4 2 11 ## 5 id5 NA 21 Najbolj pogosto bomo uporabljali left_join(), kadar bo cilj obdrati originalno razpredelnico, kot je, ali inner_join(), kadar bomo eleli podatke brez manjkajoih vrednosti. Stik right_join() je samo drugae usmerjen left_join(). Do sedaj smo prikazovali, kako zdruimo razpredelnice glede na primarni klju, za katerega predpostavljamo, da je unikaten. Torej vsaka vrstica ima svoj klju, ki se v razpredelnici ne ponovi. Vasih pa razpredelnice zdruujemo glede na sekundarni klju. V tem primeru se lahko zgodi, da imamo relacijo ena-proti-mnogo. e vzamemo banne podatke od zgoraj ima lahko en raun ve skrbnikov. Kaj se zgodi v tem primeru? Kaj pa e zdruimo transakcije in osebe glede na raun? En raun ima lahko ve transakcij in ve skrbnikov. Ker pri obeh razpredelnicah uporabimo sekundarni klju, bomo najverjetneje dobili podvojene vrednosti pri obeh. Poglejmo si sedaj na primeru podatkov, ki jih generiramo sami. df3 &lt;- tibble( id1 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), id2 = c(&quot;id1&quot;, &quot;id1&quot;, &quot;id3&quot;, &quot;id4&quot;), x = c(5, 6, 1, 2) ) df4 &lt;- tibble( id2 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;), y = c(20, 52, 11) ) df5 &lt;- tibble( id3 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), id2 = c(&quot;id1&quot;, &quot;id1&quot;, &quot;id4&quot;, &quot;id5&quot;), z = c(5, 1, 23, 5) ) df3 ## # A tibble: 4 x 3 ## id1 id2 x ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 ## 2 id2 id1 6 ## 3 id3 id3 1 ## 4 id4 id4 2 df4 ## # A tibble: 3 x 2 ## id2 y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id2 52 ## 3 id3 11 df5 ## # A tibble: 4 x 3 ## id3 id2 z ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 ## 2 id2 id1 1 ## 3 id3 id4 23 ## 4 id4 id5 5 df3 in df5 imata podvojen sekundarni klju. Zdruimo sedaj df3 in df4 z uporabo inner_join(). inner_join(df3, df4) ## # A tibble: 3 x 4 ## id1 id2 x y ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 id1 5 20 ## 2 id2 id1 6 20 ## 3 id3 id3 1 11 Klju torej ostane podvojen. Kaj pa se zgodi, e imata obe razpredelnici podvojene kljue? V tem primeru dobimo kartezini produkt vseh podvojenih vrednosti: inner_join(df3, df5) ## # A tibble: 5 x 5 ## id1 id2 x id3 z ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 id1 5 ## 2 id1 id1 5 id2 1 ## 3 id2 id1 6 id1 5 ## 4 id2 id1 6 id2 1 ## 5 id4 id4 2 id3 23 df3 in df5 imata podvojeno vrednost kljua id1. Torej dobimo vse kombinacije preostalih vrednosti (5, 5), (5, 1), (6, 5) in (6, 1). 2.9.2 Argument by Zdruevanja, ki smo jih spoznali, privzeto zdruijo razpredelnici glede na vrednosti v vseh stolpcih, ki imajo enaka imena  tamu pravimo tudi naravno zdruevanje (ang. natural join). Lahko pa tudi sami doloimo, po katerih stolpcih elimo zdruiti podatke. To naredimo tako, da pri zdruevanjih uporabimo argument by. Sintaksa zdruevanj je potem: inner_join(&lt;razpredelnica1&gt;, &lt;razpredelnica2&gt;, by = &lt;vektor-imen-stolpcev&gt;) inner_join() dveh razpredelnic bi potem zapisali kot: inner_join(df3, df4, by = &quot;id2&quot;) ## # A tibble: 3 x 4 ## id1 id2 x y ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 id1 5 20 ## 2 id2 id1 6 20 ## 3 id3 id3 1 11 Ta primer slui samo kot ilustracija in je uporaba by nepotrebna. Seveda pa se pri realnih podatkih velikokrat sreamo s stanjem, kjer ta argument potrebujemo. Prav tako je koda s parametrom by bolj robustna, saj sami definiramo, glede na katere stolpce naj se razpredelnice zdruujejo in ne more priti do kaknih napak pri ponovljivosti. Razpredelnici lahko zdruimo tudi po stolpcih, ki nimajo istega imena. Ni nenavadno, da imamo dve razpredelnici z enakimi spremenljivkami, ki pa so poimenovane drugae. e bi eleli taki razpredelnici zdruiti glede na to spremenljivko, potem bi jo morali naeloma v eni razpredelnici preimenovati. S paketom dplyr pa lahko to naredimo tudi drugae. Zdruimo sedaj df3 in df5 glede na stolpca x in z ter skupni stolpec id2. inner_join(df3, df5, by = c(&quot;x&quot; = &quot;z&quot;, &quot;id2&quot;)) ## # A tibble: 1 x 4 ## id1 id2 x id3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id1 id1 5 id1 2.9.3 Filtrirajoa zdruevanja Pri filtrirajoih zdruevanjih ne gre toliko za zdruevanja, kolikor gre za izbiro posameznih vrstic, glede na ujemanje vrednotsti stolpcev v neki drugi razpredelnici. Poznamo 2 takni zdruevanji: semi_join(). Obdri vse vrstice v prvi razpredelnici, ki ustrezajo vrsticam v drugi razpredelnici. anti_join(). Izloi vse vrstice v prvi razpredelnici, ki ustrezajo vrsticam v drugi razpredelnici. Poglejmo si uporabo teh zdruevanj na naih generiranih razpredelnicah. df1 ## # A tibble: 4 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 1 ## 4 id4 2 df2 ## # A tibble: 4 x 2 ## id y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id3 52 ## 3 id4 11 ## 4 id5 21 semi_join(df1, df2) ## # A tibble: 3 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id3 1 ## 3 id4 2 semi_join() je torej izloil vrstico z id2, saj se ta ne pojavi v df2. anti_join(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id2 6 semi_join() je torej izloil vse vrstice, ki se pojavijo tudi v df2. Ostane torej samo vrstica z id2. 2.9.4 Zdruevanja na realnih podatkih Sedaj, ko smo spoznali glavne lastnosti razlinih zdruevanj na primerih, ki so nam omogoali lajo predstavo, pa se posvetimo realnim podatkom, ki smo jih predstavili v zaetku tega poglavja. Imamo torej podatke o bannih raunih, transakcijah, posojilih, skrbnikih raunov in povezovalno razpredelnico med rauni in skrbniki. Lotimo se sedaj relativno enostavne analize, kjer bomo naredili sledee: Ustvarili novo razpredelnico, kjer bomo imeli podatke o vseh bannih raunih in o lastnikih teh raunov. Lastnik rauna je lahko samo en, medtem ko je skrbnikov lahko ve. Filtrirali razpredelnico iz toke 1), v kateri bodo samo tisti, ki imajo posojila nad 100000 kron. Ustvarili novo razpredelnico klientov, kjer bomo imeli podatke o klientih in posojilih in bodo zajeti samo klienti s posojili. Izraunali kateri klienti, ki imajo posojilo, imajo tudi najve transakcij. Za vsakega izmed teh korakov bomo morali uporabiti eno od zdruevanj, ki smo jih spoznali. Na primer, v samih razpredelnicah nimamo direktne povezave med komitenti in transakcijami, tako da bomo morali zadeve nekako zdruiti. Podobno velja za ostale alineje. Najprej elimo zdruiti razpredelnici account in client. Za to bomo potrebovali povezovalno razpredelnico disp v kateri se tudi nahaja informacija o tem, ali je klient lastnik ali samo skrbnik rauna. Najprej poveemo razpredelnico account z razpredelnico disp in filtriramo glede na tip klienta: account_disp &lt;- left_join(account, disp) %&gt;% filter(type == &quot;OWNER&quot;) account_disp ## # A tibble: 4,500 x 7 ## account_id district_id frequency date disp_id client_id type ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 18 monthly payment 1995-03-24 1 1 OWNER ## 2 2 1 monthly payment 1993-02-26 2 2 OWNER ## 3 3 5 monthly payment 1997-07-07 4 4 OWNER ## 4 4 12 monthly payment 1996-02-21 6 6 OWNER ## 5 5 15 monthly payment 1997-05-30 7 7 OWNER ## 6 6 51 monthly payment 1994-09-27 8 8 OWNER ## 7 7 60 monthly payment 1996-11-24 9 9 OWNER ## 8 8 57 monthly payment 1995-09-21 10 10 OWNER ## 9 9 70 monthly payment 1993-01-27 12 12 OWNER ## 10 10 54 monthly payment 1996-08-28 13 13 OWNER ## # ... with 4,490 more rows Sedaj lahko to novo razpredelnico poveemo z razpredelnico client. account_client &lt;- left_join(account_disp, client) S tem smo dobili eljeno razpredelnico, v kateri imamo za vsak raun tudi informacijo o lastniku. Kot drugi korak elimo ustvariti razpredelnico, v kateri bodo samo podatki o klientih, ki imajo posojila v vrednosti ve kot 100000 kron. Najprej ustvarimo razpredelnico, v kateri so samo takna posojila, nato pa uporabimo semi_join(), ki bo iz razpredelnice account_client izbral samo vrstice, ki se bodo ujemale z vrsticami v tej novi razpredelnici posojil. loan_100k &lt;- loan %&gt;% filter(amount &gt; 100000) account_100k &lt;- semi_join(account_client, loan_100k) account_100k ## # A tibble: 0 x 9 ## # ... with 9 variables: account_id &lt;dbl&gt;, district_id &lt;dbl&gt;, frequency &lt;chr&gt;, ## # date &lt;date&gt;, disp_id &lt;dbl&gt;, client_id &lt;dbl&gt;, type &lt;chr&gt;, gender &lt;chr&gt;, ## # birth_date &lt;date&gt; Hmdobili smo prazen tibble, eprav obstajajo tako velika posojila. Zakaj je do tega prilo? V obeh razpredelnicah se nahajata spremenjivki account_id in date. Ampak spremenljivka date ni ista spremenljivka, pri razpredelnici account_client predstavlja, kdaj je bil raun odprt, pri loan_100k pa predstavlja kdaj je bilo posojilo odobreno. Torej po tej spremenljivki ne smemo zdruevati. Uporabimo by: account_100k &lt;- semi_join(account_client, loan_100k, by = &quot;account_id&quot;) account_100k ## # A tibble: 377 x 9 ## account_id district_id frequency date disp_id client_id type gender ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 37 20 monthly pay~ 1997-08-18 45 45 OWNER M ## 2 38 19 weekly paym~ 1997-08-08 46 46 OWNER F ## 3 67 16 monthly pay~ 1994-10-19 78 78 OWNER F ## 4 97 74 monthly pay~ 1996-05-05 116 116 OWNER M ## 5 103 44 monthly pay~ 1996-03-10 124 124 OWNER M ## 6 105 21 monthly pay~ 1997-07-10 127 127 OWNER F ## 7 110 36 monthly pay~ 1996-07-17 132 132 OWNER M ## 8 173 66 monthly pay~ 1993-11-26 210 210 OWNER M ## 9 226 70 monthly pay~ 1997-02-23 272 272 OWNER F ## 10 276 38 monthly pay~ 1997-12-08 333 333 OWNER M ## # ... with 367 more rows, and 1 more variable: birth_date &lt;date&gt; V naslednjem koraku elimo imeti podatke o klientih in posojilih. Najprej bomo morali zdruiti razpredelnici client in disp, nato pa dodati e razpredelnico loan. Ustvarimo to novo razpredelnico kar z uporabo operatorja %&gt;%: client_loan &lt;- client %&gt;% left_join(disp) %&gt;% inner_join(loan, by = &quot;account_id&quot;) client_loan ## # A tibble: 827 x 13 ## client_id gender birth_date district_id disp_id account_id type loan_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 M 1945-02-04 1 2 2 OWNER 4959 ## 2 3 F 1940-10-09 1 3 2 DISPONENT 4959 ## 3 25 F 1939-04-23 21 25 19 OWNER 4961 ## 4 31 M 1962-02-09 68 31 25 OWNER 4962 ## 5 45 M 1952-08-26 20 45 37 OWNER 4967 ## 6 46 F 1940-01-30 19 46 38 OWNER 4968 ## 7 78 F 1944-06-13 16 78 67 OWNER 4973 ## 8 116 M 1942-01-28 74 116 97 OWNER 4986 ## 9 117 F 1936-09-20 74 117 97 DISPONENT 4986 ## 10 124 M 1967-09-21 44 124 103 OWNER 4988 ## # ... with 817 more rows, and 5 more variables: date &lt;date&gt;, amount &lt;dbl&gt;, ## # duration &lt;dbl&gt;, payments &lt;dbl&gt;, status &lt;chr&gt; Na koncu preverimo e, kateri klienti, ki imajo posojilo, imajo najve transakcij. Za to bomo morali najprej izraunati tevilo transakcij na vsakem bannem raunu. Uporabimo znanje, ki smo ga pridobili na prvem predavanju: trans_count &lt;- trans %&gt;% group_by(account_id) %&gt;% summarise(n_trans = n()) trans_count ## # A tibble: 4,205 x 2 ## account_id n_trans ## &lt;dbl&gt; &lt;int&gt; ## 1 1 6 ## 2 2 10 ## 3 3 3 ## 4 4 6 ## 5 5 3 ## 6 6 8 ## 7 7 3 ## 8 8 7 ## 9 9 3 ## 10 10 1 ## # ... with 4,195 more rows left_join(client_loan, trans_count) %&gt;% arrange(desc(n_trans)) ## # A tibble: 827 x 14 ## client_id gender birth_date district_id disp_id account_id type loan_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 11126 F 1965-01-22 1 10818 9034 OWNER 6820 ## 2 6367 M 1970-04-28 44 6367 5270 OWNER 6077 ## 3 7291 F 1940-12-02 77 7291 6034 OWNER 6228 ## 4 7195 M 1962-09-11 50 7195 5952 OWNER 6216 ## 5 4620 F 1940-11-01 54 4620 3834 OWNER 5754 ## 6 4621 M 1946-02-10 54 4621 3834 DISPONENT 5754 ## 7 11461 M 1974-07-08 70 11153 9307 OWNER 6895 ## 8 11866 M 1937-09-02 1 11558 9640 OWNER 6960 ## 9 11867 F 1934-11-19 1 11559 9640 DISPONENT 6960 ## 10 13657 F 1963-05-12 59 13349 11111 OWNER 7259 ## # ... with 817 more rows, and 6 more variables: date &lt;date&gt;, amount &lt;dbl&gt;, ## # duration &lt;dbl&gt;, payments &lt;dbl&gt;, status &lt;chr&gt;, n_trans &lt;int&gt; 2.10 Operacije nad mnoicami V tem poglavju si bomo ogledali operacije nad mnoicami. Te delujejo nad vektorji, prav tako pa nad data.frame oziroma nad tibbli. Poznamo 3 glavne operacije: Unija. Vrne vse elemente, ki se pojavijo v eni ali drugi mnoici. Presek. Vrne vse elemente, ki se pojavijo v obeh mnoicah. Razlika. Vrne vse elemente prve mnoice, ki se ne pojavijo v drugi mnoici. Poglejmo si uporabo teh operacij nad tibbli. df1 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id2&quot;), x = c(4, 6) ) df2 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id3&quot;), x = c(4, 52) ) df1 ## # A tibble: 2 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 df2 ## # A tibble: 2 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id3 52 union(df1, df2) ## # A tibble: 3 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 52 intersect(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 setdiff(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id2 6 setdiff(df2, df1) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id3 52 2.11 Ali elite izvedeti ve? Hadley Wickham je objavil znanstveni lanek na temo urejenih podatkov: https://vita.had.co.nz/papers/tidy-data.pdf, ki je vsekakor vreden branja. Za ve informacij o neurejenih podatkih in v katerih primerih so lahko celo bolj zaeljeni, predlagamo ta blog: https://simplystatistics.org/2016/02/17/non-tidy-data/. 2.12 Domaa naloga Spodaj imamo podatke o strokih za 4 osebe. Razpredelnica je v neurejeni obliki. Vaa naloga je, da jo pretvorite v urejeno obliko. podatki_o_stroskih &lt;- tibble( ime = c(&quot;Miha&quot;, &quot;Ana&quot;, &quot;Andrej&quot;, &quot;Maja&quot;), april_2019 = c(400, 200, 300, 350), maj_2019 = c(390, 250, 280, 400), april_2020 = c(410, 150, 500, 400), maj_2020 = c(300, 320, 550, 320) ) Reitev: ## # A tibble: 16 x 4 ## ime mesec leto strosek ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Miha april 2019 400 ## 2 Miha maj 2019 390 ## 3 Miha april 2020 410 ## 4 Miha maj 2020 300 ## 5 Ana april 2019 200 ## 6 Ana maj 2019 250 ## 7 Ana april 2020 150 ## 8 Ana maj 2020 320 ## 9 Andrej april 2019 300 ## 10 Andrej maj 2019 280 ## 11 Andrej april 2020 500 ## 12 Andrej maj 2020 550 ## 13 Maja april 2019 350 ## 14 Maja maj 2019 400 ## 15 Maja april 2020 400 ## 16 Maja maj 2020 320 V mapi data-raw se nahajajo podatki o predsednikih volitvah v ZDA. Najprej izberite samo podmnoico vrstic, kjer sta kandidata Joe Biden ali Donald Trump, in izloite stolpec party. Nato pretvorite podatke v iro obliko, tako da bo vsak izmed kandidatov imel svoj stolpec. ## # A tibble: 4,633 x 4 ## state county `Joe Biden` `Donald Trump` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Delaware Kent County 44518 40976 ## 2 Delaware New Castle County 194238 87685 ## 3 Delaware Sussex County 56657 71196 ## 4 District of Columbia District of Columbia 29509 1149 ## 5 District of Columbia Ward 2 24247 2365 ## 6 District of Columbia Ward 3 33584 2972 ## 7 District of Columbia Ward 4 35117 1467 ## 8 District of Columbia Ward 5 36585 1416 ## 9 District of Columbia Ward 6 44699 3360 ## 10 District of Columbia Ward 7 30253 885 ## # ... with 4,623 more rows Pri bannih podatkih smo zaenkrat delali samo s petimi razpredelnicami. Celotna zbirka je nekoliko veja, saj vsebuje e 3 razpredelnice. V mapi data-raw/financial-hw/ se nahajajo e preostale razpredelnice. Pri nalogi bomo uporabili razpredelnico district, ki vsebuje podatke o okrajih. Vsekakor pa se lahko za lastno vajo poigrate e s preostalima dvema. Vae naloge so: Preberite podatke o okrajih v R. Ugotovite, kaj je primarni klju te razpredelnice. Ustrezno dopolnite entitetni diagram. To lahko naredite rono, v kolikor pa se elite nauiti narediti bolj profesionalne diagrame pa predlagamo spletno orodje https://app.diagrams.net/. V mapi support-files se nahaja na diagram. Tega lahko enostavno naloite v to orodje in ga dopolnite. Poiite 3 pokrajine (A3) z najvejo povpreno vrednostjo posojil. ## # A tibble: 3 x 2 ## A3 mean_loan ## &lt;chr&gt; &lt;dbl&gt; ## 1 east Bohemia 165997. ## 2 south Bohemia 156236. ## 3 central Bohemia 155392. Teka naloga. Namestite paket nycflights13. Gre za relacijsko podatkovno zbirko o letih iz New Yorka v letu 2013. Naloite podatke z library(nycflights13). Uporabljali bomo tiri razpredelnice: flights, weather, airlines in planes. Vaa naloga je: Poizkusite najti primarni klju za razpredelnico flights. Ali gre za primarni klju lahko preverite tako, da preverite ali ta klju unikatno doloa vrstico v podatkih, torej da pretejete podatke, grupirane glede na ta klju. Klju je lahko sestavljen tudi iz veih spremenljivk. Na prvi pogled bi rekli, da je primarni klju tevilka leta, ampak temu ni tako (preverimo s tetjem). Ali je morda kakna druga kombinacija spremenljivk? Lahko da razpredelnica nima primarnega kljua. V tem primeru doloite nadomestni klju tako, da dodate stolpec ID z mutate(ID = row_number()). Ugotovite, kaj so primarni in kaj tuji kljui preostalih razpredelnic. Pri nekaterih razpredelnicah v tej zbirki bomo imeli sestavljene kljue, torej bodo kljui sestavljeni iz veih stolpcev. Namig: Pri vremenu je manja napaka v podatkih in se tudi primarni klju ponovi v zanemarljivem tevilu primerov. Vsekakor so napake v realnih podatkih priakovane in moramo na to biti pozorni! Nariite relacijski diagram. Ustvarite novo razpredelnico tako da razpredelnici flights dodate podrobnosti o lastnostih letal za vsak let. ## Error in library(nycflights13): there is no package called &#39;nycflights13&#39; ## Error in mutate(flights, ID = row_number()): object &#39;flights&#39; not found ## Error in left_join(flights, planes, by = &quot;tailnum&quot;): object &#39;flights&#39; not found ## Error in eval(expr, envir, enclos): object &#39;flights_plane&#39; not found Ustvarite novo razpredelnico tako da razpredelnici flights dodate podrobnosti o vremenu na letaliu vsak let. ## Error in left_join(flights, weather, by = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, : object &#39;flights&#39; not found ## Error in eval(expr, envir, enclos): object &#39;flights_weather&#39; not found Poiite vsa letala, ki so v New York priletela 5. aprila iz letalia Chicago Ohare Intl. ## Error in filter(airports, name == &quot;Chicago Ohare Intl&quot;): object &#39;airports&#39; not found ## Error in filter(., engines == 2, month == 4, day == 5): object &#39;flights_plane&#39; not found ## Error in eval(expr, envir, enclos): object &#39;planes_ORD&#39; not found Zelo teka naloga. V mapi data-raw se nahajajo podatki o kreditnih karticah v Tajvanu default of credit card clients.xlsx. Pridobili smo jih iz UCI Machine Learning repozitorija (Dua and Graff 2017). Podatki so bili uporabljeni v znanstveni raziskavi (Yeh and Lien 2009), kjer so napovedovali verjetnosti neplail v odvisnosti od preteklih transakcij na kartici in podatkov o lastnikih. Podatki so v xlsx datoteki. Bodite pozorni, da je prva vrstica datoteke nepomembna in se glava zane komaj v drugi vrstici. Trenutno so podatki v obliki, v kateri so zelo primerni kot vhodni podatek za kak model, na primer linearno regresijo. Vsekakor pa niso v primerni obliki za uinkotivo urejanje in hranjenje. Vaa naloga je, da podatke preberete v R in razpredelnico pretvorite v urejeno obliko. Predlagamo, da nalogo poizkusite reiti sami. Naloga zahteva precej razmisleka in tudi nekaj samostojne raziskave (na primer, kaj posamezni stolpci pomenijo  pomagate si lahko s spletno stranjo, iz katere smo prenesli podatke). V kolikor se vam zatakne, smo vam spodaj pripravili nekaj namigov: Najprej je potrebno razmisliti, kaj so spremenljivke. Na primer, ali sta PAY_1 in PAY_2 2 spremenljivki, ali predstavljata 1 spremenljivko, ki pa je razdeljena glede na neko drugo spremenljivko? Predlagamo da zanete ukaze tako, da razpredelnico spremenite v daljo obliko, kjer vse spremenljivke, ki se pojavijo v veih stolpcih, shranite v 1 stolpec. V novem stolpcu so celice sestavljene iz 2 spremenljivk. Ena od teh je ID meseca. Torej moramo ta stolpec loiti na 2 stolpca. Katero funkcijo uporabimo za to? Pri tem bo prav priel tudi argument te funkcije sep = -1, ki bo stolpec loil na zadnji znak v besedi in vse preostalo (na primer, beseda3 bo razdelil na beseda in 3). -1 predstavlja pri koliko znakih od konca proti zaetku naredimo loitev besede. V enem od teh dveh preostalih stolpcev imamo e vedno shranjene 3 spremenljivke, za katere bi bilo bolje, e so v 3 stolpcih. Ustrezno pretvorite tabelo. Na tej toki smo e skoraj pri koncu. ID mesecev al ne sovpada z zaporednimi tevili mesecev v letu. Predlagamo, da si ustvarite novo razpredelnico, ki bo mapirala ID mesecev v njihova zaporedna tevila. Potem pa to razpredelnico poveete z razpredelnico, kjer hranimo podatke. Kako naredimo to? Kadar zdruujemo razpredelnice moramo tudi biti pozorni na to, da so stolpci, ki jih zdruujemo, istega tipa. ## # A tibble: 180,000 x 10 ## ID LIMIT_BAL SEX EDUCATION MARRIAGE AGE MONTH PAY PAY_AMT BILL_AMT ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 20000 2 2 1 24 9 2 0 3913 ## 2 1 20000 2 2 1 24 8 2 689 3102 ## 3 1 20000 2 2 1 24 7 -1 0 689 ## 4 1 20000 2 2 1 24 6 -1 0 0 ## 5 1 20000 2 2 1 24 5 -2 0 0 ## 6 1 20000 2 2 1 24 4 -2 0 0 ## 7 2 120000 2 2 2 26 9 -1 0 2682 ## 8 2 120000 2 2 2 26 8 2 1000 1725 ## 9 2 120000 2 2 2 26 7 0 1000 2682 ## 10 2 120000 2 2 2 26 6 0 1000 3272 ## # ... with 179,990 more rows "],["nizi-kategori-ne-spremenljivke-in-datumi-osnutek.html", "Poglavje 3 Nizi, kategorine spremenljivke in datumi (OSNUTEK) 3.1 Nizi 3.2 Kategorine spremenljivke 3.3 Datumi in ure 3.4 Shranjevanje in branje podatkov", " Poglavje 3 Nizi, kategorine spremenljivke in datumi (OSNUTEK) Pogosto se pri delu s podatki sreamo s posebnimi podatkovnimi tipi, kot so nizi, kategorine spremenljivke in datumi. Z nizi smo e delali na prvi dveh predavanjih, ampak nad njimi nismo izvajali pretirano kompleksnih funkcij. Delali smo tudi s kategorinimi spremenljivkami, eprav se tega morda nismo zavedali. S temi podatkovnimi tipi lahko torej delamo z relativno malo znanja. Seveda pa za kvalitetno delo s podatki potrebujemo tudi orodja za bolj podrobno delo s taknimi tipi. V tem predavanju bomo spoznali kako delati s taknimi spremenljivkami v okviru zbirke tidyverse ter predstavili praktine primere, dobre prakse in pasti pri delu z njimi. 3.1 Nizi Poglavje o nizih. 3.2 Kategorine spremenljivke Kategorine spremenljivke so spremenljivke, ki lahko zavzamejo samo vnaprej doloene vrednosti. Delimo jih na: Nominalne spremenljivke. To so spremenljivke brez ureditve. Na primer, spol ali vrsta avtomobila. Ordinalne spremenljivke. To so spremenljivke, ki imajo smiselno ureditev. Na primer, stopnja izobrazbe ali olski uspeh. V R uporabljamo za delo s kategorinimi spremenljivkami t. i. faktorje (ang. factor). Ti se od spremenljivk tipa niz razlikujejo v tem, da se v spremenljivki hrani informacija o vseh monih vrednostih. Prav tako ni mogoe faktorju dodati vrednosti, ki je ni v mnoici monih vrednosti, kar slui kot varovalka pred napakami pri vnosu podatkov. Poglejmo si uporabo faktorja na dveh preprostih primerih, kjer bomo sami ustvarili spremenljivki. Kasneje si bomo ogledali e delo s faktorji na primeru realnih podatkov, kjer bomo ponovno uporabili podatke o zaposlitvah na podroju podatkovnih ved. Kot primer nominalne spremenljivke si oglejmo dneve v tednu. Obstaja 7 monih vrednosti. dan_v_tednu &lt;- c(&quot;torek&quot;, &quot;etrtek&quot;, &quot;nedelja&quot;, &quot;tork&quot;, &quot;sreda&quot;) Sedaj so dnevi v tednu shranjeni kot nizi. Kaj so slabosti taknega shranjevanja kategorinih podatkov? Prvi, nimamo nobenega varovala pred tipkarskimi napakami  R je etrti vnos prebral kot tork in ga tako tudi shranil: dan_v_tednu ## [1] &quot;torek&quot; &quot;etrtek&quot; &quot;nedelja&quot; &quot;tork&quot; &quot;sreda&quot; Drugi, e elimo razvrstiti to spremenljivko, razvranje ne bo smiselno, saj se bodo vrednosti razvrstile po abecedi: sort(dan_v_tednu) ## [1] &quot;etrtek&quot; &quot;nedelja&quot; &quot;sreda&quot; &quot;torek&quot; &quot;tork&quot; Da se izognemo tem teavam je bolje, e spremenljiko za katero vemo, da bo zasedla eno od vnaprej doloenih vrednosti, shranimo kot faktor. V R za to uporabimo funkcijo factor(). Poizkusimo sedaj narediti faktor iz spremenljivke dan_v_tednu. dan_v_tednu_fac &lt;- factor(dan_v_tednu) dan_v_tednu_fac ## [1] torek etrtek nedelja tork sreda ## Levels: etrtek nedelja sreda torek tork Opazimo, da je sedaj spremenljivka druganega tipa, saj hrani tudi informacijo o monih vrednostih oziroma ravneh (ang. levels). Ampak v tem primeru so te ravni napane (ne zajame vseh 7 dni v tednu, poleg tega pa vsebuje tudi eno napano vrednost). Funkcija factor() privzeto kot ravni nastavi vse vrednosti v podani spremenljivki. e elimo, ji lahko podamo dodaten argument levels, kjer rono doloimo, katere ravni bodo v spremenljivki. V kolikor to vemo vnaprej, je dobra praksa da podamo tudi ta argument. dan_v_tednu_fac &lt;- factor(dan_v_tednu, levels = c(&quot;ponedeljek&quot;, &quot;torek&quot;, &quot;sreda&quot;, &quot;etrtek&quot;, &quot;petek&quot;, &quot;sobota&quot;, &quot;nedelja&quot;)) dan_v_tednu_fac ## [1] torek etrtek nedelja &lt;NA&gt; sreda ## Levels: ponedeljek torek sreda etrtek petek sobota nedelja sort(dan_v_tednu_fac) ## [1] torek sreda etrtek nedelja ## Levels: ponedeljek torek sreda etrtek petek sobota nedelja Opazimo dvoje: sedaj lahko spremenljivko uredimo glede na dan v tednu in nesmiselne vrednosti se spremenijo v NA. Faktorju torej ne moremo prirediti vrednosti, ki ni enaka eni izmed vrednosti v ravneh. Da dostopamo do vseh ravni faktorja, uporabimo funkcijo levels(): levels(dan_v_tednu_fac) ## [1] &quot;ponedeljek&quot; &quot;torek&quot; &quot;sreda&quot; &quot;etrtek&quot; &quot;petek&quot; ## [6] &quot;sobota&quot; &quot;nedelja&quot; Vasih imajo kategorine spremenljivke tudi smiselno razvrstitev po velikosti, ki pa se obiajno ne da numerino izmeriti. Kot primer si poglejmo olski uspeh, ki lahko zavzame 5 vrednosti. V kolikor elimo, da faktor hrani tudi informacijo o tem, da obstaja smiselna razvrstitev po velikosti, dodamo argument ordered = TRUE. uspeh &lt;- factor(c(&quot;odlino&quot;, &quot;dobro&quot;, &quot;dobro&quot;, &quot;prav dobro&quot;), levels = c(&quot;nezadostno&quot;, &quot;zadostno&quot;, &quot;dobro&quot;, &quot;prav dobro&quot;, &quot;odlino&quot;), ordered = TRUE) uspeh ## [1] odlino dobro dobro prav dobro ## Levels: nezadostno &lt; zadostno &lt; dobro &lt; prav dobro &lt; odlino Opazimo, da imamo sedaj pri izpisu nivojev dodatno informacijo o razvrstitvi uspeha. V praksi nam to omogoa primerjamo, medtem ko tega pri faktorjih, ki nimajo razvrstitve po velikosti, ne moremo narediti. uspeh[2] &gt; uspeh[1] ## [1] FALSE dan_v_tednu_fac[2] &gt; dan_v_tednu[1] ## Warning in Ops.factor(dan_v_tednu_fac[2], dan_v_tednu[1]): &#39;&gt;&#39; not meaningful ## for factors ## [1] NA Poleg prednosti, ki smo jih e omenili (varovanje pred napakami in smiselna razvrstitev nivojev) imajo faktorji tudi posebno vlogo pri raznih statistinih modelih in modelih strojnega uenja. Nekatere metode eksplicitno zahtevajo faktorje. Prav tako razlikujejo med nominalnimi in ordinalnimi faktorji, kar se pozna na rezultatih. Relativno preprost primer tega je linearna regresija, ki pa je izven obsega te delavnice. Vsekakor pa si je to vredno zapomniti, v kolikor se boste kdaj ukvajrali s podobnimi modeli in boste eleli uporabiti kategorine spremenljivke. Poglejmo si uporabo faktorjev na realni podatkovni mnoici. Ponovno bomo delali s podatki o zaposlitvah na podroju podatkovnih ved. Preberimo podatke in ponovimo nekaj operacij, ki smo jih spoznali na prvem predavanju. Prav tako bomo izbrali samo podmnoico stolpcev za bolj jasen prikaz. library(tidyverse) ds_jobs &lt;- read_csv2(&quot;./data-raw/DS-jobs.csv&quot;) %&gt;% select(Country, Age, EmploymentStatus, FormalEducation, CompensationAmount, ExchangeRate) %&gt;% filter(!is.na(ExchangeRate)) %&gt;% mutate(CompensationUSD = CompensationAmount * ExchangeRate) %&gt;% filter(CompensationUSD &lt;= 2500000, CompensationUSD &gt;= 10000) ds_jobs ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; Imamo dve spremenljivki, ki bi jih bilo smiselno shraniti kot faktorje  EmploymentStatus in FormalEducation. Pretvorimo sedaj ti spremenljivki v faktorje. Pri tem pustimo kar privzeto nastavitev, da se kot nivoji uporabijo vse vrednosti v stolpcih. library(tidyverse) ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = factor(EmploymentStatus), FormalEducation = factor(FormalEducation)) ds_jobs ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; levels(ds_jobs$EmploymentStatus) ## [1] &quot;Employed full-time&quot; ## [2] &quot;Employed part-time&quot; ## [3] &quot;Independent contractor, freelancer, or self-employed&quot; levels(ds_jobs$FormalEducation) ## [1] &quot;Bachelor&#39;s degree&quot; ## [2] &quot;Doctoral degree&quot; ## [3] &quot;I did not complete any formal education past high school&quot; ## [4] &quot;I prefer not to answer&quot; ## [5] &quot;Master&#39;s degree&quot; ## [6] &quot;Professional degree&quot; ## [7] &quot;Some college/university study without earning a bachelor&#39;s degree&quot; 3.2.1 Sprememba razvrstitve faktorja Kot smo omenili e pri dnevih v tednu imajo velikokrat tudi faktorji, ki niso razvreni po velikosti, neko smiselno razvrstitev. Razvrstitev pa lahko tudi kasneje spremenimo. Ta operacija je obiajno uporabna pri vizualizaciji. Poglejmo si, na primer, kako so plae povezane z izobrazbo. Za vizualizacijo rezultatov bomo uporabili razsevni diagram: ds_jobs_agg &lt;- ds_jobs %&gt;% group_by(FormalEducation) %&gt;% summarise(MeanCompensationUSD = mean(CompensationUSD)) ds_jobs_agg ## # A tibble: 8 x 2 ## FormalEducation MeanCompensationU~ ## &lt;fct&gt; &lt;dbl&gt; ## 1 Bachelor&#39;s degree 71665. ## 2 Doctoral degree 90856. ## 3 I did not complete any formal education past high school 78470. ## 4 I prefer not to answer 90023. ## 5 Master&#39;s degree 78411. ## 6 Professional degree 64614. ## 7 Some college/university study without earning a bachelor&#39;s~ 105675. ## 8 &lt;NA&gt; 47833. ggplot(ds_jobs_agg, aes(x = FormalEducation, y = MeanCompensationUSD)) + geom_point() + coord_flip() Ta graf je sicer zelo informativen, ampak bi s teavo hitro ugotovili, kako so nivoji faktorja razvreni glede na plao. ggplot razvrsti vrednosti glede na to, kako so razvrene v faktorju: levels(ds_jobs$FormalEducation) ## [1] &quot;Bachelor&#39;s degree&quot; ## [2] &quot;Doctoral degree&quot; ## [3] &quot;I did not complete any formal education past high school&quot; ## [4] &quot;I prefer not to answer&quot; ## [5] &quot;Master&#39;s degree&quot; ## [6] &quot;Professional degree&quot; ## [7] &quot;Some college/university study without earning a bachelor&#39;s degree&quot; Morda bi bilo bolje tak graf urediti glede na vrednosti spremenljivke MeanCompensationUSD. Za to moramo doloiti novo razvrstitev te spremenljivke. Za to obstaja v paketu forcats, ki je del tidyverse, funkcija fct_reorder(). ggplot(ds_jobs_agg, aes(x = fct_reorder(FormalEducation, MeanCompensationUSD), y = MeanCompensationUSD)) + geom_point() + coord_flip() Razvrstitev lahko uredimo tudi rono s funkicjo fct_relevel(). 3.2.2 Preimenivanje obstojeih in doloanje novih nivojev Nivoje faktorjev lahko preimenujemo s funkcijo fct_recode(). ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = fct_recode(EmploymentStatus, &quot;full-time&quot; = &quot;Employed full-time&quot;, &quot;part-time&quot; = &quot;Employed part-time&quot;, &quot;other&quot; = &quot;Independent contractor, freelancer, or self-employed&quot;)) head(ds_jobs$EmploymentStatus) ## [1] full-time full-time full-time part-time full-time full-time ## Levels: full-time part-time other e elimo dodati nov nivo uporabimo funckcijo fct_expand(). ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = fct_expand(EmploymentStatus, &quot;trainee&quot;)) levels(ds_jobs$EmploymentStatus) ## [1] &quot;full-time&quot; &quot;part-time&quot; &quot;other&quot; &quot;trainee&quot; 3.2.3 Razbitje numerine spremenljivke na intervale Velikokrat elimo kakno numerino spremenljivko segmentirati na doloene intervale. Na primer, pri doloanju avtomobilskih zavarovalnih premij lahko zavarovance segmentiramo glede na starost. V R za to uporabimo funkcijo cut(). Razdelimo spremenljivko Age na intervale, kjer bodo osebe razdeljene do 25 let, nad 25 in to 35 let, nad 35 do 50 let, in nad 50 let. ds_jobs &lt;- ds_jobs %&gt;% mutate(AgeInterval = cut(Age, breaks = c(0, 25, 35, 50, 100))) ds_jobs_agg &lt;- ds_jobs %&gt;% group_by(AgeInterval) %&gt;% summarise(CompensationByAge = mean(CompensationUSD)) ggplot(ds_jobs_agg, aes(x = AgeInterval, y = CompensationByAge)) + geom_point() 3.3 Datumi in ure Delo z datumi in urami morda na prvi pogled deluje precej enostavno. Vendar pa zaradi razlinih fizikalnih zakonitosti ali lovekih konstruktov lahko pride do teav. Na primer, vsako leto nima 365 dni. Prav tako v nekaterih asovnih conah 3. ura zjutraj ne sledi vedno 2. uri, saj pride do premika ure. Za delo z datumi bomo uporabljali paket lubridate. Glavni komponenti v tem paketu sta datum (date) in as (time), ter zdruena komponenta datum in as (and. datetime) S tem paketom lahko datume ustvarimo na 2 naina: Z nizom: library(lubridate) ymd(&quot;2021-04-02&quot;) ## [1] &quot;2021-04-02&quot; ymd(&quot;2021/04/02&quot;) ## [1] &quot;2021-04-02&quot; ymd(20210402) ## [1] &quot;2021-04-02&quot; dmy(&quot;02.04.2021&quot;) ## [1] &quot;2021-04-02&quot; ymd_hms(&quot;2021-04-02 12:01:00&quot;) # Tipa datetime. ## [1] &quot;2021-04-02 12:01:00 UTC&quot; ymd(20210402, 20210403) ## [1] &quot;2021-04-02&quot; &quot;2021-04-03&quot; S posameznimi komponentami: make_date(2021, 4, 2) ## [1] &quot;2021-04-02&quot; make_datetime(2021, 4, 2, 12, 1, 0) ## [1] &quot;2021-04-02 12:01:00 UTC&quot; Opazimo, da pri datumu in asu spremenljivka hrani tudi informacijo o asovnem pasu. Privzeto lubridate dela s asovnim pasom UTC (Coordinated Universal Time), ki je naslednik GMT (Greenwich Mean Time). Prednost tega asovnega pasu je predvsem v tem, da se ne prilagaja spremembi ure v pomladnih in jesenskih mesecih. Te spremembe lahko privedejo do napak pri raunanju z datumi in asi, tako da je raunanje v UTC bolj varno. Seveda pa lahko rono nastavimo drugi asovni pas z argumentom tz. Paket lubridate uporablja IANA asovne pasove (https://www.iana.org/time-zones), kateri so definirani s kombinacijo celine in drave. Na primer, za Ljubljano bi asovni pas nastavili tako: ymd_hms(&quot;2021-04-02 12:01:00&quot;, tz = &quot;Europe/Ljubljana&quot;) ## [1] &quot;2021-04-02 12:01:00 CEST&quot; Pomembno je torej, da vemo, v katerem asovnem pasu so bile opravljene meritve v naih podatkih, da lahko potem ustrezno pretvorimo spremenljivko v asovno. Seveda pa lahko tudi pretvarjamo asovne spremenljivke med asovnimi pasovi. Za to uporabimo funkcijo with_tz(). Vsakemu asu v doloenem asovnem pasu lahko priredimo nek as v drugem asovnem pasu. V kolikor elimo bolj robustno raunati z datumi in urami, potem lahko vedno datume pretvorimo v UTC as, naredimo izraune in potem pretvorimo nazaj v lokalni asovni pas. my_datetime &lt;- ymd_hms(&quot;2021-04-02 12:01:00&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime ## [1] &quot;2021-04-02 12:01:00 CEST&quot; my_datetime_UTC &lt;- with_tz(my_datetime, tz = &quot;UTC&quot;) V R je asovni pas namenjen samo izpisu datumov in asov. Sama vrednost spremenljivke ostane nespremenjena. To lahko preverimo tako, da odtejemo en datum od drugega, kar nam vrne razliko v asu: my_datetime - my_datetime_UTC ## Time difference of 0 secs V kolikor smo narobe prebrali datum v zaetku (na primer, v podatkih je bil datum v UTC, prebrali pa smo v lokalnem asu) zgornja pretvorba med asovnimi pasovi ni ustrezna, saj bomo s tem zajeli napaen as. V tem primeru moramo uporabiti funkcijo force_tz(). Predlagamo, da udeleenci sami poizkusijo, kaj naredi ta funkcija, tako da z njo pretvorijo my_datetime v UTC in potem izraunajo razliko, podobno kot smo to naredili zgoraj. Kadar delamo sekvence datumov in asov te upotevajo premik ure. datetime_dst &lt;- seq(ymd_hms(&quot;2011-10-30 00:00:00&quot;, tz = &quot;Europe/Ljubljana&quot;), ymd_hms(&quot;2011-10-30 04:00:00&quot;, tz = &quot;Europe/Ljubljana&quot;), by = &quot;30 min&quot;) datetime_dst ## [1] &quot;2011-10-30 00:00:00 CEST&quot; &quot;2011-10-30 00:30:00 CEST&quot; ## [3] &quot;2011-10-30 01:00:00 CEST&quot; &quot;2011-10-30 01:30:00 CEST&quot; ## [5] &quot;2011-10-30 02:00:00 CEST&quot; &quot;2011-10-30 02:30:00 CEST&quot; ## [7] &quot;2011-10-30 02:00:00 CET&quot; &quot;2011-10-30 02:30:00 CET&quot; ## [9] &quot;2011-10-30 03:00:00 CET&quot; &quot;2011-10-30 03:30:00 CET&quot; ## [11] &quot;2011-10-30 04:00:00 CET&quot; with_tz(datetime_dst, tz = &quot;UTC&quot;) ## [1] &quot;2011-10-29 22:00:00 UTC&quot; &quot;2011-10-29 22:30:00 UTC&quot; ## [3] &quot;2011-10-29 23:00:00 UTC&quot; &quot;2011-10-29 23:30:00 UTC&quot; ## [5] &quot;2011-10-30 00:00:00 UTC&quot; &quot;2011-10-30 00:30:00 UTC&quot; ## [7] &quot;2011-10-30 01:00:00 UTC&quot; &quot;2011-10-30 01:30:00 UTC&quot; ## [9] &quot;2011-10-30 02:00:00 UTC&quot; &quot;2011-10-30 02:30:00 UTC&quot; ## [11] &quot;2011-10-30 03:00:00 UTC&quot; Pozorni moramo biti tudi na kombiniranje datumov. V kolikor uporabimo funkcijo c(), ta obiajno privzeto nastavi asovni pas prvega podanega elementa. Vsekakor pa je to odvisno. TODO: Ali je to res? Ker dobim drugane rezultate kot pa so v knjigi. 3.3.1 Raunanje z datumi in asi Vsaka asovna spremenljivka, ki vsebuje datum in as, je sestavljena iz komponent. Te so leto, mesec, dan, ura, minuta in sekunda. Za dostop do posameznih komponent imamo na voljo ve funkcij: year() month() mday(). Dan v mesecu. wday(). Dan v tednu. Privzeto se zane z nedeljo. To lahko spremenimo z argumentom week_start. hour() minute() second() Poglejmo sedaj kaj vraajo te funkcije: x &lt;- now() x ## [1] &quot;2021-06-09 10:21:25 CEST&quot; year(x) ## [1] 2021 month(x) ## [1] 6 mday(x) ## [1] 9 wday(x) ## [1] 4 wday(x, week_start = 1) ## [1] 3 hour(x) ## [1] 10 minute(x) ## [1] 21 second(x) ## [1] 25.14696 S komponentami lahko tudi spreminjamo dele asovne spremenljivke: mday(x) &lt;- 5 x ## [1] &quot;2021-06-05 10:21:25 CEST&quot; Pri raunanju s asovnimi enotami v lubridate poznamo tri razrede: trajanja (ang. duration). as v sekundah. Funkcije dseconds(), dminutes(), ddays(), dweeks() in dyears(). Pri trajanjih se vedno uporabi pretvorba, da ima vsak dan 24 ur in vsako leto 365.25 dni. Slednje predstavlja povpreno teilo dni v letu. Tako da bo funkcija dyears(4) vedno vrnila tevilo sekund, ki ustreza 4x365.25 dnem, ki imajo vsak po 24 ur. periode (ang. period). as v lovekih enotah kot je na primer teden. Funkcije seconds(), minutes(), days(), weeks(), months() in years(). intervali (ang. interval). asovni interval med dvema tokama. Pozoren bralec je morda opazil, da pri trajanjih nismo navedli funkcije za mesece. To je zaradi tega, ker imajo meseci lahko 28, 29, 30 ali 31 dni. Vsekakor bi pri izbiri osnovne enote za trajanja prilo do neke arbitrarne odloitve, koliko dni vzamemo privzeto. 30 ali 31? V vsakem primeru bo vsaj polovica mesecev imela napano trajanje. Pri dnevih in letih si laje privoimo posploitev. ddays(1) ## [1] &quot;86400s (~1 days)&quot; days(1) ## [1] &quot;1d 0H 0M 0S&quot; Poglejmo si preprost primer, kako dodati my_datetime &lt;- ymd_hms(&quot;2021/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + dminutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + minutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + months(2) ## [1] &quot;2021-08-08 11:05:30 CEST&quot; Trajanja in periode so si oitno zelo podobni ampak imajo eno veliko razliko, kadar raunamo z dnevi, tedni in leti. Prvi, kadar bomo uporabljali dyears() lahko hitro pride do teave, saj bomo priteli 0.25 dneva. Poglejmo si to na primeru: my_datetime + years(1) ## [1] &quot;2022-06-08 11:05:30 CEST&quot; my_datetime + dyears(1) ## [1] &quot;2022-06-08 17:05:30 CEST&quot; Opazimo, da smo priteli 6 dodatnih ur. Drugi, kaj se zgodi, kadar pritejemo teden ali dan v asu, ko pride do premika ure. Premik ure se je po lokalnem asu zgodil 28. 3. 2021 ob 2 zjutraj. my_datetime &lt;- ymd_hms(&quot;2021/03/27 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-03-28 12:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-03-28 11:05:30 CEST&quot; my_datetime + dweeks(1) ## [1] &quot;2021-04-03 12:05:30 CEST&quot; my_datetime + weeks(1) ## [1] &quot;2021-04-03 11:05:30 CEST&quot; Funkcija years() deluje kot bi priakovali tudi na prestopnem letu: my_datetime &lt;- ymd_hms(&quot;2020/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + years(1) ## [1] &quot;2021-06-08 11:05:30 CEST&quot; S funkcijami trajanja in period lahko tudi raunamo, na primer: dyears(2) + ddays(4) + dseconds(20) ## [1] &quot;63460820s (~2.01 years)&quot; days(2) + minutes(20) + seconds(120) ## [1] &quot;2d 0H 20M 120S&quot; 5 * dminutes(20) ## [1] &quot;6000s (~1.67 hours)&quot; 5 * minutes(20) ## [1] &quot;100M 0S&quot; Najbolje, da jo prikaemo na dveh primerih  premik ure in prestopno leto. Periode so bolj naraven prikaz za loveka. my_datetime &lt;- ymd_hms(&quot;2021/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + dminutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + minutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + dyears(1) ## [1] &quot;2022-06-08 17:05:30 CEST&quot; my_datetime + years(1) ## [1] &quot;2022-06-08 11:05:30 CEST&quot; my_datetime + months(2) ## [1] &quot;2021-08-08 11:05:30 CEST&quot; 3.4 Shranjevanje in branje podatkov 3.4.1 Delo z binarnimi datotekami V programskem jeziku R lahko shranjujemo in nalagamo (v trenutno sejo R) spremenljivke kot binarne objekte na dva prevladujoa naina: S kombinacijo funkcij save() in load(). S kombinacijo funkcij saveRDS() in readRDS(). Pomembna razlika med prvim in drugim pristopom je, da lahko s prvim shranimo ve spremenljivk naenkrat, z drugim pa samo eno. Na prvi pogled bi torej priakovali, da je prvi pristop bolji, oziroma bolj zaelen. Ampak ima eno pomembno slabost, zaradi katere predlagamo uporabo drugega pristopa. Funkcija save() shrani spremenljivke v trenutni seji R v datoteko s konnico rda ali RData. To naredi tako, da shrani tako vrednost spremenljivke kot tudi ime spremenljivke. To pomeni, da ko bomo takno datoteko prebrali v novo sejo R, bomo ustvarili spremenljivke z enakimi imeni, kot smo jih shranili. Pri tem pa lahko pride do teav. Recimo, da imamo v trenutni seji R e nek nabor spremenljivk nato pa elimo vanjo prenesti e neke druge spremenljivke, ki smo jih pred asom shranili s funkcijo save() v datoteko saved-data.rda. Kaj se bo zgodilo, e bo katera od spremenljivk v nai trenutni seji imela enako ime kot ena od spremenljivk shranjenih v saved-data.rda? R bo enostavno to spremenljivko prepisal s spremenljivko, ki se je nahajala v tej rda datoteki. Taken postopek dela je lahko torej nevaren, saj lahko nevede izbriemo obstojee spremenljivke. Predlagamo torej uporabo druge kombinacije, torej funkcij saveRDS() in readRDS(). Funkcija saveRDS() shrani samo vrednost spremenljivke, ne pa tudi njenega imena, tako da ne pride do podobnih teav kot pri prvem pristopu. Konnica tako shranjenih datotek je rds. Poglejmo si uporabo teh funkcij. x &lt;- c(3, 6, 3, 7) x ## [1] 3 6 3 7 saveRDS(x, &quot;./my-saved-files/my-x.rds&quot;) x2 &lt;- readRDS(&quot;./my-saved-files/my-x.rds&quot;) x2 ## [1] 3 6 3 7 Vedno ko preberemo podatke v sejo R s funkcijo readRDS() ji moramo prirediti ime, saj je v rds datoteki shrnajena samo njena vrednost. S tem se tudi izognemo podobnim teavam kot pri funkcijah save() in load(). Pomanjkljivost shranjevanja rds datotek pa je v tem, da lahko naenkrat shranimo samo 1 spremenljivko. Ampak to pomanjkljivost lahko zaobidemo, tako da ve spremenljivk enostavno shranimov v seznam (list()). Poglejmo si sedaj na primer, kako bi shranili ve spremenljivk. tmp_list &lt;- list( &quot;x&quot; = x, &quot;some_datetime&quot; = my_datetime, &quot;ds_jobs&quot; = ds_jobs ) saveRDS(tmp_list, &quot;./my-saved-files/my-list.rds&quot;) read_list &lt;- readRDS(&quot;./my-saved-files/my-list.rds&quot;) names(read_list) ## [1] &quot;x&quot; &quot;some_datetime&quot; &quot;ds_jobs&quot; x2 &lt;- read_list[[&quot;x&quot;]] x2 ## [1] 3 6 3 7 my_datetime2 &lt;- read_list[[&quot;some_datetime&quot;]] my_datetime2 ## [1] &quot;2021-06-08 11:05:30 CEST&quot; ds_jobs2 &lt;- read_list[[&quot;ds_jobs&quot;]] ds_jobs2 ## # A tibble: 3,186 x 8 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 full-time Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 full-time Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 full-time Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 part-time Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 full-time Doctoral degree 100000 1 ## 6 Russia 22 full-time Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 full-time Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 other I did not comp~ 150000 1.20 ## 9 Poland 29 full-time Master&#39;s degree 126000 0.281 ## 10 United ~ 35 full-time Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 2 more variables: CompensationUSD &lt;dbl&gt;, ## # AgeInterval &lt;fct&gt; 3.4.2 Branje in shranjevanje z ostalimi datotekami "],["reference.html", "Reference", " Reference "]]
