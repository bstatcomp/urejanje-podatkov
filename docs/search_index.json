[["index.html", "Urejanje podatkov Uvod Struktura te knjige Stil programske kode", " Urejanje podatkov Gregor Pir, Matej Piulin in Erik trumbelj 2021-06-11 Uvod Pri delu s podatki se sreujemo z razlinimi izzivi. Prvi izziv je zbiranje do podatkov. Takoj za tem pa se sooimo z drugim izzivom, ki obiajno zahteva najve naega asa  ienje in urejanje podatkov. V veini primerov so podatki v izvorni obliki namre neurejeni (ang. messy data). Ta knjiga je namenjena spoznanju osnovnih konceptov ienja in urejanja podatkov, ki nam bodo olajali nadaljnjo analizo in vizualizacijo. Vse koncepte bomo prikazali v programskem jeziku R. Podatkovne mnoice in izvorne datoteke te knjige so objavljene na Github repozitoriju. Cilj delavnice je spoznati: Najbolj uporabne funkcije za urejanje podatkov; Koncept t. i. urejenih (ang. tidy) podatkov; Dobre prakse dela z datumi, nizi in kategorinimi spremenljivkami. Za sistematino delo s podatki v R-ju je bil razvit skupek paketov, ki se imenuje tidyverse. Sestavljen je iz 8 temeljnih paketov: ggplot2. Vizualizacija podatkov s slovnico grafike (ang. grammar of graphics). dplyr. Laje urejanje podatkov, na primer izbiranje vrstic in stolpcev, dodajanje stolpcev, povzemanje in urejanje podatkov. Ta paket je glavna tema 1. predavanja. tidyr. Preoblikovanje podatkov med dolgo in iroko obliko, oziroma preoblikovanje podatkov v urejeno obliko. Ve o tem bomo povedali na 2. predavanju. readr. Uinkovito branje in shranjevanje podatkov. purrr. Funkcijsko programiranje v R. tibble. Moderna verzija data.frame. Tema 1. predavanja. stringr. Preprosteje delo z nizi. Tema 3. predavanja. forcats. Preprosteje delo s kategorinimi spremenljivkami. Tema 3. predavanja. Vseh 8 paketov lahko namestimo z enim ukazom: install.packages(&quot;tidyverse&quot;) Lahko pa namestimo tudi samo posamezne pakete: install.packages(&quot;dplyr&quot;) Struktura te knjige Vsako poglavje ima 3 sklope: Priprava. Ta sklop je namenjen temu, da se udeleenci pripravijo na predavanje. Ker bodo le-ta intenzivna in namenjena predstavitvi glavnih konceptov ter uporabi funkcij na praktinih primerih, je dobro, da poznamo osnovne klice uporabljenih funkcij. V pripravi si bomo na preprostih podatkih pogledali, kako izvajati osnovne klice funkcij v tidyverse. Za vsako pripravo je na voljo video. Priprava traja najve 30 minut. Jedro. V tem sklopu je zajeta vsebina posameznega predavanja in vasih dodatna snov, ki jo predelamo samostojno. Podrobneje opiemo posamezne koncepte in funkcije ter demonstriramo na praktinih primerih. Domaa naloga. Na koncu vsakega predavanja so vaje za utrjevanje. Poskusimo jih reiti sami. V tej knjigi bodo prikazani samo rezultati reitev brez postopka oziroma programske kode. V kolikor se nam zatakne, lahko preverimo reitev v izvornih datotekah Rmd, ki se nahajajo na repozitoriju. Nekatere naloge od nas zahtevaj, da kaj raziemo sami, z uporabo vgrajene pomoi ali spleta, kot smo to navajeni pri vsakodnevnem programerskem delu. Domaa naloga vsakega sklopa je sestavljena iz nekaj osnovnih nalog, ki ponovijo snov predavanj. Poleg teh pa so tudi teje naloge, pri kateri je potrebno koncepte uporabiti na realni podatkovni mnoici ali samostojno reiti probleme, ki jih na predavanju ne bomo predelali. Stil programske kode V tej knjigi bomo predelali potrebne koncepte za urejanje podatkov, kar nam bo omogoilo bolj kvalitetno in uinkovito delo s podatki. Poleg poznavanja teh orodij in konceptov pa nam analizo olaja tudi konsistenten stil programiranja. Dober stil programiranja za nae delo ni nujen, je pa vsekakor dobrodoel, saj je programska koda bolj berljiva. Zbirka paketov tidyverse ima tudi svoj stilski vodnik. Vsak stilski vodnik vsebuje pravila, ki so doloena dokaj arbitrarno, oziroma glede na preference avtorja. Najbolj pomembno je, da smo pri pisanju programske kode konsistentni in stilski vodnik nam to nudi. "],["slovnica-ravnanja-s-podatki.html", "Poglavje 1 Slovnica ravnanja s podatki 1.1 Priprava 1.2 Sodobna razpredelnica: tibble 1.3 Urejeno ovrednotenje 1.4 Izbira vrstic s filter() 1.5 Izbira stolpcev s select() 1.6 Urejanje vrstic z arrange() 1.7 Dodajanje novih spremenljivk z mutate() 1.8 Povzemanje vrednosti s summarise() 1.9 Pipe 1.10 filter() in mutate() na zdruenih podatkih 1.11 Izvajanje operacij nad veimi stolpci z across() 1.12 Povzemanje stolpcev 1.13 Povzemanje vrstic 1.14 Dodatek 1.15 Ali elite izvedeti ve? 1.16 Domaa naloga", " Poglavje 1 Slovnica ravnanja s podatki Pri sistematinem delu s podatki je zelo pomembna berljivost in preglednost programske kode. Pri delu velikokrat delimo svojo programsko kodo z drugimi strokovnjaki, zato je zaeljeno, da je koda pregledna in razumljiva. Lahko se tudi zgodi, da imamo teave z razumevanjem svoje stareje kode. Zaradi tega je smiselno, da stremimo k imveji konsistentnosti in preglednosti. Na dolgi rok s tem prihranimo as  s konsistentno uporabo enakih ukazov postanemo bolj uinkoviti, prav tako pa laje prenesemo programsko kodo iz enega problema na drugega. Naa programska koda je s tem bolj robustna in ponovljiva, kar je pomembno iz vidika iskanja napak v analizah. Dober primer konsistentnosti in razumljivosti za sporazumevanje je naraven jezik  v kolikor dve osebi govorita enak jezik se bosta brez teav sporazumevali. Lahko si predstavljate, da ne boste imeli teav z razumevanjem teksta v slovenini, e se bo avtor dral slovninih in pravopisnih pravil. Tako kot se pri naravnem jeziku drimo doloenih pravil, lahko podobno doseemo tudi s programskim jezikom. V tem predavanju se bomo osredotoili na temeljne operacije, ki jih izvajamo nad podatki. Te operacije so nepogreljive pri vsaki analizi: izbira podmnoice vrstic, izbira podmnoice stolpcev, dodajanje stolpcev, ki so lahko izpeljani iz obstojeih stolpcev, urejanje razpredelnice glede na vrednosti stolpcev, povzemanje razpredelnic, na primer povpreja in vsote. Paket dplyr vsebuje funkcije, ki nam v primerjavi z osnovno razliico R-ja, te operacije olajajo. Temelji na t. i. slovnici ravnanja s podatki (ang. grammar of data manipulation), ki programsko kodo pretvori v nekaj podobnega naravnemu jeziku. Pri slovnici ravnanja s podatki poznamo 5 osnovnih glagolov, s katerimi preoblikujemo podatke. Vsak glagol ustreza eni izmed temeljnih operacij, ki smo jih omenili zgoraj. Programska koda se potem bere podobno kot naravni jezik  glagoli programskemu jeziku povedo, kaj naj s podatki naredi. Ti glagoli so implementirani v obliki funkcij: filter() Izbira podmnoice vrstic glede na izbrane pogoje. select() Izbira podmnoice stolpcev, glede na imena stolpcev. mutate() Dodajanje stolpcev, ki so lahko izpeljani iz obstojeih stolpcev. summarise() Povzemanje podatkov v razpredelnici. arrange() Urejanje razpredelnice. V tem predavanju bomo bolj podrobno spoznali vsakega izmed teh glagolov. Po tem pa si bomo ogledali e dva uporabna povzetka  povzemanje po vrsticah in povzemanje po stolpcih. .fold-btn { float: right; margin: 5px 5px 0 0; } .fold { border: 1px solid black; min-height: 40px; } 1.1 Priprava V pripravi se bomo nauili osnovnih klicev petih glagolov iz slovnice ravnanja s podatki. Hkrati bomo primerjali osnovno razliico R-ja z uporabo paketa dplyr. Pripravimo podatke: library(tidyverse) # Nalozimo celotno zbirko paketov tidyverse. df &lt;- data.frame( ime = c(&quot;Maja&quot;, &quot;Ales&quot;, &quot;Tom&quot;, &quot;Barbara&quot;, &quot;Simon&quot;, &quot;Tina&quot;), spol = c(&quot;z&quot;, &quot;m&quot;, &quot;m&quot;, &quot;z&quot;, &quot;m&quot;, &quot;z&quot;), starost = c(23, 54, 21, 35, 53, 21), visina = c(170, 180, 192, 168, 177, 182) ) S funkcijo filter() izberemo podmnoico vrstic v razpredelnici glede na izbrane pogoje. Izberimo enske nije od 180 centimetrov. # Osnovni R: df[df$spol == &quot;z&quot; &amp; df$visina &lt; 180, ] ## ime spol starost visina ## 1 Maja z 23 170 ## 4 Barbara z 35 168 # dplyr: filter(df, spol == &quot;z&quot;, visina &lt; 180) ## ime spol starost visina ## 1 Maja z 23 170 ## 2 Barbara z 35 168 Opazimo, da z uporabo dplyr ni potrebno vsaki pisati df$ pred imenom spremenljivke. Tukaj gre za t. i. maskiranje podatkov (ang. data masking). Ve o tem v jedru poglavja. S funkcijo select() izberemo podmnoico stolpcev. Izberimo stolpce ime, spol in visina: # Osnovni R: df[ , c(&quot;ime&quot;, &quot;spol&quot;, &quot;visina&quot;)] ## ime spol visina ## 1 Maja z 170 ## 2 Ales m 180 ## 3 Tom m 192 ## 4 Barbara z 168 ## 5 Simon m 177 ## 6 Tina z 182 # dplyr: select(df, ime, spol, visina) ## ime spol visina ## 1 Maja z 170 ## 2 Ales m 180 ## 3 Tom m 192 ## 4 Barbara z 168 ## 5 Simon m 177 ## 6 Tina z 182 Opazimo, da nam pri uporabi dplyr stolpcev ni potrebno pisati v narekovajih. Tukaj gre za t. i. urejeno izbiranje (ang. tidy selection). Ve o tem v jedru poglavja. S funkcijo mutate() dodajamo stolpce. Dodajmo viino v metrih: # Osnovni R: df2 &lt;- df df2$visina_v_metrih &lt;- df2$visina / 100 df2 ## ime spol starost visina visina_v_metrih ## 1 Maja z 23 170 1.70 ## 2 Ales m 54 180 1.80 ## 3 Tom m 21 192 1.92 ## 4 Barbara z 35 168 1.68 ## 5 Simon m 53 177 1.77 ## 6 Tina z 21 182 1.82 # dplyr: mutate(df, visina_v_metrih = visina / 100) ## ime spol starost visina visina_v_metrih ## 1 Maja z 23 170 1.70 ## 2 Ales m 54 180 1.80 ## 3 Tom m 21 192 1.92 ## 4 Barbara z 35 168 1.68 ## 5 Simon m 53 177 1.77 ## 6 Tina z 21 182 1.82 S funkcijo arrange() urejamo razpredelnico. Uredimo osebe po starosti: # Osnovni R: df[order(df$starost), ] ## ime spol starost visina ## 3 Tom m 21 192 ## 6 Tina z 21 182 ## 1 Maja z 23 170 ## 4 Barbara z 35 168 ## 5 Simon m 53 177 ## 2 Ales m 54 180 # dplyr: arrange(df, starost) ## ime spol starost visina ## 1 Tom m 21 192 ## 2 Tina z 21 182 ## 3 Maja z 23 170 ## 4 Barbara z 35 168 ## 5 Simon m 53 177 ## 6 Ales m 54 180 S funkcijo summarise() povzamemo podatke. Obiajno se uporablja v kombinaciji z group_by(). Izraunajmo povpreno viino glede na spol: # Osnovni R: aggregate(visina ~ spol, data = df, FUN = mean) ## spol visina ## 1 m 183.0000 ## 2 z 173.3333 # dplyr: summarise(group_by(df, spol), povp_visina = mean(visina)) ## # A tibble: 2 x 2 ## spol povp_visina ## &lt;chr&gt; &lt;dbl&gt; ## 1 m 183 ## 2 z 173. Naloga: Poglejmo si nov primer podatkov. df &lt;- data.frame( podjetje = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;), panoga = c(&quot;proizvodnja&quot;, &quot;gostinstvo&quot;, &quot;proizvodnja&quot;, &quot;gostinstvo&quot;, &quot;proizvodnja&quot;), st_zaposlenih = c(100, 20, 110, 15, 20), dobicek = c(100000, 10000, 12000, 1000, 0) ) Z uporabo dplyr: Izberite vrstice, ki imajo med (vkljuno) 10000 in 20000 dobika. ## podjetje panoga st_zaposlenih dobicek ## 1 B gostinstvo 20 10000 ## 2 C proizvodnja 110 12000 Izberite drugi in etrti stolpec. ## panoga dobicek ## 1 proizvodnja 100000 ## 2 gostinstvo 10000 ## 3 proizvodnja 12000 ## 4 gostinstvo 1000 ## 5 proizvodnja 0 Dodajte stolpec, ki bo prikazal dobiek na zaposlenega. ## podjetje panoga st_zaposlenih dobicek dobicek_na_zaposlenega ## 1 A proizvodnja 100 100000 1000.00000 ## 2 B gostinstvo 20 10000 500.00000 ## 3 C proizvodnja 110 12000 109.09091 ## 4 D gostinstvo 15 1000 66.66667 ## 5 E proizvodnja 20 0 0.00000 Uredite podjetja po tevilu zaposlenih. ## podjetje panoga st_zaposlenih dobicek ## 1 D gostinstvo 15 1000 ## 2 B gostinstvo 20 10000 ## 3 E proizvodnja 20 0 ## 4 A proizvodnja 100 100000 ## 5 C proizvodnja 110 12000 Poiite maksimalno tevilo zaposlenih glede na panogo. ## # A tibble: 2 x 2 ## panoga max_st_zaposlenih ## &lt;chr&gt; &lt;dbl&gt; ## 1 gostinstvo 20 ## 2 proizvodnja 110 1.2 Sodobna razpredelnica: tibble Najprej si poglejmo podatke, na katerih se bomo nauili osnovnih konceptov slovnice ravnanja s podatki. V mapi data-raw se nahajajo podatki DS-jobs.csv. Gre za rezultate ankete, ki so jo v povezavi z industrijo izvedli na spletni strani Kaggle (https://www.kaggle.com/kaggle/kaggle-survey-2017) leta 2017 z namenom raziskati trg dela na podroju podatkovnih ved in strojnega uenja. Podatki so shranjeni v tekstovni datoteki, kjer so elementi loeni s podpijem. Preberimo podatke v nao sejo R: ds_jobs &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) head(ds_jobs) ## Gender Country Age EmploymentStatus ## 1 Female Australia 43 Employed full-time ## 2 Male Russia 33 Employed full-time ## 3 Male Taiwan 26 Employed full-time ## 4 Male United States 25 Employed part-time ## 5 Male United States 33 Employed full-time ## 6 Male Czech Republic 21 Employed part-time ## CurrentJobTitle LanguageRecommendation ## 1 Business Analyst Python ## 2 Software Developer/Software Engineer Python ## 3 Software Developer/Software Engineer Python ## 4 Researcher Python ## 5 Scientist/Researcher Matlab ## 6 Other Python ## FormalEducation ## 1 Bachelor&#39;s degree ## 2 Bachelor&#39;s degree ## 3 Master&#39;s degree ## 4 Bachelor&#39;s degree ## 5 Doctoral degree ## 6 Some college/university study without earning a bachelor&#39;s degree ## Major CompensationAmount CompensationCurrency ## 1 80000 AUD ## 2 Other 1200000 RUB ## 3 Computer Science 1100000 TWD ## 4 Physics 20000 USD ## 5 Electrical Engineering 100000 USD ## 6 Computer Science 20000 CZK ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 1 60 10 5 15 ## 2 40 30 15 10 ## 3 35 20 25 10 ## 4 0 80 0 20 ## 5 0 0 0 0 ## 6 20 60 20 0 ## TimeFindingInsights TimeOtherSelect ExchangeRate ## 1 10 0 0.802310 ## 2 5 0 0.017402 ## 3 10 0 0.033304 ## 4 0 0 1.000000 ## 5 0 0 1.000000 ## 6 0 0 0.045820 Spremenljivka ds_jobs je tipa data.frame. To je osnovna oblika, v kateri v R hranimo razpredelnice. V tidyverse obstaja paket tibble, ki je namenjen sodobni predstavitvi razpredelnice. Glavna funkcionalnost tega paketa je objekt tibble, ki predstavlja nadgradnjo data frame. V preostanku knjige bomo za objekte data.frame uporabljali izraz data frame in za objekte tipa tibble izraz tibble. Veina funkcij v tidyverse sicer lahko kot vhodni podatek prejme data frame, ampak ga nekatere potem samodejno pretvorijo v tibble. Kot dobro prakso predlagamo delo izkljuno s tibble. Poleg kompatibilnosti s funkcijami tidyverse je e nekaj drugih razlik v primerjavi z data frame, veino le-teh bomo spoznali v preostanku knjige. Pretvorimo sedaj ta data frame v tibble s funkcijo as_tibble(). library(tidyverse) ds_jobs &lt;- as_tibble(ds_jobs) ds_jobs ## # A tibble: 4,523 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Netherl~ 51 Employed full-time Engineer R ## 9 Male Colombia 34 Employed full-time Data Scientist Python ## 10 Male Germany 41 Independent contrac~ Data Scientist Python ## # ... with 4,513 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Opazimo, da je oblika prikaza podatkov sedaj nekoliko drugana. Najbolj oitna razlika je, da imamo na zaslonu prikazanih samo toliko stolpcev, kot jih je mono prikazati na zaslonu. Preostali stolpci so samo zapisani zaporedno z imeni, da lahko vidimo, katere stolpce e imamo v podatkih. S tem prepreimo, da bi izpis postal nepregleden. e vedno lahko vidimo vse oziroma ve stolpcev z uporabo View() ali pa e tibble izpiemo s pomojo print() in ustrezno nastavitvijo irine, na primer print(ds_jobs, width = 120). Izpis tibble pa nam nudi e nekaj dodatnih informacij v primerjavi z data frame. V prvi vrstici imamo izpisano dimenzijo podatkov  tevilo vrstic in tevilo stolpcev. Pod vsako spremenljivko je zapisan tudi njen tip. Tibble tudi dopua imena stolpcev, ki niso standardna za R (na primer vsebujejo - in podobno), eprav uporaba takih imen ni dobra praksa. Ve o tem bomo povedali kasneje. 1.3 Urejeno ovrednotenje Preden zanemo resneje delati z glagoli slovnice ravnanja s podatki, spoznajmo t. i. urejeno ovrednotenje (ang. tidy evaluation). To je posebnost tidyverse in veina glagolov v dplyr ga uporablja. Kaj pa je urejeno ovrednotenje? To je nestandarden pristop k ovrednotenju izrazov v programskem jeziku R. V pripravi smo e sreali dva primera: Pri funkciji filter() ni bilo potrebno vsaki navesti df$ za izbiro spremenljivk iz razpredelnice. Pri funkciji select() nismo potrebovali narekovajev. Oba sta primera dveh vrst urejenega ovrednotenja: Pri nekaterih glagolih v dplyr lahko uporabimo spremenljivke (stolpce) tibbla (ali razpredelnice), kot da bi bile spremenljivke v globalnem okolju (torej lahko uporabimo moja_spremenljivka namesto df$moja_spremenljivka). Temu pravimo maskiranje podatkov (ang. data masking). Funkcije, ki podpirajo to strukturo in jih bomo spoznali v nadaljevanju so: arrange(), count(), filter(), group_by(), mutate() in summarise(). Pri nekaterih glagolih v dplyr lahko na laji nain izberemo spremenljivke (stolpce) glede na njihovo pozicijo, ime ali tip (na primer izbira stolpcev po imenu brez narekovajev, izbira stolpcev ki se zanejo na doloen niz, izbira samo tevilskih stolpcev). Temu pravimo urejeno izbiranje (ang. tidy selection). Funkcije, ki podpirajo to strukturo so: across(), count(), rename(), select() in pull(). Informacije o tem, ali funkcija vsebuje maskiranje podatkov ali urejeno izbiranje, lahko najdemo v datoteki s pomojo pod razdelkom Arguments. 1.4 Izbira vrstic s filter() S funkcijo filter() izbiramo podmnoico vrstic glede na izbrane pogoje. Sintaksa je: filter(&lt;tibble&gt;, &lt;pogoj1&gt;, &lt;pogoj2&gt;, ...) Kot prvi argument podamo tibble s podatki, potem pa z vejicami loene pogoje. Izberimo vse osebe mlaje od 30 let: library(dplyr) filter(ds_jobs, Age &lt; 30) ## # A tibble: 1,729 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Taiwan 26 Employed full-t~ Software Developer~ Python ## 2 Male United S~ 25 Employed part-t~ Researcher Python ## 3 Male Czech Re~ 21 Employed part-t~ Other Python ## 4 Male Russia 22 Employed full-t~ Data Analyst Python ## 5 Male Poland 29 Employed full-t~ Software Developer~ Python ## 6 Male Other 28 Employed full-t~ Data Scientist R ## 7 Male Mexico 26 Employed part-t~ Data Scientist Python ## 8 Male Singapore 24 Employed full-t~ Data Analyst Python ## 9 Male India 29 Employed full-t~ Data Scientist R ## 10 Male United S~ 25 Employed full-t~ Engineer Python ## # ... with 1,719 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Ve pogojev loimo z vejico, kadar elimo, da veljajo vsi pogoji (enakovredno uporabi operatorja in  &amp; pri natevanju pogojev). Poglejmo si vse osebe mlaje od 30 let, ki prihajajo iz Nemije: filter(ds_jobs, Age &lt; 30, Country == &quot;Germany&quot;) ## # A tibble: 42 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Germany 24 Employed part-time Scientist/Resear~ R ## 2 Male Germany 28 Employed full-time Scientist/Resear~ Python ## 3 Male Germany 24 Independent contract~ Data Scientist Python ## 4 Female Germany 29 Employed full-time Business Analyst SQL ## 5 Male Germany 26 Employed part-time Researcher Python ## 6 Male Germany 27 Employed full-time Data Scientist Python ## 7 Female Germany 26 Employed part-time Statistician R ## 8 Male Germany 26 Independent contract~ Data Scientist Python ## 9 Male Germany 29 Employed full-time Machine Learning~ Python ## 10 Male Germany 25 Employed full-time Data Scientist Python ## # ... with 32 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; V kolikor elimo, da velja vsaj eden izmed pogojev, moramo uporabiti operator ali  |. Poglejmo si vse osebe mlaje od 30 ali stareje od 50 let: filter(ds_jobs, Age &lt; 30 | Age &gt; 50) ## # A tibble: 2,006 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Taiwan 26 Employed full-t~ Software Developer~ Python ## 2 Male United S~ 25 Employed part-t~ Researcher Python ## 3 Male Czech Re~ 21 Employed part-t~ Other Python ## 4 Male Russia 22 Employed full-t~ Data Analyst Python ## 5 Male Netherla~ 51 Employed full-t~ Engineer R ## 6 Male Poland 29 Employed full-t~ Software Developer~ Python ## 7 Male Other 28 Employed full-t~ Data Scientist R ## 8 Male Mexico 26 Employed part-t~ Data Scientist Python ## 9 Male Singapore 24 Employed full-t~ Data Analyst Python ## 10 Male India 29 Employed full-t~ Data Scientist R ## # ... with 1,996 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; e elimo nek kategorini stolpec pogojiti z veimi vrednostmi (na primer udeleence iz veih drav), lahko namesto veih | uporabimo operator %in%, ki preveri, e je element del mnoice: filter(ds_jobs, Country %in% c(&quot;Germany&quot;, &quot;Canada&quot;, &quot;Ireland&quot;)) ## # A tibble: 306 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Male Germany 41 Independent contrac~ Data Scientist Python ## 2 Female Germany 49 Employed part-time Scientist/Resea~ Python ## 3 Male Germany 44 Employed full-time Other Python ## 4 A diffe~ Canada 23 Employed full-time Scientist/Resea~ Python ## 5 Female Germany 24 Employed part-time Scientist/Resea~ R ## 6 Male Canada 52 Employed full-time Software Develo~ Python ## 7 Male Ireland 27 Employed full-time Data Scientist Python ## 8 Male Canada 24 Employed full-time Business Analyst Python ## 9 Male Canada 46 Employed full-time Data Scientist Python ## 10 Male Canada 31 Employed full-time Data Analyst R ## # ... with 296 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; 1.4.1 Manjkajoe vrednosti Vrstice pogosto filtriramo na podlagi manjkajoih vrednosti. Vasih so te pomembne za samo analizo, saj nas lahko zanimajo razlogi za njihov pojav. Vasih pa so to nepomembne vrstice, saj nam ne prinesejo dodatne informacije. V tem primeru jih obiajno kar izloimo iz nadaljnje analize. V nadaljevanju bomo spoznali, kako dodati nov stolpec, in to ilustrirali na izraunu plae v dolarjih. Za to bomo potrebovali stolpca CompensationAmount in ExchangeRate. V slednjem je kar nekaj manjkajoih vrednosti. Takne vrstice bodo za analizo pla neuporabne, zato jih bomo sedaj izloili iz podatkov. Ali je vrednost enaka NA (objekt, ki predstavlja manjkajoo vrednost v R) preverimo s funkcijo is.na(). Izloimo sedaj te vrstice: ds_jobs &lt;- filter(ds_jobs, !is.na(ExchangeRate)) Podobno kot v zgornjem primeru lahko v pogoju nastopa poljubna funkcija. 1.5 Izbira stolpcev s select() S funkcijo select() izbiramo podmnoico stolpcev. Osnovna sintaksa je: filter(&lt;tibble&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ...) Izberimo sedaj stolpce Country, Age in EmploymentStatus. select(ds_jobs, Country, Age, EmploymentStatus) ## # A tibble: 3,781 x 3 ## Country Age EmploymentStatus ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Australia 43 Employed full-time ## 2 Russia 33 Employed full-time ## 3 Taiwan 26 Employed full-time ## 4 United States 25 Employed part-time ## 5 United States 33 Employed full-time ## 6 Czech Republic 21 Employed part-time ## 7 Russia 22 Employed full-time ## 8 Colombia 34 Employed full-time ## 9 Germany 41 Independent contractor, freelancer, or self-employed ## 10 Poland 29 Employed full-time ## # ... with 3,771 more rows Izberimo vse stolpce razen teh treh stolpcev. Za to enostavno dodamo minus pred imenom stolpca, ki ga elimo izloiti: select(ds_jobs, -Country, -Age, -EmploymentStatus) ## # A tibble: 3,781 x 14 ## Gender CurrentJobTitle LanguageRecommen~ FormalEducation Major ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Business Analyst Python Bachelor&#39;s degree &quot;&quot; ## 2 Male Software Develope~ Python Bachelor&#39;s degree &quot;Other&quot; ## 3 Male Software Develope~ Python Master&#39;s degree &quot;Computer ~ ## 4 Male Researcher Python Bachelor&#39;s degree &quot;Physics&quot; ## 5 Male Scientist/Researc~ Matlab Doctoral degree &quot;Electrica~ ## 6 Male Other Python Some college/univers~ &quot;Computer ~ ## 7 Male Data Analyst Python Bachelor&#39;s degree &quot;Informati~ ## 8 Male Data Scientist Python Master&#39;s degree &quot;Computer ~ ## 9 Male Data Scientist Python I did not complete a~ &quot;&quot; ## 10 Male Software Develope~ Python Master&#39;s degree &quot;Computer ~ ## # ... with 3,771 more rows, and 9 more variables: CompensationAmount &lt;dbl&gt;, ## # CompensationCurrency &lt;chr&gt;, TimeGatheringData &lt;int&gt;, ## # TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, TimeVisualizing &lt;dbl&gt;, ## # TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ExchangeRate &lt;dbl&gt; Izberimo vse stolpce med Country in Major. Podobno kot v R 1:10 nateje vsa cela tevila med 1 in 10, operator : v tidyverse izbere vse stolpce med Country in Major: select(ds_jobs, Country:Major) ## # A tibble: 3,781 x 7 ## Country Age EmploymentStatus CurrentJobTitle LanguageRecommen~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Australia 43 Employed full-time Business Analyst Python ## 2 Russia 33 Employed full-time Software Developer~ Python ## 3 Taiwan 26 Employed full-time Software Developer~ Python ## 4 United S~ 25 Employed part-time Researcher Python ## 5 United S~ 33 Employed full-time Scientist/Research~ Matlab ## 6 Czech Re~ 21 Employed part-time Other Python ## 7 Russia 22 Employed full-time Data Analyst Python ## 8 Colombia 34 Employed full-time Data Scientist Python ## 9 Germany 41 Independent contractor~ Data Scientist Python ## 10 Poland 29 Employed full-time Software Developer~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; Izberimo vse stolpce, ki se zanejo z besedo Time. Za to bomo uporabili funkcijo starts_with(). Ta funkcija je t. i. selection helper, kar pomeni, da jo lahko uporabimo le znotraj funkcij, ki omogoajo urejeno izbiro in nam omogoa lajo izbiro na podlagi nekega pogoja. V tem primeru je ta pogoj, da se beseda zane na doloen niz: select(ds_jobs, starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 6 ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 60 10 5 15 ## 2 40 30 15 10 ## 3 35 20 25 10 ## 4 0 80 0 20 ## 5 0 0 0 0 ## 6 20 60 20 0 ## 7 50 20 10 5 ## 8 60 10 20 5 ## 9 50 10 20 10 ## 10 25 20 25 20 ## # ... with 3,771 more rows, and 2 more variables: TimeFindingInsights &lt;dbl&gt;, ## # TimeOtherSelect &lt;int&gt; Poleg starts_with() dplyr vsebuje e ve taknih funkcij: ends_with() Ali se ime stolpca kona na doloen niz? contains() Ali ime stolpca vsebuje niz? matches() Ali ime stolpca ustreza regularnemu izrazu? Ve o regularnih izrazih bomo povedali v 3. predavanju. num_range() Ali ime stolpca vsebuje tevila znotraj mnoice tevil? Na primer, e imamo stolpce, ki v imenu vsebujejo tevila  stolpec1, stolpec2, in tako naprej. 1.6 Urejanje vrstic z arrange() Vrstice lahko tudi uredimo glede na vrednosti v posameznih stolpcih. Za to uporabimo funkcijo arrange(). Sintaksa te funkcije je: arrange(&lt;tibble&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ...) kjer stolpci predstavljajo vrednosti, po katerih elimo urediti tibble. Ustvarimo najprej nov tibble, v katerem bomo izbrali podmnoico stolpcev. ds_jobs_tmp &lt;- select(ds_jobs, CurrentJobTitle, Country, CompensationCurrency, Age, CompensationAmount) Uredimo sedaj podatke glede na leta: arrange(ds_jobs_tmp, Age) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Predictive Modeler Australia AUD 0 78000 ## 2 Scientist/Researcher United St~ USD 1 100000 ## 3 Programmer Other GBP 11 0 ## 4 Data Scientist United St~ USD 16 50000 ## 5 Software Developer/Soft~ Russia USD 18 40000 ## 6 Programmer Other USD 18 1000 ## 7 Machine Learning Engine~ Other USD 19 30000 ## 8 Programmer Russia USD 19 40000 ## 9 Scientist/Researcher Canada CAD 19 0 ## 10 Computer Scientist Brazil BRL 19 400 ## # ... with 3,771 more rows Opazimo, da imamo nekaj neveljavnih starosti, na primer 0 in 1, najverjetneje tudi 11. Prav tako imamo nekaj nesmiselnih vrednosti v stolpcu o plai. Pri celostni analizi bi seveda raziskali, zakaj je prilo do takih vrednosti, oziroma bi jih izloili iz analize. Za namen spoznavanja ravnanja s podatki in dplyr to ni pomembno, tako da temu ne bomo posveali pozornosti. Bralcem pa predlagamo, naj razmislijo, kako bi se tega lotili z e nauenimi koncepti. e elimo podatke urediti padajoe, potem uporabimo funkcijo desc(): arrange(ds_jobs_tmp, desc(Age)) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Statistician United Ki~ ILS 100 100000000000 ## 2 Other Other EUR 99 15000 ## 3 Researcher Portugal EUR 78 63000 ## 4 Data Scientist Canada USD 75 110 ## 5 Software Developer/Soft~ Netherlan~ EUR 73 40000 ## 6 Data Analyst Russia USD 70 14000 ## 7 Business Analyst United St~ USD 70 130000 ## 8 Machine Learning Engine~ United Ki~ GBP 70 40000 ## 9 Scientist/Researcher United St~ USD 69 200000 ## 10 Business Analyst United St~ USD 68 125000 ## # ... with 3,771 more rows Uredimo lahko tudi glede na ve stolpcev, kjer se najprej uredi po prvem zapisanem, nato drugem, itd.: arrange(ds_jobs_tmp, Age, CompensationAmount) ## # A tibble: 3,781 x 5 ## CurrentJobTitle Country CompensationCurre~ Age CompensationAmo~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Predictive Modeler Australia AUD 0 78000 ## 2 Scientist/Researcher United St~ USD 1 100000 ## 3 Programmer Other GBP 11 0 ## 4 Data Scientist United St~ USD 16 50000 ## 5 Programmer Other USD 18 1000 ## 6 Software Developer/Soft~ Russia USD 18 40000 ## 7 Scientist/Researcher Canada CAD 19 0 ## 8 Computer Scientist Brazil BRL 19 400 ## 9 Machine Learning Engine~ Other USD 19 30000 ## 10 Programmer Russia USD 19 40000 ## # ... with 3,771 more rows 1.7 Dodajanje novih spremenljivk z mutate() Pogosto elimo ustvariti nove stolpce, ki so izpeljani iz obstojeih stolpcev. Pri naih podatkih imamo stolpec CompensationAmount, ki predstavlja letno plao in ExchangeRate, ki predstavlja menjalni teaj lokalne valute v ameriki dolar. e elimo imeti primerljive podatke, moramo izraunati vrednosti v dolarjih za vse podatke. Za to uporabimo funkcijo mutate(), ki doda stolpec (ali ve stolpcev). Sintaksa funkcije je: &lt;tibble&gt; &lt;- mutate(&lt;tibble&gt;, &lt;ime-novega-stolpca&gt; = &lt;funkcija-obstojeih-stolpcev&gt;, ...) Dodajmo stolpec CompensationUSD, ki bo prikazal letno plao v USD: ds_jobs &lt;- mutate(ds_jobs, CompensationUSD = CompensationAmount * ExchangeRate) select(ds_jobs, CompensationAmount, ExchangeRate, CompensationUSD) ## # A tibble: 3,781 x 3 ## CompensationAmount ExchangeRate CompensationUSD ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 80000 0.802 64185. ## 2 1200000 0.0174 20882. ## 3 1100000 0.0333 36634. ## 4 20000 1 20000 ## 5 100000 1 100000 ## 6 20000 0.0458 916. ## 7 624000 0.0174 10859. ## 8 156000000 0.000342 53352 ## 9 150000 1.20 179374. ## 10 126000 0.281 35419. ## # ... with 3,771 more rows Znotraj klica mutate() lahko uporabimo stolpce, ki smo jih ustvarili v istem klicu v preteklih vrsticah. Recimo, da elimo poleg plae v USD izraunati e meseno plao v USD: ds_jobs &lt;- mutate(ds_jobs, CompensationUSD = CompensationAmount * ExchangeRate, MonthlyCompUSD = CompensationUSD / 12) select(ds_jobs, CompensationAmount, ExchangeRate, CompensationUSD, MonthlyCompUSD) ## # A tibble: 3,781 x 4 ## CompensationAmount ExchangeRate CompensationUSD MonthlyCompUSD ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 80000 0.802 64185. 5349. ## 2 1200000 0.0174 20882. 1740. ## 3 1100000 0.0333 36634. 3053. ## 4 20000 1 20000 1667. ## 5 100000 1 100000 8333. ## 6 20000 0.0458 916. 76.4 ## 7 624000 0.0174 10859. 905. ## 8 156000000 0.000342 53352 4446 ## 9 150000 1.20 179374. 14948. ## 10 126000 0.281 35419. 2952. ## # ... with 3,771 more rows 1.8 Povzemanje vrednosti s summarise() Funkcija summarise() se uporablja za povzemanje vrednosti (na primer povpreja, vsote, tevci, ). Sintaksa funkcije je: summarise(&lt;tibble&gt;, &lt;ime-povzetka&gt; = &lt;funkcija-ki-povzame-stolpec&gt;, ...) Najprej poglejmo delovanje te funkcije, tako da povzamemo povpreen as priprave podatkov: summarise(ds_jobs, MeanDataCleaning = mean(TimeGatheringData)) ## # A tibble: 1 x 1 ## MeanDataCleaning ## &lt;dbl&gt; ## 1 37.3 Funkcija enostavno vrne povpreje stolpca TimeGatheringData. Ta informacija je sicer uporabna, ampak to ni edina funkcionalnost te funkcije in je obiajno ne uporabljamo v tej obliki. Njena mo se izrazi, ko jo uporabimo v kombinaciji z ukazom group_by(). Ta ukaz zdrui vrstice glede na vrednosti v podanih stolpcih. Zdruene vrednosti imajo posebno funkcijo v paketu dplyr in vplivajo na funkcionalnosti funkcij summarise(), mutate() in filter(). Vpliv grupiranja na mutate() in filter() si bomo ogledali nekoliko kasneje, poglejmo sedaj vpliv na summarise(). Recimo, da nas zanima, v katerih slubah je potrebnega najve ienja podatkov. Najprej podatke zdruimo po stolpcu CurrentJobTitle, potem pa uporabimo summarise(): ds_jobs_grouped &lt;- group_by(ds_jobs, CurrentJobTitle) summarise(ds_jobs_grouped, MeanDataCleaning = mean(TimeGatheringData)) ## # A tibble: 17 x 2 ## CurrentJobTitle MeanDataCleaning ## &lt;chr&gt; &lt;dbl&gt; ## 1 &quot;&quot; 40 ## 2 &quot;Business Analyst&quot; 37.9 ## 3 &quot;Computer Scientist&quot; 33.3 ## 4 &quot;Data Analyst&quot; 41.2 ## 5 &quot;Data Miner&quot; 48.0 ## 6 &quot;Data Scientist&quot; 39.4 ## 7 &quot;DBA/Database Engineer&quot; 37.7 ## 8 &quot;Engineer&quot; 36.4 ## 9 &quot;Machine Learning Engineer&quot; 34.7 ## 10 &quot;Operations Research Practitioner&quot; 37.8 ## 11 &quot;Other&quot; 36.3 ## 12 &quot;Predictive Modeler&quot; 37.1 ## 13 &quot;Programmer&quot; 35.8 ## 14 &quot;Researcher&quot; 31.3 ## 15 &quot;Scientist/Researcher&quot; 33.5 ## 16 &quot;Software Developer/Software Engineer&quot; 36.9 ## 17 &quot;Statistician&quot; 34.7 Izgleda, da so povpreja kar blizu  as ienja podatkov je relativno neodvisen od delovnega mesta. Povzemamo lahko tudi preko veih stolpcev. Poglejmo si tevilo ljudi z razlinimi statusi zaposlitve v kombinaciji z izobrazbo. Da pretejemo tevilo vrstic, ki ustrezajo grupiranju, uporabimo funkcijo n(): ds_jobs_grouped &lt;- group_by(ds_jobs, FormalEducation, EmploymentStatus) summarise(ds_jobs_grouped, Count = n()) ## # A tibble: 21 x 3 ## # Groups: FormalEducation [8] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows Ker je tetje primerov zelo pogosta operacija, obstaja tudi funkcija count(), ki naredi enako kot kombinacija group_by() in summarise(): count(ds_jobs, FormalEducation, EmploymentStatus) ## # A tibble: 21 x 3 ## FormalEducation EmploymentStatus n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows 1.9 Pipe V praksi ravnanje s podatki zajame veino, e ne kar vseh funkcij, ki smo jih predstavili do sedaj. e elimo sproti shranjevati nae spremembe, moramo po vsaki uporabi funkcije spremenjene podatke ponovno shraniti v spremenljivko. To lahko postane nekoliko nepregledno. Poglejmo si potek dela, kjer bomo nad osnovnimi podatki izvedli te operacije: Izbrali bomo vrstice, kjer so osebe stareje od 30 let in drava ni Other ali prazen niz. Izloili vse stolpce, ki vsebujejo niz Time. Izraunali stolpec s plao v amerikih dolarjih. Povzeli plao glede na dravo. Z uporabo shranjevanja podatkov v spremenljivko, kot smo navajeni iz osnovne razliice R, bi s funkcijami iz dplyr izgledalo takole: ds_jobs2 &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs2 &lt;- as_tibble(ds_jobs2) ds_jobs2 &lt;- filter(ds_jobs2, Age &gt; 30, !(Country %in% c(&quot;Other&quot;, &quot;&quot;))) ds_jobs2 &lt;- select(ds_jobs2, -contains(&quot;Time&quot;)) ds_jobs2 &lt;- mutate(ds_jobs2, CompensationUSD = CompensationAmount * ExchangeRate) ds_jobs2 &lt;- group_by(ds_jobs2, Country) ds_jobs2_summarised &lt;- summarise(ds_jobs2, MeanCompensation = mean(CompensationUSD, na.rm = T)) ds_jobs2_summarised ## # A tibble: 51 x 2 ## Country MeanCompensation ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 39282. ## 2 Australia 112800. ## 3 Belarus 33500 ## 4 Belgium 74141. ## 5 Brazil 47799. ## 6 Canada 85471. ## 7 Chile 44152. ## 8 Colombia 43303. ## 9 Czech Republic 50223. ## 10 Denmark 88136. ## # ... with 41 more rows Pri raunanju povpreja smo uporabili argument na.rm = T, s katerim smo manjkajoe vrednosti ignorirali. Celoten postopek je vseboval kar nekaj prepisovanja. Predvsem spremenljivko ds_jobs2 smo morali prepisati kar 6-krat. Dplyr pa vsebuje poseben operator, ki ga imenujemo pipe in ga oznaimo z %&gt;%. S tem operatorjem funkcije poveemo v sosledje. Poglejmo si, kako deluje: ds_jobs2 &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs2_summarised &lt;- ds_jobs2 %&gt;% filter(Age &gt; 30, !(Country %in% c(&quot;Other&quot;, &quot;&quot;))) %&gt;% select(-contains(&quot;Time&quot;)) %&gt;% mutate(CompensationUSD = CompensationAmount * ExchangeRate) %&gt;% group_by(Country) %&gt;% summarise(MeanCompensation = mean(CompensationUSD, na.rm = T)) ds_jobs2_summarised ## # A tibble: 51 x 2 ## Country MeanCompensation ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 39282. ## 2 Australia 112800. ## 3 Belarus 33500 ## 4 Belgium 74141. ## 5 Brazil 47799. ## 6 Canada 85471. ## 7 Chile 44152. ## 8 Colombia 43303. ## 9 Czech Republic 50223. ## 10 Denmark 88136. ## # ... with 41 more rows Sedaj smo do povzetka prili z zaporednim izvajanjem operacij nad spremenljivko ds_jobs. Ta nain je bolj pregleden, saj bralec kode takoj opazi, da se je vse izvajalo nad istimi podatki. Opazimo tudi, zakaj gre za slovnico ravnanja s podatki. Programska koda zapisana zgoraj se bere skoraj kot naravni jezik. Na primer, izberi vrstice, kjer so leta veja od 30 in drava ni v ustrezni mnoici. Zatem izberi stolpce, ki ne vsebujejo besede Time. Dodaj novo spremenljivko, zdrui podatke in jih povzemi. 1.10 filter() in mutate() na zdruenih podatkih Spoznali smo, kako funkcija group_by() vpliva na povzemanje podatkov. Uporabimo pa jo lahko tudi v povezavi s filter() in mutate(). Kombinacija z izbiro vrstic pride prav, kadar elimo pogojno izbiro na nek drugi stolpec. Kot primer si poglejmo, kako bi iz podatkov za vsako dravo filtrirali top 3 anketirance, ki prejmejo najvijo plao. Najprej bomo podatke grupirali, nato pa uporabili filter: ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country) %&gt;% filter(rank(desc(CompensationUSD)) &lt;= 3) %&gt;% arrange(Country) ## # A tibble: 154 x 4 ## # Groups: Country [53] ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 &quot;&quot; NA Data Scientist 107624. ## 2 &quot;&quot; 63 Machine Learning Engineer 160000 ## 3 &quot;&quot; NA Operations Research Practitioner 120000 ## 4 &quot;Argentina&quot; 55 Data Scientist 100000 ## 5 &quot;Argentina&quot; 26 Data Scientist 65000 ## 6 &quot;Argentina&quot; 26 Data Scientist 80000 ## 7 &quot;Australia&quot; 39 Data Scientist 280808. ## 8 &quot;Australia&quot; 50 Data Miner 248716. ## 9 &quot;Australia&quot; 37 Software Developer/Software Engineer 400000 ## 10 &quot;Belarus&quot; 22 Data Scientist 10800 ## # ... with 144 more rows Kombinacija group_by() in mutate() je uporabna, kadar elimo ustvariti novo spremenljivko, pri kateri bomo pri izraunu potrebovali kak povzetek vrednosti znotraj posamezne skupine. Primer takne transformacije je na primer standardiziranje znotraj skupine. Standardna ocena je: \\[ z_i = \\frac{x_i - \\bar{x}}{S_x}, \\] kjer je \\(\\bar{x}\\) povpreje vektorja \\(x\\) in \\(S_x\\) njegov vzorni standardni odklon. Poskusimo za vsako dravo izraunati vzorno povpreno vrednost in standardni odklon, ter s tema vrednostima ustrezno transformirati plao v USD. Da pa bo funkcija mutate() vedela, katere vrednosti naj vzame za raunanje teh dveh statistie moramo podatke najprej grupirati glede na dravo: ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country) %&gt;% mutate(CompensationStand = (CompensationUSD - mean(CompensationUSD)) / sd(CompensationUSD)) ## # A tibble: 3,781 x 5 ## # Groups: Country [53] ## Country Age CurrentJobTitle CompensationUSD CompensationSta~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. -0.617 ## 2 Russia 33 Software Developer/Softwa~ 20882. -0.136 ## 3 Taiwan 26 Software Developer/Softwa~ 36634. 0.0566 ## 4 United Sta~ 25 Researcher 20000 -0.0468 ## 5 United Sta~ 33 Scientist/Researcher 100000 -0.0347 ## 6 Czech Repu~ 21 Other 916. -0.907 ## 7 Russia 22 Data Analyst 10859. -0.417 ## 8 Colombia 34 Data Scientist 53352 0.770 ## 9 Germany 41 Data Scientist 179374. 2.35 ## 10 Poland 29 Software Developer/Softwa~ 35419. 0.486 ## # ... with 3,771 more rows e ta tibble shranimo v novo spremenljivko, se bo informacija o zdruevanju ohranila. ds_jobs_grouped &lt;- ds_jobs %&gt;% select(Country, Age, CurrentJobTitle, CompensationUSD) %&gt;% group_by(Country, CurrentJobTitle) ds_jobs_grouped ## # A tibble: 3,781 x 4 ## # Groups: Country, CurrentJobTitle [543] ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. ## 2 Russia 33 Software Developer/Software Engineer 20882. ## 3 Taiwan 26 Software Developer/Software Engineer 36634. ## 4 United States 25 Researcher 20000 ## 5 United States 33 Scientist/Researcher 100000 ## 6 Czech Republic 21 Other 916. ## 7 Russia 22 Data Analyst 10859. ## 8 Colombia 34 Data Scientist 53352 ## 9 Germany 41 Data Scientist 179374. ## 10 Poland 29 Software Developer/Software Engineer 35419. ## # ... with 3,771 more rows Opazimo, da ima ta tibble dodatno informacijo v drugi vrstici, ki nam sporoa, da je zdruen glede na spremenljivki Country in CurrentJobTitle. Poleg tega je v oglatih oklepajih zapisano tevilo unikatnih skupin. Pri tem so vsi pari drave in trenutne pozicije, za katere nimamo nobenega podatka, izpueni. Informacija o tem, da je ta tibble grupiran, je pomembna, saj se bodo vse nadaljnje operacije nad njim izvajale nad skupinami. e tega ne elimo, lahko uporabimo funkcijo ungroup(). ds_jobs_ungrouped &lt;- ds_jobs_grouped %&gt;% ungroup() ds_jobs_ungrouped ## # A tibble: 3,781 x 4 ## Country Age CurrentJobTitle CompensationUSD ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia 43 Business Analyst 64185. ## 2 Russia 33 Software Developer/Software Engineer 20882. ## 3 Taiwan 26 Software Developer/Software Engineer 36634. ## 4 United States 25 Researcher 20000 ## 5 United States 33 Scientist/Researcher 100000 ## 6 Czech Republic 21 Other 916. ## 7 Russia 22 Data Analyst 10859. ## 8 Colombia 34 Data Scientist 53352 ## 9 Germany 41 Data Scientist 179374. ## 10 Poland 29 Software Developer/Software Engineer 35419. ## # ... with 3,771 more rows 1.11 Izvajanje operacij nad veimi stolpci z across() S kombinacijo funkcij mutate() in across() lahko izvajamo isto operacijo hkrati na ve stolpcih. Znotraj funkcije across() lahko uporabljamo iste funkcije za izbiro kot znotraj select(). Spremenimo vrednosti stolpcev, ki se zanejo s Time, v delee tako, da jih pomnoimo z 0.01. Na tem mestu bomo uporabili dva nova operatorja: . in ~. Operator . v dplyr igra vlogo podatkov, nad katerimi operiramo. Operator ~ je nekakna blinjica, ki ustvari funkcijo. Na primer ~ x^2 je blinjica za zapis function(x) {x^2}. To je uporabno predvsem, ko funkcijo potrebujemo samo na enem mestu znotraj naega poteka dela in jo tako lahko na kraji nain zapiemo. Poglejmo si sedaj spremembo stolpcev v delee: ds_jobs %&gt;% mutate(across(starts_with(&quot;Time&quot;), ~ . * 0.01)) %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 8 ## Country CurrentJobTitle TimeGatheringDa~ TimeModelBuildi~ TimeProduction ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 0.6 0.1 0.05 ## 2 Russia Software Develope~ 0.4 0.3 0.15 ## 3 Taiwan Software Develope~ 0.35 0.2 0.25 ## 4 United S~ Researcher 0 0.8 0 ## 5 United S~ Scientist/Researc~ 0 0 0 ## 6 Czech Re~ Other 0.2 0.6 0.2 ## 7 Russia Data Analyst 0.5 0.2 0.1 ## 8 Colombia Data Scientist 0.6 0.1 0.2 ## 9 Germany Data Scientist 0.5 0.1 0.2 ## 10 Poland Software Develope~ 0.25 0.2 0.25 ## # ... with 3,771 more rows, and 3 more variables: TimeVisualizing &lt;dbl&gt;, ## # TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;dbl&gt; Funkciji across() smo najprej podali stolpce, na katerih elimo izvajati izraune, nato pa funkcijo, ki jo elimo izvesti. 1.12 Povzemanje stolpcev Pogosto elimo dobiti numerine povzetke glede na vrednosti v stolpcih. Z uporabo osnovne razliice R to lahko naredimo s funkcijo apply(), ki ji podamo tibble numerinih vrednosti (lahko tudi data.frame ali matriko), doloimo dimenzijo 2, ki predstavlja stolpce, ter podamo kateri povzetek elimo (na primer povpreje, varianco, maksimalno vrednost, ). Izraunajmo povpreja in standardne odklone stolpcev, ki se zanejo s Time: ds_jobs_times &lt;- ds_jobs %&gt;% select(starts_with(&quot;Time&quot;)) apply(ds_jobs_times, 2, mean, na.rm = T) ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 37.341973 21.085472 11.172853 14.190924 ## TimeFindingInsights TimeOtherSelect ## 13.375298 2.202176 apply(ds_jobs_times, 2, sd, na.rm = T) ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## 20.96041 15.19101 12.03243 10.99431 ## TimeFindingInsights TimeOtherSelect ## 12.01139 11.18898 apply() nam v teh primerih vrne vektor, eprav smo operacijo izvajali na tibble. Ideja paketa tidyverse je, da so izhodni podatki enakega tipa kot vhodni  v tem primeru tibble. e elimo izraunati povzetke za vsak stolpec, lahko v paketu dplyr uporabimo kombinacijo funkcije summarise() in across(). Kot smo e spoznali, nam funkcija across() omogoa izvajanje operacij nad veimi stolpci. ds_jobs %&gt;% summarise(across(starts_with(&quot;Time&quot;), mean, na.rm = T)) ## # A tibble: 1 x 6 ## TimeGatheringData TimeModelBuilding TimeProduction TimeVisualizing ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 37.3 21.1 11.2 14.2 ## # ... with 2 more variables: TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;dbl&gt; Povzetke lahko enostavno izraunamo tudi za razline skupine z uporabo funkcije group_by(): ds_jobs %&gt;% group_by(EmploymentStatus) %&gt;% summarise(across(starts_with(&quot;Time&quot;), mean, na.rm = T)) ## # A tibble: 3 x 7 ## EmploymentStatus TimeGatheringDa~ TimeModelBuildi~ TimeProduction ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Employed full-time 37.6 20.6 11.0 ## 2 Employed part-time 37.4 26.1 10.3 ## 3 Independent contractor, free~ 34.8 23.0 12.8 ## # ... with 3 more variables: TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, ## # TimeOtherSelect &lt;dbl&gt; 1.13 Povzemanje vrstic Kadar analiziramo podatke, preverimo, ali so vneeni podatki smiselni. Na primer, v stolpcih, ki se zanejo s Time, so odstotkovne vrednosti asa, ki ga anketiranci porabijo za posamezne naloge. Te bi se morale seteti v 100 in v primeru, ko se ne, se lahko odloimo, da takne vrstice izbriemo. Na tem primeru si bomo sedaj pogledali e operacije nad stolpci. Na cilj bo, da dodamo temu tibblu e en stolpec, v katerem bomo seteli vse te stolpce. Funkcija apply deluje tudi nad stolpci, e spremenimo drugi argument: tmp &lt;- ds_jobs %&gt;% select(starts_with(&quot;Time&quot;)) head(apply(tmp, 1, sum, na.rm = T)) ## [1] 100 100 100 100 0 100 Kako pa to naredimo z dplyr, tako da se bo naravno vkljuilo v potek dela? Prva ideja bi morda bila, da enostavno natejemo vse stolpce. ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TotalTime = TimeGatheringData + TimeModelBuilding + TimeProduction + TimeVisualizing + TimeFindingInsights + TimeOtherSelect) %&gt;% select(!starts_with(&quot;Time&quot;)) # Ta vrstica je samo za lepi izpis. ## # A tibble: 3,781 x 3 ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 100 ## 2 Russia Software Developer/Software Engineer 100 ## 3 Taiwan Software Developer/Software Engineer 100 ## 4 United States Researcher 100 ## 5 United States Scientist/Researcher 0 ## 6 Czech Republic Other 100 ## 7 Russia Data Analyst 100 ## 8 Colombia Data Scientist 100 ## 9 Germany Data Scientist 100 ## 10 Poland Software Developer/Software Engineer 100 ## # ... with 3,771 more rows Sicer je to v naem primeru bilo izvedljivo, saj smo imeli samo 6 stolpcev. Kako pa bi to naredili z veimi stolpci? Morda lahko uporabimo starts_with(): ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TimeTotal = sum(starts_with(&quot;Time&quot;), na.rm = T)) ## Error: Problem with `mutate()` column `TimeTotal`. ## i `TimeTotal = sum(starts_with(&quot;Time&quot;), na.rm = T)`. ## x `starts_with()` must be used within a *selecting* function. ## i See &lt;https://tidyselect.r-lib.org/reference/faq-selection-context.html&gt;. R vrne napako in nas opozori, da se lahko starts_with() uporabi le znotraj izbire. e elimo v tem primeru omogoiti urejeno izbiro stolpcev, uporabimo funkcijo c_across(). Ta funkcija je po funkcionalnosti bolj podobna funkciji c() ali select(), kot pa funkciji across(), tako da jih ne smemo zamenjati: ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% mutate(TotalTime = sum(c_across(starts_with(&quot;Time&quot;)), na.rm = T)) %&gt;% select(!starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 3 ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 375462 ## 2 Russia Software Developer/Software Engineer 375462 ## 3 Taiwan Software Developer/Software Engineer 375462 ## 4 United States Researcher 375462 ## 5 United States Scientist/Researcher 375462 ## 6 Czech Republic Other 375462 ## 7 Russia Data Analyst 375462 ## 8 Colombia Data Scientist 375462 ## 9 Germany Data Scientist 375462 ## 10 Poland Software Developer/Software Engineer 375462 ## # ... with 3,771 more rows Sedaj smo dobili nek rezultat, ki pa e vedno ni pravilen. V em je teava? e sum() uporabimo znotraj mutate(), ta vrne vsoto znotraj skupin, doloenih z group_by(). Ker podatkov nismo grupirali, vrne vsoto kar ez celotne podatke. Reitev se torej skriva v ustreznem zdruevanju vrstic. V dplyr obstaja funkcija, ki celoten tibble grupira po posameznih vrsticah in to je rowwise(): ds_jobs %&gt;% select(Country, CurrentJobTitle, starts_with(&quot;Time&quot;)) %&gt;% rowwise() %&gt;% mutate(TotalTime = sum(c_across(starts_with(&quot;Time&quot;)), na.rm = T)) %&gt;% select(!starts_with(&quot;Time&quot;)) ## # A tibble: 3,781 x 3 ## # Rowwise: ## Country CurrentJobTitle TotalTime ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Australia Business Analyst 100 ## 2 Russia Software Developer/Software Engineer 100 ## 3 Taiwan Software Developer/Software Engineer 100 ## 4 United States Researcher 100 ## 5 United States Scientist/Researcher 0 ## 6 Czech Republic Other 100 ## 7 Russia Data Analyst 100 ## 8 Colombia Data Scientist 100 ## 9 Germany Data Scientist 100 ## 10 Poland Software Developer/Software Engineer 100 ## # ... with 3,771 more rows 1.14 Dodatek 1.14.1 Zamenjava vrstnega reda stolpcev Vrstni red stolpcev zamenjamo s funkcijo relocate(). Ustvarimo najprej manji tibble: ds_jobs_select &lt;- ds_jobs %&gt;% select(Gender:Major) ds_jobs_select ## # A tibble: 3,781 x 8 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; e elimo doloene stolpce premakniti na zaetek, jih enostavno podamo funkciji relocate(). Dajmo na prvo mesto stolpca Major in Age: ds_jobs_select %&gt;% relocate(Major, Age) ## # A tibble: 3,781 x 8 ## Major Age Gender Country EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;&quot; 43 Female Austra~ Employed full-t~ Business Analy~ Python ## 2 &quot;Othe~ 33 Male Russia Employed full-t~ Software Devel~ Python ## 3 &quot;Comp~ 26 Male Taiwan Employed full-t~ Software Devel~ Python ## 4 &quot;Phys~ 25 Male United~ Employed part-t~ Researcher Python ## 5 &quot;Elec~ 33 Male United~ Employed full-t~ Scientist/Rese~ Matlab ## 6 &quot;Comp~ 21 Male Czech ~ Employed part-t~ Other Python ## 7 &quot;Info~ 22 Male Russia Employed full-t~ Data Analyst Python ## 8 &quot;Comp~ 34 Male Colomb~ Employed full-t~ Data Scientist Python ## 9 &quot;&quot; 41 Male Germany Independent con~ Data Scientist Python ## 10 &quot;Comp~ 29 Male Poland Employed full-t~ Software Devel~ Python ## # ... with 3,771 more rows, and 1 more variable: FormalEducation &lt;chr&gt; Poljubno ureditev dobimo tako, da enostavno zapiemo vrstni red stolpcev, kot ga elimo. Funkcija relocate() omogoa e nekatere monosti urejanja, kot na primer, glede na tip spremenljivke. Za ve informacij o razlinih nainih urejanja stolpcev bralcu predlagamo uporabo pomoi ?relocate. 1.14.2 Preimenovanje stolpcev Stolpce preimenujemo s funkcijo rename(). ds_jobs_select %&gt;% rename(employment_status = EmploymentStatus, current_job_title = CurrentJobTitle) ## # A tibble: 3,781 x 8 ## Gender Country Age employment_status current_job_title LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; Tibble lahko vsebuje tudi imena stolpcev, ki niso veljavna za spremenljivke v R. V tem primeru jih moramo zapisati znotraj `. Na primer, spremenljivki v R ne moremo prirediti imena z minusom. Poizkusimo to narediti v tibblu: ds_jobs_select %&gt;% rename(`employment-status` = EmploymentStatus, `current-job-title` = CurrentJobTitle) ## # A tibble: 3,781 x 8 ## Gender Country Age `employment-status` `current-job-tit~ LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 2 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt; 1.14.3 Summarise in group unpeeling Kot smo e spoznali je funkcija summarise() najbolj uporabna v kombinaciji z group_by(). Pogljemo si sedaj bolj podrobno, kaken tibble je rezultat te kombinacije. Najprej samo grupirajmo ds_jobs: ds_jobs_grouped &lt;- ds_jobs %&gt;% group_by(FormalEducation, EmploymentStatus) ds_jobs_grouped ## # A tibble: 3,781 x 19 ## # Groups: FormalEducation, EmploymentStatus [21] ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Colombia 34 Employed full-time Data Scientist Python ## 9 Male Germany 41 Independent contrac~ Data Scientist Python ## 10 Male Poland 29 Employed full-time Software Develop~ Python ## # ... with 3,771 more rows, and 13 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt;, CompensationUSD &lt;dbl&gt;, MonthlyCompUSD &lt;dbl&gt; V drugi vrstici vidimo, da je ta tibble grupiran po spremenljivkah FormalEducation in EmploymentStatus. Poglejmo kaj se zgodi, ko uporabimo summarise(): ds_jobs_summarised &lt;- ds_jobs_grouped %&gt;% summarise(Count = n()) ds_jobs_summarised ## # A tibble: 21 x 3 ## # Groups: FormalEducation [8] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows Opazimo, da je ta novi tibble grupiran samo po spremenljivki FormalEducation. Privzeto summarise() vedno odstrani zadnje grupiranje. e tega ne elimo, lahko uporabimo dodaten parameter .groups = \"keep\". ds_jobs_summarised &lt;- ds_jobs_grouped %&gt;% summarise(Count = n(), .groups = &quot;keep&quot;) ds_jobs_summarised ## # A tibble: 21 x 3 ## # Groups: FormalEducation, EmploymentStatus [21] ## FormalEducation EmploymentStatus Count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 &quot;&quot; Employed full-time 1 ## 2 &quot;Bachelor&#39;s degree&quot; Employed full-time 857 ## 3 &quot;Bachelor&#39;s degree&quot; Employed part-time 52 ## 4 &quot;Bachelor&#39;s degree&quot; Independent contractor, freelanc~ 76 ## 5 &quot;Doctoral degree&quot; Employed full-time 719 ## 6 &quot;Doctoral degree&quot; Employed part-time 26 ## 7 &quot;Doctoral degree&quot; Independent contractor, freelanc~ 50 ## 8 &quot;I did not complete any formal educa~ Employed full-time 13 ## 9 &quot;I did not complete any formal educa~ Employed part-time 2 ## 10 &quot;I did not complete any formal educa~ Independent contractor, freelanc~ 10 ## # ... with 11 more rows 1.15 Ali elite izvedeti ve? V tem poglavju smo spoznali temeljne operacije nad podatki in njihovo implementacijo v R paketu dplyr. Opis vseh funkcij v dplyr najdemo tukaj: https://dplyr.tidyverse.org/reference/index.html. Jedrnat povzetek pa je na voljo tukaj, pod poglavjem Data Transformation Cheatsheet: https://www.rstudio.com/resources/cheatsheets/. 1.16 Domaa naloga Zaeli bomo z relativno preprosto nalogo, kjer bomo ponovili osnovne ukaze iz slovnice ravnanja s podatki. Osnovna razliica programskega jezika R e vsebuje nekatere podatkovne zbirke. Z ukazom data() dobimo opis vseh zbirk. V tej nalogi bomo uporabili podatkovno zbirko mtcars: head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Za podrobneji opis podatkov uporabite pomo ?mtcars. Najprej ustvarite novo spremenljivko mtcars_tib, v katero shranite razpredelnico mtcars kot tibble. Nato vsako izmed spodnjih nalog izvedite posebej (torej v vsaki toki izvedite ukaz na mtcars_tib, ampak tako spremenjenega tibbla ne shranite nazaj v to spremenljivko), razen e je v nalogi eksplicitno navedeno drugae. Vae naloge so sledee: Ustvarite novo spremenljivko mtcars_tib, v katero shranite razpredelnico mtcars kot tibble. Izberite vse vrstice avtomobilov z avtomatskim menjalnikom. ## # A tibble: 19 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 2 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 3 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 5 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 6 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 7 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 8 17.8 6 168. 123 3.92 3.44 18.9 1 0 4 4 ## 9 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 10 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## 11 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 ## 12 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 13 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 14 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## 15 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 16 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 ## 17 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 ## 18 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 19 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 Izberite vse vrstice, kjer je poraba manja od 15 galon na miljo ali veja od 20 galon na miljo in je motor oblike V. ## # A tibble: 8 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 4 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 5 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 6 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## 7 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 8 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 Izberite vse stolpce, kjer ime stolpca vsebuje rko a. ## # A tibble: 32 x 4 ## drat am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.9 1 4 4 ## 2 3.9 1 4 4 ## 3 3.85 1 4 1 ## 4 3.08 0 3 1 ## 5 3.15 0 3 2 ## 6 2.76 0 3 1 ## 7 3.21 0 3 4 ## 8 3.69 0 4 2 ## 9 3.92 0 4 2 ## 10 3.92 0 4 4 ## # ... with 22 more rows Izberite zadnje 4 stolpce. ## # A tibble: 32 x 4 ## vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 1 4 4 ## 2 0 1 4 4 ## 3 1 1 4 1 ## 4 1 0 3 1 ## 5 0 0 3 2 ## 6 1 0 3 1 ## 7 0 0 3 4 ## 8 1 0 4 2 ## 9 1 0 4 2 ## 10 1 0 4 4 ## # ... with 22 more rows V tibble mtcars_tib dodajte stolpca, kjer bosta izraunani tevilo litrov na 100 kilometrov in tea v kilogramih (v tisoicah). 1 milja je priblino 1.61 kilometra, 1 galona 3.79 litra in 1 funt 0.45 kilograma. ## # A tibble: 32 x 4 ## mpg wt lp100km wt_in_kg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 2.62 11.2 1.18 ## 2 21 2.88 11.2 1.29 ## 3 22.8 2.32 10.3 1.04 ## 4 21.4 3.22 11.0 1.45 ## 5 18.7 3.44 12.6 1.55 ## 6 18.1 3.46 13.0 1.56 ## 7 14.3 3.57 16.5 1.61 ## 8 24.4 3.19 9.65 1.44 ## 9 22.8 3.15 10.3 1.42 ## 10 19.2 3.44 12.3 1.55 ## # ... with 22 more rows Izraunajte povpreno porabo avtomobilov v odvisnosti tevila cilindrov. ## # A tibble: 3 x 2 ## cyl mean_mpg ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 Izraunajte povpreno konjsko mo v odvisnosti od oblike motorja in ali je avtomobil avtomatik ali ne. ## # A tibble: 4 x 3 ## # Groups: vs [2] ## vs am mean_hp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 194. ## 2 0 1 181. ## 3 1 0 102. ## 4 1 1 80.6 Normalizirajte vse stolpce, ki vsebujejo decimalna tevila, na interval [0, 1]. To naredimo tako, da vrednostim odtejemo minimalno vrednost in delimo z razliko med maksimalno in minimalno vrednostjo: \\[ x_i&#39; = \\frac{x_i - \\min(x)}{\\max(x) - \\min(x)}. \\] ## # A tibble: 32 x 13 ## mpg cyl disp hp drat wt qsec vs am gear carb lp100km ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.451 6 0.222 110 0.525 0.283 0.233 0 1 4 4 0.272 ## 2 0.451 6 0.222 110 0.525 0.348 0.3 0 1 4 4 0.272 ## 3 0.528 4 0.0920 93 0.502 0.206 0.489 1 1 4 1 0.215 ## 4 0.468 6 0.466 110 0.147 0.435 0.588 1 0 3 1 0.259 ## 5 0.353 8 0.721 175 0.180 0.493 0.3 0 0 3 2 0.360 ## 6 0.328 6 0.384 105 0 0.498 0.681 1 0 3 1 0.386 ## 7 0.166 8 0.721 245 0.207 0.526 0.160 0 0 3 4 0.607 ## 8 0.596 4 0.189 62 0.429 0.429 0.655 1 0 4 2 0.172 ## 9 0.528 4 0.174 95 0.535 0.419 1 1 0 4 2 0.215 ## 10 0.374 6 0.241 123 0.535 0.493 0.452 1 0 4 4 0.339 ## # ... with 22 more rows, and 1 more variable: wt_in_kg &lt;dbl&gt; Izraunajte povprene vrednosti vseh stolpcev. ## # A tibble: 1 x 13 ## mpg cyl disp hp drat wt qsec vs am gear carb lp100km ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20.1 6.19 231. 147. 3.60 3.22 17.8 0.438 0.406 3.69 2.81 12.8 ## # ... with 1 more variable: wt_in_kg &lt;dbl&gt; Teja naloga. V mapi data-raw se nahajajo podatki o gozdnih poarih na Portugalskem. Podatki so bili uporabljeni v znanstvenem lanku (Cortez and Morais 2007), kjer so napovedovali velikost poganega obmoja v odvisnosti od meteorolokih in drugih podatkov. Vrednosti 0 za pogano obmoje predstavljajo poare, kjer je pogorelo manj kot 100 kvadratnih metrov. Preberite podatke in jih shranite kot tibble. Preverite, v katerem mesecu je najve poarov in jih uredite padajoe od tistega z najve poari do tistega z najmanj. ## # A tibble: 12 x 2 ## month n ## &lt;chr&gt; &lt;int&gt; ## 1 aug 184 ## 2 sep 172 ## 3 mar 54 ## 4 jul 32 ## 5 feb 20 ## 6 jun 17 ## 7 oct 15 ## 8 apr 9 ## 9 dec 9 ## 10 jan 2 ## 11 may 2 ## 12 nov 1 Preverite, ali obstajajo obmoja v parku, kjer se bolj pogosto pojavljajo poari. Za vsako kombinacijo koordinat bomo torej izraunali tevilo poarov. Rezultat lahko predstavimo z razpredelnico. Glede na to, da imamo dvodimenzionalne podatke, bi jih morda bilo smiselno predstaviti vizualno. V kolikor poznate paket ggplot2, predlagamo da si pogledate funkcijo geom_tile(). ## # A tibble: 36 x 3 ## X Y n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2 19 ## 2 1 3 10 ## 3 1 4 15 ## 4 1 5 4 ## 5 2 2 25 ## 6 2 3 1 ## 7 2 4 27 ## 8 2 5 20 ## 9 3 3 1 ## 10 3 4 43 ## # ... with 26 more rows Dodajte stolpec, ki bo za vsak poar izraunal dele poganega obmoja glede na vse poare na posameznih koordinatah. Za tem smiselno filtrirajte podatke (ali smo v novem stolpcu dobili kakne nepriakovane, oziroma neveljavne vrednosti?). ## # A tibble: 509 x 5 ## X Y month day area_by_coord ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 7 5 mar fri 0 ## 2 7 4 oct tue 0 ## 3 7 4 oct sat 0 ## 4 8 6 mar fri 0 ## 5 8 6 mar sun 0 ## 6 8 6 aug sun 0 ## 7 8 6 aug mon 0 ## 8 8 6 aug mon 0 ## 9 8 6 sep tue 0 ## 10 7 5 sep sat 0 ## # ... with 499 more rows Preverite, ali ob vroem vremenu in nizki vlanosti pogori veji dele obmoja, ki smo ga izraunali v prejnji toki, tako da izberete vrstice, kjer je temperatura vija od 0.8 kvantila temperature in vlanost nija od 0.2 kvantila vlanosti ter izraunate povpreje. \\(q\\)-ti kvantil je ocena tevila, za katerega velja, da je \\(q\\) vrednosti manjih od tega tevila. Za raunanje kvantilov uporabite funkcijo quantile(). Za primerjavo izraunajte e povpreje te spremenljivke za vse preostale vrstice. Ali se rezultati skladajo z vao intuicijo? ## # A tibble: 1 x 1 ## mean_area_by_coord ## &lt;dbl&gt; ## 1 0.153 ## # A tibble: 1 x 1 ## mean_area_by_coord ## &lt;dbl&gt; ## 1 0.0555 Izraunajte povpreje standardiziranih indeksov in ga vstavite kot stolpec pred prvo spremenljivko, ki predstavlja indeks. ## # A tibble: 509 x 15 ## # Rowwise: ## X Y month day mean_indices FFMC_index DMC_index DC_index ISI_index ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 5 mar fri -1.21 -0.796 -1.32 -1.86 -0.859 ## 2 7 4 oct tue -0.304 -0.00502 -1.18 0.480 -0.510 ## 3 7 4 oct sat -0.254 -0.00502 -1.05 0.552 -0.510 ## 4 8 6 mar fri -0.739 0.193 -1.21 -1.92 -0.00890 ## 5 8 6 mar sun -0.719 -0.239 -0.934 -1.82 0.122 ## 6 8 6 aug sun 0.218 0.301 -0.405 -0.256 1.23 ## 7 8 6 aug mon -0.0979 0.301 -0.349 -0.225 -0.118 ## 8 8 6 aug mon 0.320 0.157 0.530 0.232 0.361 ## 9 8 6 sep tue 0.120 0.0669 0.283 0.575 -0.445 ## 10 7 5 sep sat 0.0375 0.337 -0.363 0.599 -0.423 ## # ... with 499 more rows, and 6 more variables: temp &lt;dbl&gt;, RH &lt;dbl&gt;, ## # wind &lt;dbl&gt;, rain &lt;dbl&gt;, area &lt;dbl&gt;, area_by_coord &lt;dbl&gt; "],["urejeni-in-relacijski-podatki.html", "Poglavje 2 Urejeni in relacijski podatki 2.1 Priprava 2.2 Urejeni podatki 2.3 pivot_longer(): pretvorba v daljo obliko 2.4 pivot_wider(): pretvorba v iro obliko 2.5 separate() in unite(): deljenje in zdruevanje stolpcev 2.6 Relacijske zbirke podatkov 2.7 Primer: Banni podatki 2.8 Kljui 2.9 Zdruevanja 2.10 Operacije nad mnoicami 2.11 Ali elite izvedeti ve? 2.12 Domaa naloga", " Poglavje 2 Urejeni in relacijski podatki Pri kakrnemkoli delu smo obiajno zelo ciljno naravnani. Dobimo nalogo in jo elimo imprej in imbolje opraviti. Z namenom uinkovitosti se obiajno posluimo znanih orodij in postopkov, ki jih prilagodimo samemu problemu. Pri delu s podatki se ciljna naravnanost obiajno izrazi tako, da elimo imprej priti do analize in zakljukov, samemu urejanju podatkov pa ne posvetimo pretirane pozornosti, oziroma le toliko, kot je nujno potrebno (kar je e vedno lahko dolgotrajno). Na kratek rok to deluje v redu in celo prihranimo nekaj asa. Na dolgi rok pa obiajno zahteva veliko ve asa, saj se moramo pri vsaki novi nalogi na novo prilagajati podatkom. Bolji pristop bi bil, da bi problem prilagodili ustaljenemu postopku. Obiajno lahko veino podatkov uredimo do te mere, da so si po obliki podobni. V kolikor se nauimo narediti to za neko splono podatkovno zbirko, lahko potem vsaki pristopimo do nadaljnjega dela na podoben nain. V praksi s tem na dolgi rok prihranimo veliko asa. Koncept urejenih podatkov (ang. tidy data), ki ga bomo spoznali v tem poglavju, je formalizacija intuitivne predstavke kaj podatki so. Podatke, ki so urejeni, lahko veliko laje transformiramo in pripravimo na nadaljnjo analizo. Tudi funkcije v tidyverse so implementirane tako, da na vhod prejmejo urejene podatke in takne tudi vrnejo. Z drugimi besedami ohranjajo urejenost. Relacijski podatki pa so podatki o razlinih entitetah (na primer podjetje, delavec, slubeno vozilo, klient), ki so shranjeni v razlinih razpredelnicah. Kadar elimo analizirati relacijske podatke moramo razumeti povezave med njimi in kako delati z njimi. Spoznali bomo koncept relacijskih podatkovnih zbirk in kako uporabiti tidyverse za delo z njimi. 2.1 Priprava V tem poglavju bomo spoznali, kako podatke pretvorimo iz dalje v krajo obliko (in obratno) ter kako delamo z relacijskimi podatki. Kaj vsi ti koncepti pomenijo in kako so povezani z urejenimi podatki, bomo predelali v jedru poglavja. Pri pretvorbi podatkov v daljo obliko gre za pretvorbo, kjer vrednosti veih stolpcev zdruimo v en stolpec. Poglejmo si razpredelnico, kjer imamo shranjene podatke za ve let: df &lt;- tibble( ime = c(&quot;Mojca&quot;, &quot;Miha&quot;, &quot;Mateja&quot;), `2018` = c(5.5, 4.6, 8.7), `2019` = c(5.8, 4.2, 9) ) df ## # A tibble: 3 x 3 ## ime `2018` `2019` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mojca 5.5 5.8 ## 2 Miha 4.6 4.2 ## 3 Mateja 8.7 9 Recimo, da elimo stolpca z leti spraviti v en stolpec. Uporabimo funkcijo pivot_longer(). df_longer &lt;- pivot_longer(df, c(`2018`, `2019`), names_to = &quot;leto&quot;, values_to = &quot;rezultat&quot;) df_longer ## # A tibble: 6 x 3 ## ime leto rezultat ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mojca 2018 5.5 ## 2 Mojca 2019 5.8 ## 3 Miha 2018 4.6 ## 4 Miha 2019 4.2 ## 5 Mateja 2018 8.7 ## 6 Mateja 2019 9 Lahko naredimo tudi obratno transformacijo, torej da vrednosti enega stolpca razirimo v ve stolpcev. Na primer, razirimo stolpec ime: pivot_wider(df_longer, names_from = ime, values_from = rezultat) ## # A tibble: 2 x 4 ## leto Mojca Miha Mateja ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2018 5.5 4.6 8.7 ## 2 2019 5.8 4.2 9 Naloga: Spodnjo razpredelnico transformirajte v daljo obliko, tako da informacije o tevilu oddelkov shranite v 1 stolpec. df &lt;- tibble( podjetje = c(&quot;Podjetje A&quot;, &quot;Podjetje A&quot;, &quot;Podjetje B&quot;), kraj_tovarne = c(&quot;Koper&quot;, &quot;Kranj&quot;, &quot;Koper&quot;), prihodek = c(100000, 120000, 60000), razvojni_oddelki = c(2, 3, 1), prodajni_oddelki = c(3, 3, 2) ) df ## # A tibble: 3 x 5 ## podjetje kraj_tovarne prihodek razvojni_oddelki prodajni_oddelki ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Podjetje A Koper 100000 2 3 ## 2 Podjetje A Kranj 120000 3 3 ## 3 Podjetje B Koper 60000 1 2 Reitev: ## # A tibble: 6 x 5 ## podjetje kraj_tovarne prihodek oddelek stevilo_oddelkov ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Podjetje A Koper 100000 razvojni_oddelki 2 ## 2 Podjetje A Koper 100000 prodajni_oddelki 3 ## 3 Podjetje A Kranj 120000 razvojni_oddelki 3 ## 4 Podjetje A Kranj 120000 prodajni_oddelki 3 ## 5 Podjetje B Koper 60000 razvojni_oddelki 1 ## 6 Podjetje B Koper 60000 prodajni_oddelki 2 Spoznali bomo tudi relacijske podatke, pri katerih so podatki razdeljeni med ve razpredelnic. Zato bomo potrebovali ve funkcij, ki nam omogoajo zdruevanje teh razpredelnic. Poglejmo si dve razpredelnici: ekipe &lt;- tibble( id_ekipe = c(1, 2, 3, 4), ekipa = c(&quot;Liverpool&quot;, &quot;Manchester United&quot;, &quot;Arsenal&quot;, &quot;Rokova ekipa&quot;) ) igralci &lt;- tibble( id_igralca = c(1, 2, 3, 4, 5, 6, 7), ime = c(&quot;Henderson&quot;, &quot;Fernandes&quot;, &quot;Alisson&quot;, &quot;Rashford&quot;, &quot;Novak&quot;, &quot;Aubameyang&quot;, &quot;Vega&quot;), id_ekipe = c(1, 2, 1, 2, 8, 3, 8) ) ekipe ## # A tibble: 4 x 2 ## id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Liverpool ## 2 2 Manchester United ## 3 3 Arsenal ## 4 4 Rokova ekipa igralci ## # A tibble: 7 x 3 ## id_igralca ime id_ekipe ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 Henderson 1 ## 2 2 Fernandes 2 ## 3 3 Alisson 1 ## 4 4 Rashford 2 ## 5 5 Novak 8 ## 6 6 Aubameyang 3 ## 7 7 Vega 8 Za zdruevanje razpredelnic obstaja ve funkcij, vse imajo konnico _join. Poglejmo si, kako jih kliemo in kaj vsaka izmed njih naredi. Ve bomo o njih povedali na predavanju. left_join() zdrui razpredelnici tako, da obdri vse primere iz prve razpredelnice: left_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 7 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 5 Novak 8 &lt;NA&gt; ## 6 6 Aubameyang 3 Arsenal ## 7 7 Vega 8 &lt;NA&gt; right_join() zdrui razpredelnici tako, da obdri vse primere iz druge razpredelnice: right_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 6 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 6 Aubameyang 3 Arsenal ## 6 NA &lt;NA&gt; 4 Rokova ekipa inner_join() zdrui razpredelnici tako, da obdri samo primere, ki se pojavijo v obeh razpredelnicah: inner_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 5 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 6 Aubameyang 3 Arsenal full_join() zdrui razpredelnici tako, da obdri vse primere iz obeh razpredelnic: full_join(igralci, ekipe, by = &quot;id_ekipe&quot;) ## # A tibble: 8 x 4 ## id_igralca ime id_ekipe ekipa ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Henderson 1 Liverpool ## 2 2 Fernandes 2 Manchester United ## 3 3 Alisson 1 Liverpool ## 4 4 Rashford 2 Manchester United ## 5 5 Novak 8 &lt;NA&gt; ## 6 6 Aubameyang 3 Arsenal ## 7 7 Vega 8 &lt;NA&gt; ## 8 NA &lt;NA&gt; 4 Rokova ekipa Naloga: Obstajata e dve operaciji zdruevanja, ki pa ne delujeta popolnoma enako kot zgornje funkcije. Pokliite funkciji semi_join() in anti_join() in poizkusite ugotoviti, kaj sta ti funkciji naredili. Sintaksa je enaka kot pri ostalih funkcijah join. Za branje podatkov iz tekstovnih datotek velikokrat uporabljamo funkcijo read.csv() ali katero od preostalih izpeljank funkcije read.table(). Tidyverse ima svojo razliico teh funkcij, ki pa imajo nekaj dodatne funkcionalnosti. Najbolj pomembna je ta, da se podatki samodejno shranijo kot tibble. To omogoa relativno enostavno branje datotek, kjer stolpci niso poimenovani v skladu s pravili programskega jezika R (na primer, lahko se zanejo s tevilom, lahko imajo minuse, presledke in podobno). Kot smo omenili shranjevanje podatkov, kjer imena stolpcev niso standardne oblike, ni dobra praksa. Vsekakor pa se pri realnih podatkih velikokrat zgodi, da imamo takna imena. V tem primeru je bolje, da jih prebermo takna kot so in jih programsko spremenimo, saj s tem ne posegamo v izvirne podatke. Je pa potrebno pri teh funkcijah dodatno nastaviti kodiranje, da znajo prebrati umnike. Poglejmo si uporabo funkcije read_csv2() paketa readr, kjer bomo ustrezno nastavili kodiranje. df &lt;- read_csv2(&quot;./data-raw/SLO-gradbena-dovoljenja-messy1.csv&quot;, locale = readr::locale(encoding = &quot;cp1250&quot;)) Ve o kodiranjih bomo povedali na zadnjem predavanju. 2.2 Urejeni podatki Omenili smo e, da se v praksi sreamo z najrazlinejimi oblikami zapisov podatkov. Skupek paketov tidyverse je namenjen delu s tako imenovanimi urejenimi podatki (ang. tidy data). Ideja je, da se ustvari enoten standard za obliko podatkov, s katero je laje delati. V kolikor se drimo tega standarda pri vseh naih analizah, nam to omogoa, da vedno uporabljamo ista orodja (na primer, ggplot2) in se nam ni potrebno uiti novih orodij za vsako analizo. Standard lahko povzamemo s 3 lastnostmi: vsak stolpec je spremenljivka, vsaka vrstica je primer podatka, vsaka vrednost ima svojo celico. Morda se na tej toki to slii nekoliko abstraktno. Poglejmo si praktien primer. Nabrali smo podatke o tevilu izdanih gradbenih dovoljenj v Sloveniji, razdeljeno glede na obine. Podatke smo prenesli s spletne strani statistinega urada Slovenije https://pxweb.stat.si/SiStat/slshranili in jih shranili na ve nainov. Najprej si poglejmo podatke v takni obliki, kot smo jih dobili naravnost iz vira. ## # A tibble: 424 x 16 ## OBINE TIP.STAVBE `2007` `2008` `2009` `2010` `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdov~ Stanovanjsk~ 52 55 45 33 52 40 29 30 ## 2 Ajdov~ Nestanovanj~ 19 9 22 15 27 11 23 11 ## 3 Ankaran~ Stanovanjsk~ NA NA NA NA NA NA NA NA ## 4 Ankaran~ Nestanovanj~ NA NA NA NA NA NA NA NA ## 5 Apae Stanovanjsk~ 10 11 22 12 7 5 9 10 ## 6 Apae Nestanovanj~ 3 3 8 3 4 6 2 3 ## 7 Beltinci Stanovanjsk~ 16 19 11 15 19 14 5 13 ## 8 Beltinci Nestanovanj~ 4 6 1 3 8 4 4 5 ## 9 Benedikt Stanovanjsk~ 11 12 6 9 7 3 16 10 ## 10 Benedikt Nestanovanj~ 3 2 1 3 5 3 4 3 ## # ... with 414 more rows, and 6 more variables: 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt;, ## # 2017 &lt;dbl&gt;, 2018 &lt;dbl&gt;, 2019 &lt;dbl&gt;, 2020 &lt;dbl&gt; Najprej imamo na voljo spremenljivki OBINE in TIP.STAVBE. Potem pa imamo za vsako leto natete vrednosti, oziroma tevila gradbenih dovoljenj. Podatki so velikokrat shranjeni v taknem formatu, saj ima doloene prednosti. Tak format je bolj prijazen za prikaz loveku, saj lahko samo s pogledom na razpredelnico hitro oceni, ali obstaja trend v posamezni vrstici. Format pa ni najbolji za delo s podatki. Govorili smo e o istih podatkih in da vse funkcije v tidyverse podpirajo operacije nad taknimi podatki. Kot vhod bo veina teh funkcij prejela iste podatke in takne potem tudi vrnila. Kaj je razlog, da ti podatki niso isti? Ne dri, da imamo v vsakem stolpcu spremenljivko, saj imamo eno spremenljivko razvleeno ez ve stolpcev  leto. Ta podatek vsekakor predstavlja spremenljivko, torej bi moral imeti enoten stolpec. Poglejmo si te podatke e v dveh neistih formatih. ## # A tibble: 28 x 214 ## TIP.STAVBE Leto Ajdovina `Ankaran/Ancaran~ Apae Beltinci Benedikt ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Stanovanjske stav~ 2007 52 NA 10 16 11 ## 2 Stanovanjske stav~ 2008 55 NA 11 19 12 ## 3 Stanovanjske stav~ 2009 45 NA 22 11 6 ## 4 Stanovanjske stav~ 2010 33 NA 12 15 9 ## 5 Stanovanjske stav~ 2011 52 NA 7 19 7 ## 6 Stanovanjske stav~ 2012 40 NA 5 14 3 ## 7 Stanovanjske stav~ 2013 29 NA 9 5 16 ## 8 Stanovanjske stav~ 2014 30 NA 10 13 10 ## 9 Stanovanjske stav~ 2015 38 3 12 23 13 ## 10 Stanovanjske stav~ 2016 31 1 10 22 15 ## # ... with 18 more rows, and 207 more variables: Bistrica ob Sotli &lt;dbl&gt;, ## # Bled &lt;dbl&gt;, Bloke &lt;dbl&gt;, Bohinj &lt;dbl&gt;, Borovnica &lt;dbl&gt;, Bovec &lt;dbl&gt;, ## # Braslove &lt;dbl&gt;, Brda &lt;dbl&gt;, Brezovica &lt;dbl&gt;, Breice &lt;dbl&gt;, Cankova &lt;dbl&gt;, ## # Celje &lt;dbl&gt;, Cerklje na Gorenjskem &lt;dbl&gt;, Cerknica &lt;dbl&gt;, Cerkno &lt;dbl&gt;, ## # Cerkvenjak &lt;dbl&gt;, Cirkulane &lt;dbl&gt;, renovci &lt;dbl&gt;, rna na Korokem &lt;dbl&gt;, ## # rnomelj &lt;dbl&gt;, Destrnik &lt;dbl&gt;, Divaa &lt;dbl&gt;, Dobje &lt;dbl&gt;, ## # Dobrepolje &lt;dbl&gt;, Dobrna &lt;dbl&gt;, Dobrova - Polhov Gradec &lt;dbl&gt;, ## # Dobrovnik/Dobronak &lt;dbl&gt;, Dol pri Ljubljani &lt;dbl&gt;, Dolenjske Toplice &lt;dbl&gt;, ## # Domale &lt;dbl&gt;, Dornava &lt;dbl&gt;, Dravograd &lt;dbl&gt;, Duplek &lt;dbl&gt;, ## # Gorenja vas - Poljane &lt;dbl&gt;, Gorinica &lt;dbl&gt;, Gorje &lt;dbl&gt;, ## # Gornja Radgona &lt;dbl&gt;, Gornji Grad &lt;dbl&gt;, Gornji Petrovci &lt;dbl&gt;, Grad &lt;dbl&gt;, ## # Grosuplje &lt;dbl&gt;, Hajdina &lt;dbl&gt;, Hoe - Slivnica &lt;dbl&gt;, Hodo/Hodos &lt;dbl&gt;, ## # Horjul &lt;dbl&gt;, Hrastnik &lt;dbl&gt;, Hrpelje - Kozina &lt;dbl&gt;, Idrija &lt;dbl&gt;, ## # Ig &lt;dbl&gt;, Ilirska Bistrica &lt;dbl&gt;, Ivanna Gorica &lt;dbl&gt;, Izola/Isola &lt;dbl&gt;, ## # Jesenice &lt;dbl&gt;, Jezersko &lt;dbl&gt;, Jurinci &lt;dbl&gt;, Kamnik &lt;dbl&gt;, Kanal &lt;dbl&gt;, ## # Kidrievo &lt;dbl&gt;, Kobarid &lt;dbl&gt;, Kobilje &lt;dbl&gt;, Koevje &lt;dbl&gt;, Komen &lt;dbl&gt;, ## # Komenda &lt;dbl&gt;, Koper/Capodistria &lt;dbl&gt;, Kostanjevica na Krki &lt;dbl&gt;, ## # Kostel &lt;dbl&gt;, Kozje &lt;dbl&gt;, Kranj &lt;dbl&gt;, Kranjska Gora &lt;dbl&gt;, ## # Krievci &lt;dbl&gt;, Krko &lt;dbl&gt;, Kungota &lt;dbl&gt;, Kuzma &lt;dbl&gt;, Lako &lt;dbl&gt;, ## # Lenart &lt;dbl&gt;, Lendava/Lendva &lt;dbl&gt;, Litija &lt;dbl&gt;, Ljubljana &lt;dbl&gt;, ## # Ljubno &lt;dbl&gt;, Ljutomer &lt;dbl&gt;, Log - Dragomer &lt;dbl&gt;, Logatec &lt;dbl&gt;, ## # Loka dolina &lt;dbl&gt;, Loki Potok &lt;dbl&gt;, Lovrenc na Pohorju &lt;dbl&gt;, ## # Lue &lt;dbl&gt;, Lukovica &lt;dbl&gt;, Majperk &lt;dbl&gt;, Makole &lt;dbl&gt;, Maribor &lt;dbl&gt;, ## # Markovci &lt;dbl&gt;, Medvode &lt;dbl&gt;, Menge &lt;dbl&gt;, Metlika &lt;dbl&gt;, Meica &lt;dbl&gt;, ## # Miklav na Dravskem polju &lt;dbl&gt;, Miren - Kostanjevica &lt;dbl&gt;, Mirna &lt;dbl&gt;, ## # Mirna Pe &lt;dbl&gt;, Mislinja &lt;dbl&gt;, ... Sedaj imamo podobno situacijo kot prej  ena spremenljivka je razvleena preko ve stolpcev  v tem primeru je to obina. Kot smo e omenili, so vsaki neisti podatki neisti na svoj nain. Podatki so popolnoma enaki kot v prejnjem prikazu, ampak razpredelnica izgleda popolnoma drugae. isti podatki pa imajo samo eno pravilno obliko, torej ne more priti do taknih dvoumnih prikazov. Poglejmo si e tretji format: ## # A tibble: 5,936 x 3 ## OBINA_TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina_Stanovanjske stavbe 2007 52 ## 2 Ajdovina_Stanovanjske stavbe 2008 55 ## 3 Ajdovina_Stanovanjske stavbe 2009 45 ## 4 Ajdovina_Stanovanjske stavbe 2010 33 ## 5 Ajdovina_Stanovanjske stavbe 2011 52 ## 6 Ajdovina_Stanovanjske stavbe 2012 40 ## 7 Ajdovina_Stanovanjske stavbe 2013 29 ## 8 Ajdovina_Stanovanjske stavbe 2014 30 ## 9 Ajdovina_Stanovanjske stavbe 2015 38 ## 10 Ajdovina_Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Ta je morda nekoliko blije istim podatkom, kot prejnja dva, ampak e vedno ni v popolnoma pravilni obliki. V em je teava? Dve spremenljivki imamo podani v enem stolpcu  obino in tip. Ker gre za razlini spremenljivki, bi bilo dobro, da se pojavita v razlinih stolpcih. Poglejmo si sedaj e iste podatke: ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Sedaj ima vsaka spremenljivka (obina, tip in leto) svoj stolpec, zadnji stolpec pa je namenjen vrednostim. V tem poglavju se bomo nauili neiste podatke spremeniti v iste. isti podatki imajo obiajno ve vrstic kot neisti in jim zato pravimo da so dalji (ang. longer). Neisti pa so obiajno iri (ang. wider). Izogibamo se besedam dolgi in iroki, saj je ta definicija relativna, se pravi lahko uporabimo transformacijo, ki naredi podatke dalje, ne pa nujno dolge, saj morda obstaja e kakna operacija, ki jih bo naredila e dalje. 2.3 pivot_longer(): pretvorba v daljo obliko Funkcija pivot_longer() podatke spremeni v daljo obliko. Ta trasformacija je pri delu s podatki bolj pogosta kot sprememba v iro. Obiajno uporabljamo to transformacijo, ko preurejamo podatke v iste. Poglejmo si ponovno neiste podatke, ki smo jih dobili naravnost iz vira: ## # A tibble: 424 x 16 ## OBINE TIP.STAVBE `2007` `2008` `2009` `2010` `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdov~ Stanovanjsk~ 52 55 45 33 52 40 29 30 ## 2 Ajdov~ Nestanovanj~ 19 9 22 15 27 11 23 11 ## 3 Ankaran~ Stanovanjsk~ NA NA NA NA NA NA NA NA ## 4 Ankaran~ Nestanovanj~ NA NA NA NA NA NA NA NA ## 5 Apae Stanovanjsk~ 10 11 22 12 7 5 9 10 ## 6 Apae Nestanovanj~ 3 3 8 3 4 6 2 3 ## 7 Beltinci Stanovanjsk~ 16 19 11 15 19 14 5 13 ## 8 Beltinci Nestanovanj~ 4 6 1 3 8 4 4 5 ## 9 Benedikt Stanovanjsk~ 11 12 6 9 7 3 16 10 ## 10 Benedikt Nestanovanj~ 3 2 1 3 5 3 4 3 ## # ... with 414 more rows, and 6 more variables: 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt;, ## # 2017 &lt;dbl&gt;, 2018 &lt;dbl&gt;, 2019 &lt;dbl&gt;, 2020 &lt;dbl&gt; Sedaj elimo te podatke spremeniti v isto obliko. Vse stolpce, ki prikazujejo razline vrednosti spremenljivke leto, moramo zapisati v 1 stolpec. Uporabimo funkcijo pivot_longer(), ki prejme argumente: data. Katere podatke elimo spremeniti. cols. V katerih stolpcih imamo vrednosti spremenljivke, ki jo elimo shraniti v 1 stolpec. df %&gt;% pivot_longer(cols = `2007`:`2020`) ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE name value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Sedaj imamo leta shranjena v stolpcu, prav tako pa vrednosti. Stolpca sta dobila privzeti meni name in value. Funkcija pivot_longer() pa lahko prejme e ve opcijskih argumentov, za nas bosta najbolj pomembna 2: names_to. Ime stolpca, v katerega bomo shranili spremenljivko. value_to. Ime stolpca, v katerega bomo shranili vrednosti. Uporabimo sedaj e ta 2 parametra: df_longer &lt;- df %&gt;% pivot_longer(cols = `2007`:`2020`, names_to = &quot;Leto&quot;, values_to = &quot;tevilo&quot;) df_longer ## # A tibble: 5,936 x 4 ## OBINE TIP.STAVBE Leto tevilo ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows 2.4 pivot_wider(): pretvorba v iro obliko Obiajno bo ta transformacija naredila podatke neiste, vendar s tem ni ni narobe, saj imajo tudi takni podatki svoje prednosti: Podatki v iri obliki so loveku laje berljivi. Nekatera podjetja in podroja imajo razvite standarde, v katerih potrebujemo podatke v iri obliki. Nekatere metode, predvsem gre tukaj za metode strojnega uenja, delujejo bolje ali izkljuno s podatki v iri obliki. e elimo podatke pretvoriti v matriko. Za pretvorbo podatkov v iro obliko uporabimo funkcijo pivot_wider(), ki prejme dva argumenta: names_from. Ime stolpca, katerga elimo raztegniti v iro obliko. values_from. Ime stolpca, v katerem so shranjene vrednosti. Pretvorimo sedaj df_longer v iro obliko glede na stolpec TIP.STAVBE. df_wider &lt;- df_longer %&gt;% pivot_wider(names_from = TIP.STAVBE, values_from = tevilo) df_wider[1:14, ] ## # A tibble: 14 x 4 ## OBINE Leto `Stanovanjske stavbe` `Nestanovanjske stavbe` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina 2007 52 19 ## 2 Ajdovina 2008 55 9 ## 3 Ajdovina 2009 45 22 ## 4 Ajdovina 2010 33 15 ## 5 Ajdovina 2011 52 27 ## 6 Ajdovina 2012 40 11 ## 7 Ajdovina 2013 29 23 ## 8 Ajdovina 2014 30 11 ## 9 Ajdovina 2015 38 49 ## 10 Ajdovina 2016 31 66 ## 11 Ajdovina 2017 33 60 ## 12 Ajdovina 2018 42 36 ## 13 Ajdovina 2019 38 39 ## 14 Ajdovina 2020 42 46 S taknim prikazom lahko relativno hitro opazimo doloene trende. Na primer v Ajdovini se je gradilo veliko ve stanovanjskih stavb med leti 2007 in 2014, leta 2015 pa se je oitno zaelo graditi ve nestanovanjskih stavb, kar bi lahko nakazovalo na gospodarsko rast tega mesta. Za loveka je torej tak prikaz bolji. Vsekakor pa bi v tem primeru raje uporabili vizualizacijo. 2.5 separate() in unite(): deljenje in zdruevanje stolpcev V uvodu tega poglavja smo prikazali podatke, kjer sta bili dve spremenljivki shranjeni v enem stolpcu. Poglejmo si te podatke e enkrat: df &lt;- read_csv2(&quot;./data-raw/SLO-gradbena-dovoljenja-messy2.csv&quot;, locale = readr::locale(encoding = &quot;cp1250&quot;)) df ## # A tibble: 5,936 x 3 ## OBINA_TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina_Stanovanjske stavbe 2007 52 ## 2 Ajdovina_Stanovanjske stavbe 2008 55 ## 3 Ajdovina_Stanovanjske stavbe 2009 45 ## 4 Ajdovina_Stanovanjske stavbe 2010 33 ## 5 Ajdovina_Stanovanjske stavbe 2011 52 ## 6 Ajdovina_Stanovanjske stavbe 2012 40 ## 7 Ajdovina_Stanovanjske stavbe 2013 29 ## 8 Ajdovina_Stanovanjske stavbe 2014 30 ## 9 Ajdovina_Stanovanjske stavbe 2015 38 ## 10 Ajdovina_Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Vasih se sreamo celo z dvema vrednostima v istem stolpcu. Da loimo ti spremenljivki na dva stolpca uporabimo funkcijo separate(): separate(&lt;podatki&gt;, col = &lt;ime-stolpca&gt;, into = &lt;ime-novih-stolpcev&gt;, sep = &lt;znak-ki-locuje&gt;) Uporabimo sedaj to funkcijo da pretvorimo df v isto obliko: df_tidy &lt;- df %&gt;% separate(col = &quot;OBINA_TIP&quot;, into = c(&quot;OBINA&quot;, &quot;TIP&quot;), sep = &quot;_&quot;) df_tidy ## # A tibble: 5,936 x 4 ## OBINA TIP Leto tevilo.gradbenih.dovoljenj ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ajdovina Stanovanjske stavbe 2007 52 ## 2 Ajdovina Stanovanjske stavbe 2008 55 ## 3 Ajdovina Stanovanjske stavbe 2009 45 ## 4 Ajdovina Stanovanjske stavbe 2010 33 ## 5 Ajdovina Stanovanjske stavbe 2011 52 ## 6 Ajdovina Stanovanjske stavbe 2012 40 ## 7 Ajdovina Stanovanjske stavbe 2013 29 ## 8 Ajdovina Stanovanjske stavbe 2014 30 ## 9 Ajdovina Stanovanjske stavbe 2015 38 ## 10 Ajdovina Stanovanjske stavbe 2016 31 ## # ... with 5,926 more rows Obstaja pa tudi obratna operacija unite(), ki zdrui dva stolpca: unite(&lt;podatki&gt;, &lt;stolpec1&gt;, &lt;stolpec2&gt;, ..., sep = &lt;znak-ki-locuje&gt;) Pri tem tri pikice prestavljajo morebitne preostale stolpce, saj jih lahko zdruimo ve. Za primer si poglejmo, kako bi v eno spremenljivko shranili podatke o tevilu stanovanjskih in nestanovanjskih gradbenih dovoljenj. Najprej pretvorimo podatke v iro obliko glede na tip, potem pa ta nova stolpca zdruimo s funkcijo unite(). df_wider &lt;- df_tidy %&gt;% pivot_wider(names_from = TIP, values_from = tevilo.gradbenih.dovoljenj) %&gt;% unite(&quot;Stanovanjske/Nestanovanjske&quot;, &quot;Stanovanjske stavbe&quot;, &quot;Nestanovanjske stavbe&quot;, sep = &quot;/&quot;) df_wider ## # A tibble: 2,968 x 3 ## OBINA Leto `Stanovanjske/Nestanovanjske` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Ajdovina 2007 52/19 ## 2 Ajdovina 2008 55/9 ## 3 Ajdovina 2009 45/22 ## 4 Ajdovina 2010 33/15 ## 5 Ajdovina 2011 52/27 ## 6 Ajdovina 2012 40/11 ## 7 Ajdovina 2013 29/23 ## 8 Ajdovina 2014 30/11 ## 9 Ajdovina 2015 38/49 ## 10 Ajdovina 2016 31/66 ## # ... with 2,958 more rows 2.6 Relacijske zbirke podatkov Pogosto se pri analizi podatkov sreamo z razpredelnicami, ki so med seboj logino povezane. Nekaj primerov: V spletni trgovini lahko hranimo podatke v 3 razpredelnicah o produktih, kupcih in nakupih. Razpredelnice so med seboj povezane, na primer razpredelnica o nakupih vsebuje ID kupca in produkta. Baze podatkov o filmih, kot je IMDB, imajo na primer podatke o filmih, ocenjevalcih, igralcih in ocenah. Filmi povezujejo vse preostale razpredelnice. Bioloke podatkovne zbirke lahko imajo razpredelnice atomov, molekul in vezi. Pri eleznikem omreju imamo razpredelnice z vlaki, vagoni, eleznikimi postajami, prihodi in odhodi. Pri nogometu imamo razpredelnice z igralci, klubi in odigranimi tekmami. Taknim podatkovnim zbirkam pravimo relacijske zbirke podatkov, saj so poleg podatkov v razpredelnicah pomembne tudi relacije oziroma povezave med razpredelnicami. Zaenkrat smo se nauili, kako urejati podatke v eni razpredelnici. e elimo analizirati relacijske podatke, moramo znati upotevati tudi povezave med njimi in jih ustrezno zdruevati. V tem poglavju bomo predelali operacije, ki nam to omogoajo. Morda ste se e sreali z jezikom SQL, ki se obiajno uporablja za urejanje podatkov v sistemih za upravljanje relacijskih podatkovnih baz (ang. relational database management systems, RDBMS). Paket dplyr ima podobno sintakso kot SQL, vendar pa ni popolnoma enaka. Je tudi enostavneji za uporabo pri analizi podatkov, saj je ustvarjen prav s tem namenom. 2.7 Primer: Banni podatki V tem poglavju bomo delali s podatki eke banke (https://data.world/lpetrocelli/czech-financial-dataset-real-anonymized-transactions, https://relational.fit.cvut.cz/dataset/Financial). Gre za realno anonimizirano podatkovno zbirko, ki je bila uporabljena v izzivu PKDD99 Discovery Challenge (https://sorry.vse.cz/~berka/challenge/pkdd1999/berka.htm). Cilj izziva je bil odkriti dobre in slabe kliente z namenom izboljanja ponudbe. Mi bomo te podatke uporabili za ilustracijo operacij na relacijski zbirki podatkov. V mapi data_raw/financial se nahaja 5 razpredelnic v csv formatu: account.csv, client.csv, disp.csv, loan.csv in transaction-smaller.csv. Izvirni podatki vsebujejo e nekaj razpredelnic, vendar jih bomo z namenom uinkovitega prikaza izpustili. Prav tako smo pri razpredelnici transaction.csv nakljuno izbrali 20000 vrstic, saj originalna datoteka vsebuje preko milijon vrstic, kar bi upoasnilo izvajanje ukazov in zasedlo veliko prostora na repozitoriju. V kolikor elite raziskati celotno zbirko, predlagamo, da si podatke prenesete iz vira. Poglejmo si sedaj vsako izmed razpredelnic. Razpredelnica account vsebuje podatke o raunih na banki. account &lt;- read_csv2(&quot;./data-raw/financial/account.csv&quot;) account ## # A tibble: 4,500 x 4 ## account_id district_id frequency date ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; ## 1 1 18 monthly payment 1995-03-24 ## 2 2 1 monthly payment 1993-02-26 ## 3 3 5 monthly payment 1997-07-07 ## 4 4 12 monthly payment 1996-02-21 ## 5 5 15 monthly payment 1997-05-30 ## 6 6 51 monthly payment 1994-09-27 ## 7 7 60 monthly payment 1996-11-24 ## 8 8 57 monthly payment 1995-09-21 ## 9 9 70 monthly payment 1993-01-27 ## 10 10 54 monthly payment 1996-08-28 ## # ... with 4,490 more rows Razpredelnica client vsebuje podatke o strankah. client &lt;- read_csv2(&quot;./data-raw/financial/client.csv&quot;) client ## # A tibble: 5,369 x 4 ## client_id gender birth_date district_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 1 F 1970-12-13 18 ## 2 2 M 1945-02-04 1 ## 3 3 F 1940-10-09 1 ## 4 4 M 1956-12-01 5 ## 5 5 F 1960-07-03 5 ## 6 6 M 1919-09-22 12 ## 7 7 M 1929-01-25 15 ## 8 8 F 1938-02-21 51 ## 9 9 M 1935-10-16 60 ## 10 10 M 1943-05-01 57 ## # ... with 5,359 more rows Razpredelnica disp povee podatke o osebah in raunih, torej, katere osebe imajo pravico opravljati s katerimi rauni. disp &lt;- read_csv2(&quot;./data-raw/financial/disp.csv&quot;) disp ## # A tibble: 5,369 x 4 ## disp_id client_id account_id type ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 1 1 OWNER ## 2 2 2 2 OWNER ## 3 3 3 2 DISPONENT ## 4 4 4 3 OWNER ## 5 5 5 3 DISPONENT ## 6 6 6 4 OWNER ## 7 7 7 5 OWNER ## 8 8 8 6 OWNER ## 9 9 9 7 OWNER ## 10 10 10 8 OWNER ## # ... with 5,359 more rows Razpredelnica loan vsebuje podatke o posojilih. loan &lt;- read_csv2(&quot;./data-raw/financial/loan.csv&quot;) loan ## # A tibble: 682 x 7 ## loan_id account_id date amount duration payments status ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 4959 2 1994-01-05 80952 24 3373 A ## 2 4961 19 1996-04-29 30276 12 2523 B ## 3 4962 25 1997-12-08 30276 12 2523 A ## 4 4967 37 1998-10-14 318480 60 5308 D ## 5 4968 38 1998-04-19 110736 48 2307 C ## 6 4973 67 1996-05-02 165960 24 6915 A ## 7 4986 97 1997-08-10 102876 12 8573 A ## 8 4988 103 1997-12-06 265320 36 7370 D ## 9 4989 105 1998-12-05 352704 48 7348 C ## 10 4990 110 1997-09-08 162576 36 4516 C ## # ... with 672 more rows Razpredelnica trans vsebuje podatke o transakcijah. trans &lt;- read_csv2(&quot;./data-raw/financial/transaction-smaller.csv&quot;) trans ## # A tibble: 20,000 x 10 ## trans_id account_id date type operation amount balance k_symbol bank ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 736882 2517 1997-07-17 CHOICE CHOICE 21992 22279 &lt;NA&gt; &lt;NA&gt; ## 2 201830 686 1997-05-08 INCOME DEPOSIT 10533 18473 &lt;NA&gt; &lt;NA&gt; ## 3 3158278 10478 1998-01-29 EXPEN~ CHOICE 2100 8821 &lt;NA&gt; &lt;NA&gt; ## 4 41116 135 1994-05-09 EXPEN~ CHOICE 2900 21513 &lt;NA&gt; &lt;NA&gt; ## 5 1046207 3578 1996-09-08 EXPEN~ TRANSFER~ 4051 51755 SIPO KL ## 6 875501 2982 1997-04-30 EXPEN~ CHOICE 12100 41859 &lt;NA&gt; &lt;NA&gt; ## 7 893918 3047 1996-11-30 EXPEN~ CHOICE 15 24788 SERVICES &lt;NA&gt; ## 8 3442751 1543 1998-07-31 INCOME &lt;NA&gt; 71 17153 UROK &lt;NA&gt; ## 9 462371 1571 1998-08-25 EXPEN~ CHOICE 2760 25770 &lt;NA&gt; &lt;NA&gt; ## 10 1028586 3513 1993-10-12 EXPEN~ TRANSFER~ 4507 31227 SIPO KL ## # ... with 19,990 more rows, and 1 more variable: account &lt;dbl&gt; Imamo 5 razpredelnice, vse pa so med seboj povezane. Razpredelnici account in client sta povezani preko razpredelnice disp. Razpredelnici loan in transsta povezani z razpredelnico account preko spremenljivke account_id. To strukturo najbolje prikaemo z relacijskim diagramom. Relacijski diagram 2.8 Kljui Spremenljivkam, ki povezujejo razpredelnice, pravimo kljui. Te spremenljivke (ali zbirke spremenljivk) edinstveno definirajo podatke. Lahko gre za eno spremenljivko, kot je na primer account_id v razpredelnici account. Lahko pa obstaja ve spremenljivk, ki definirajo en podatek. Na primer, e imamo razpredelnico s temperaturami za vsak dan in uro. Potem ni nujno, da ima vsaka vrstica svoj ID, lahko pa jih edinstveno loimo na podlagi dveh spremenljivk  dneva in ure. V tem primeru gre torej za klju, ki je sestavljen iz dveh spremenljivk. Poznamo dva glavna tipa kljuev: Primarni klju. Ta klju edinstveno definira podatek v razpredelnici. Na primer, trans_id v razpredelnici trans. V urejenih podatkih ima vsaka tabela svoj primarni klju. Tuj klju. To je klju v razpredelnici, ki je primarni klju v eni od preostalih razpredelnic. Na primer, account_id v razpredelnici trans. Vrednosti tujih kljuev se lahko podvajajo. Na primer, ve transakcij lahko ima isto vrednost tujega kljua za account_id, saj se na enem bannem raunu izvede ve transakcij. V kolikor razpredelnica nima primarnega kljua, lahko ustvarimo t. i. nadomestni klju, ki igra vlogo primarnega kljua. To lahko naredimo na primer tako, da vsaki vrstici priredimo njeno zaporedno vrednost v razpredelnici. Na primer mutate(row_number()). Primarni in tuj klju skupaj tvorita relacijo med razpredelnicama. Na primer account_id predstavlja relacijo med razpredelnicama trans in account. Relacije so lahko ena-proti-ena (ena drava ima enega predsednika in ena oseba je lahko predsednik samo ene drave), ena-proti-mnogo (en igralec lahko igra za en klub, ampak en klub ima ve igralcev) ali mnogo-proti-mnogo (en avtor lahko napie ve knjig in ena knjiga je lahko napisana s strani veih avtorjev). Kadar imamo opravka z relacijskimi podatki, je smiselno preveriti, ali je primarni klju res edinstven za vsako razpredelnico. df_list &lt;- list(account, client, disp, trans, loan) id_vec &lt;- c(&quot;account_id&quot;, &quot;client_id&quot;, &quot;disp_id&quot;, &quot;trans_id&quot;, &quot;loan_id&quot;) for (i in 1:length(df_list)) { tmp &lt;- df_list[[i]] %&gt;% group_by(.data[[id_vec[i]]]) %&gt;% summarise(n = n()) %&gt;% filter(n &gt; 1) print(tmp) } ## # A tibble: 0 x 2 ## # ... with 2 variables: account_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: client_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: disp_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: trans_id &lt;dbl&gt;, n &lt;int&gt; ## # A tibble: 0 x 2 ## # ... with 2 variables: loan_id &lt;dbl&gt;, n &lt;int&gt; V prejnjem klicu kode se pojavi nova sintaksa, in sicer .data[[id_vec[i]]]. Funkcija group_by() uporablja t. i. tidyselect, s katerim izbiramo stolpce brez da bi jih dali v narekovaje. To pa predstavlja teavo, kadar so imena stolpcev shranjena v neki spremenljivki, kot v tem primeru. Tidyverse je ustvarjen na naelu, da olaja bolj pogoste operacije (na primer, enostavno uporaba group_by() pri urejanju posamezne razpredelnice), za ceno teje izvedbe manj pogostih operacij (na primer, uporaba group_by() v zanki for). Veliko veino urejanja podatkov bomo lahko z uporabo tidyverse naredili brez uporabe zank ali naprednih lastnih funkcij. V kolikor se boste lotili bolj programerskega pristopa, pa predlagamo, da si preberete navodila za programiranje z dplyr, ki jih dobite tako, da v konzoli kliete vignette('programming'). Na tej delavnici ne bomo predstavili podrobnosti teh pristopov. Zaenkrat je dovolj, da poznamo samo zgornji klic. Torej, e imamo imena stolpcev shranjena v neki spremenljivki, potem moramo znotraj tidyselecta uporabiti .data[[&lt;spremenljivka-z-imeni-stolpcev&gt;]]. 2.9 Zdruevanja Kadar imamo opravka z veimi razpredelnicami potrebujemo orodja, s katerimi lahko posamezne pare razpredelnic zdruimo. Vei uporabniki R morda e poznajo funkcijo merge, ki je del osnovne razliice R in je namenjena splonemu zdruevanju razpredelnic. Seveda pa tidyverse premore svoje razliice podobnih funkcij, ki premorejo enake lastnosti kot preostale funkcije v tej zbirki  prejmejo in vrnejo podatke v enakem formatu in sicer tibblu. Poleg tega so funkcije iz paketa dplyr tudi hitreje od merge, kar ima pomembno vlogo, kadar imamo opravka z nekoliko vejimi podatkovnimi mnoicami. Zdruevanja podatkovnih razpredelnic lahko loimo na 3 sklope: Mutirajoa zdruevanja (ang. mutating joins). Dodajo nove stolpce k razpredelnici iz ujemajoih vrstic druge razpredelnice. Filtrirajoa zdruevanja (ang. filtering joins). Izberejo vrstice ene razpredenice glede na to, ali se te ujemajo z vrsticami v drugi razpredelnici. Operacije nad mnoicami. Operirajo nad vrsticami, kot da so ti deli mnoice. 2.9.1 Mutirajoa zdruevanja Mutirajoa zdruevanja so pogosta operacija pri delu z relacijskimi podatki. Te operacije zdruijo dve (ali ve) razpredelnici glede na vrednosti stolpcev. Obstajajo 4 takne operacije: left_join(). Ohrani vse vrstice prve (leve) razpredelnice in povee ustrezne vrstice iz druge razpredelnice s temi vrsticami. right_join(). Ohrani vse vrstice druge (desne) razpredelnice in povee ustrezne vrstice iz prve rapredelnice s temi vrsticami. full_join(). Ohrani vse vrstice obeh razpredelnic. inner_join(). Ohrani samo tiste vrstice, ki se pojavijo v obeh razpredelnicah. Prvi trije so tako imenovani zunanji stiki (outer join), saj uporabijo vrstice, ki se pojavijo vsaj v eni razpredelnici. Za laje razumevanje bomo najprej prikazali uporabo stikov na podatkih, ki jih bomo ustvarili sami. Sintaksa pri vseh zdruevanjih je: left_join(&lt;razpredelnica1&gt;, &lt;razpredelnica2&gt;) Ustvarimo dva tibbla: df1 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), x = c(4, 6, 1, 2) ) df2 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id3&quot;, &quot;id4&quot;, &quot;id5&quot;), y = c(20, 52, 11, 21) ) df1 ## # A tibble: 4 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 1 ## 4 id4 2 df2 ## # A tibble: 4 x 2 ## id y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id3 52 ## 3 id4 11 ## 4 id5 21 left_join() obdri tibble df1 taken kot je in mu pripne stolpec y iz tibbla df2, kjer so vrednosti spremenljivke id enake. Za tiste vrstice df1, ki nimajo ustreznega id v df2 se vrednosti v spremenljivki y nastavijo na NA. left_join(df1, df2) ## # A tibble: 4 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id2 6 NA ## 3 id3 1 52 ## 4 id4 2 11 right_join() obdri tibble df2 taken kot je in mu pripne stolpec x iz tibbla df1, kjer so vrednosti spremenljivke id enake. Za tiste vrstice df2, ki nimajo ustreznega id v df1, se vrednosti v spremenljivki y nastavijo na NA. right_join(df1, df2) ## # A tibble: 4 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id3 1 52 ## 3 id4 2 11 ## 4 id5 NA 21 inner_join() obdri samo tiste podatke, kjer se id nahaja v obeh razpredelnicah (torej 1, 3 in 4). Vse preostale vrstice zavre. inner_join(df1, df2) ## # A tibble: 3 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id3 1 52 ## 3 id4 2 11 full_join() obdri vse podatke iz df1 in df2. Kjer ni ustreznega id v nasprotni razpredelnici se vrednosti nastavijo na NA. full_join(df1, df2) ## # A tibble: 5 x 3 ## id x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 4 20 ## 2 id2 6 NA ## 3 id3 1 52 ## 4 id4 2 11 ## 5 id5 NA 21 Najbolj pogosto bomo uporabljali left_join(), kadar bo cilj obdrati originalno razpredelnico, kot je, ali inner_join(), kadar bomo eleli podatke brez manjkajoih vrednosti. Stik right_join() je samo drugae usmerjen left_join(). Do sedaj smo prikazovali, kako zdruimo razpredelnice glede na primarni klju, za katerega predpostavljamo, da je unikaten. Torej vsaka vrstica ima svoj klju, ki se v razpredelnici ne ponovi. Vasih pa razpredelnice zdruujemo glede na sekundarni klju. V tem primeru se lahko zgodi, da imamo relacijo ena-proti-mnogo. e vzamemo banne podatke od zgoraj ima lahko en raun ve skrbnikov. Kaj se zgodi v tem primeru? Kaj pa e zdruimo transakcije in osebe glede na raun? En raun ima lahko ve transakcij in ve skrbnikov. Ker pri obeh razpredelnicah uporabimo sekundarni klju, bomo najverjetneje dobili podvojene vrednosti pri obeh. Poglejmo si sedaj na primeru podatkov, ki jih generiramo sami. df3 &lt;- tibble( id1 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), id2 = c(&quot;id1&quot;, &quot;id1&quot;, &quot;id3&quot;, &quot;id4&quot;), x = c(5, 6, 1, 2) ) df4 &lt;- tibble( id2 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;), y = c(20, 52, 11) ) df5 &lt;- tibble( id3 = c(&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;), id2 = c(&quot;id1&quot;, &quot;id1&quot;, &quot;id4&quot;, &quot;id5&quot;), z = c(5, 1, 23, 5) ) df3 ## # A tibble: 4 x 3 ## id1 id2 x ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 ## 2 id2 id1 6 ## 3 id3 id3 1 ## 4 id4 id4 2 df4 ## # A tibble: 3 x 2 ## id2 y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id2 52 ## 3 id3 11 df5 ## # A tibble: 4 x 3 ## id3 id2 z ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 ## 2 id2 id1 1 ## 3 id3 id4 23 ## 4 id4 id5 5 df3 in df5 imata podvojen sekundarni klju. Zdruimo sedaj df3 in df4 z uporabo inner_join(). inner_join(df3, df4) ## # A tibble: 3 x 4 ## id1 id2 x y ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 id1 5 20 ## 2 id2 id1 6 20 ## 3 id3 id3 1 11 Klju torej ostane podvojen. Kaj pa se zgodi, e imata obe razpredelnici podvojene kljue? V tem primeru dobimo kartezini produkt vseh podvojenih vrednosti: inner_join(df3, df5) ## # A tibble: 5 x 5 ## id1 id2 x id3 z ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id1 id1 5 id1 5 ## 2 id1 id1 5 id2 1 ## 3 id2 id1 6 id1 5 ## 4 id2 id1 6 id2 1 ## 5 id4 id4 2 id3 23 df3 in df5 imata podvojeno vrednost kljua id1. Torej dobimo vse kombinacije preostalih vrednosti (5, 5), (5, 1), (6, 5) in (6, 1). 2.9.2 Argument by Zdruevanja, ki smo jih spoznali, privzeto zdruijo razpredelnici glede na vrednosti v vseh stolpcih, ki imajo enaka imena  tamu pravimo tudi naravno zdruevanje (ang. natural join). Lahko pa tudi sami doloimo, po katerih stolpcih elimo zdruiti podatke. To naredimo tako, da pri zdruevanjih uporabimo argument by. Sintaksa zdruevanj je potem: inner_join(&lt;razpredelnica1&gt;, &lt;razpredelnica2&gt;, by = &lt;vektor-imen-stolpcev&gt;) inner_join() dveh razpredelnic bi potem zapisali kot: inner_join(df3, df4, by = &quot;id2&quot;) ## # A tibble: 3 x 4 ## id1 id2 x y ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id1 id1 5 20 ## 2 id2 id1 6 20 ## 3 id3 id3 1 11 Ta primer slui samo kot ilustracija in je uporaba by nepotrebna. Seveda pa se pri realnih podatkih velikokrat sreamo s stanjem, kjer ta argument potrebujemo. Prav tako je koda s parametrom by bolj robustna, saj sami definiramo, glede na katere stolpce naj se razpredelnice zdruujejo in ne more priti do kaknih napak pri ponovljivosti. Razpredelnici lahko zdruimo tudi po stolpcih, ki nimajo istega imena. Ni nenavadno, da imamo dve razpredelnici z enakimi spremenljivkami, ki pa so poimenovane drugae. e bi eleli taki razpredelnici zdruiti glede na to spremenljivko, potem bi jo morali naeloma v eni razpredelnici preimenovati. S paketom dplyr pa lahko to naredimo tudi drugae. Zdruimo sedaj df3 in df5 glede na stolpca x in z ter skupni stolpec id2. inner_join(df3, df5, by = c(&quot;x&quot; = &quot;z&quot;, &quot;id2&quot;)) ## # A tibble: 1 x 4 ## id1 id2 x id3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id1 id1 5 id1 2.9.3 Filtrirajoa zdruevanja Pri filtrirajoih zdruevanjih ne gre toliko za zdruevanja, kolikor gre za izbiro posameznih vrstic, glede na ujemanje vrednotsti stolpcev v neki drugi razpredelnici. Poznamo 2 takni zdruevanji: semi_join(). Obdri vse vrstice v prvi razpredelnici, ki ustrezajo vrsticam v drugi razpredelnici. anti_join(). Izloi vse vrstice v prvi razpredelnici, ki ustrezajo vrsticam v drugi razpredelnici. Poglejmo si uporabo teh zdruevanj na naih generiranih razpredelnicah. df1 ## # A tibble: 4 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 1 ## 4 id4 2 df2 ## # A tibble: 4 x 2 ## id y ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 20 ## 2 id3 52 ## 3 id4 11 ## 4 id5 21 semi_join(df1, df2) ## # A tibble: 3 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id3 1 ## 3 id4 2 semi_join() je torej izloil vrstico z id2, saj se ta ne pojavi v df2. anti_join(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id2 6 semi_join() je torej izloil vse vrstice, ki se pojavijo tudi v df2. Ostane torej samo vrstica z id2. 2.9.4 Zdruevanja na realnih podatkih Sedaj, ko smo spoznali glavne lastnosti razlinih zdruevanj na primerih, ki so nam omogoali lajo predstavo, pa se posvetimo realnim podatkom, ki smo jih predstavili v zaetku tega poglavja. Imamo torej podatke o bannih raunih, transakcijah, posojilih, skrbnikih raunov in povezovalno razpredelnico med rauni in skrbniki. Lotimo se sedaj relativno enostavne analize, kjer bomo naredili sledee: Ustvarili novo razpredelnico, kjer bomo imeli podatke o vseh bannih raunih in o lastnikih teh raunov. Lastnik rauna je lahko samo en, medtem ko je skrbnikov lahko ve. Filtrirali razpredelnico iz toke 1), v kateri bodo samo tisti, ki imajo posojila nad 100000 kron. Ustvarili novo razpredelnico klientov, kjer bomo imeli podatke o klientih in posojilih in bodo zajeti samo klienti s posojili. Izraunali kateri klienti, ki imajo posojilo, imajo tudi najve transakcij. Za vsakega izmed teh korakov bomo morali uporabiti eno od zdruevanj, ki smo jih spoznali. Na primer, v samih razpredelnicah nimamo direktne povezave med komitenti in transakcijami, tako da bomo morali zadeve nekako zdruiti. Podobno velja za ostale alineje. Najprej elimo zdruiti razpredelnici account in client. Za to bomo potrebovali povezovalno razpredelnico disp v kateri se tudi nahaja informacija o tem, ali je klient lastnik ali samo skrbnik rauna. Najprej poveemo razpredelnico account z razpredelnico disp in filtriramo glede na tip klienta: account_disp &lt;- left_join(account, disp) %&gt;% filter(type == &quot;OWNER&quot;) account_disp ## # A tibble: 4,500 x 7 ## account_id district_id frequency date disp_id client_id type ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 18 monthly payment 1995-03-24 1 1 OWNER ## 2 2 1 monthly payment 1993-02-26 2 2 OWNER ## 3 3 5 monthly payment 1997-07-07 4 4 OWNER ## 4 4 12 monthly payment 1996-02-21 6 6 OWNER ## 5 5 15 monthly payment 1997-05-30 7 7 OWNER ## 6 6 51 monthly payment 1994-09-27 8 8 OWNER ## 7 7 60 monthly payment 1996-11-24 9 9 OWNER ## 8 8 57 monthly payment 1995-09-21 10 10 OWNER ## 9 9 70 monthly payment 1993-01-27 12 12 OWNER ## 10 10 54 monthly payment 1996-08-28 13 13 OWNER ## # ... with 4,490 more rows Sedaj lahko to novo razpredelnico poveemo z razpredelnico client. account_client &lt;- left_join(account_disp, client) S tem smo dobili eljeno razpredelnico, v kateri imamo za vsak raun tudi informacijo o lastniku. Kot drugi korak elimo ustvariti razpredelnico, v kateri bodo samo podatki o klientih, ki imajo posojila v vrednosti ve kot 100000 kron. Najprej ustvarimo razpredelnico, v kateri so samo takna posojila, nato pa uporabimo semi_join(), ki bo iz razpredelnice account_client izbral samo vrstice, ki se bodo ujemale z vrsticami v tej novi razpredelnici posojil. loan_100k &lt;- loan %&gt;% filter(amount &gt; 100000) account_100k &lt;- semi_join(account_client, loan_100k) account_100k ## # A tibble: 0 x 9 ## # ... with 9 variables: account_id &lt;dbl&gt;, district_id &lt;dbl&gt;, frequency &lt;chr&gt;, ## # date &lt;date&gt;, disp_id &lt;dbl&gt;, client_id &lt;dbl&gt;, type &lt;chr&gt;, gender &lt;chr&gt;, ## # birth_date &lt;date&gt; Hmdobili smo prazen tibble, eprav obstajajo tako velika posojila. Zakaj je do tega prilo? V obeh razpredelnicah se nahajata spremenjivki account_id in date. Ampak spremenljivka date ni ista spremenljivka, pri razpredelnici account_client predstavlja, kdaj je bil raun odprt, pri loan_100k pa predstavlja kdaj je bilo posojilo odobreno. Torej po tej spremenljivki ne smemo zdruevati. Uporabimo by: account_100k &lt;- semi_join(account_client, loan_100k, by = &quot;account_id&quot;) account_100k ## # A tibble: 377 x 9 ## account_id district_id frequency date disp_id client_id type gender ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 37 20 monthly pay~ 1997-08-18 45 45 OWNER M ## 2 38 19 weekly paym~ 1997-08-08 46 46 OWNER F ## 3 67 16 monthly pay~ 1994-10-19 78 78 OWNER F ## 4 97 74 monthly pay~ 1996-05-05 116 116 OWNER M ## 5 103 44 monthly pay~ 1996-03-10 124 124 OWNER M ## 6 105 21 monthly pay~ 1997-07-10 127 127 OWNER F ## 7 110 36 monthly pay~ 1996-07-17 132 132 OWNER M ## 8 173 66 monthly pay~ 1993-11-26 210 210 OWNER M ## 9 226 70 monthly pay~ 1997-02-23 272 272 OWNER F ## 10 276 38 monthly pay~ 1997-12-08 333 333 OWNER M ## # ... with 367 more rows, and 1 more variable: birth_date &lt;date&gt; V naslednjem koraku elimo imeti podatke o klientih in posojilih. Najprej bomo morali zdruiti razpredelnici client in disp, nato pa dodati e razpredelnico loan. Ustvarimo to novo razpredelnico kar z uporabo operatorja %&gt;%: client_loan &lt;- client %&gt;% left_join(disp) %&gt;% inner_join(loan, by = &quot;account_id&quot;) client_loan ## # A tibble: 827 x 13 ## client_id gender birth_date district_id disp_id account_id type loan_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 M 1945-02-04 1 2 2 OWNER 4959 ## 2 3 F 1940-10-09 1 3 2 DISPONENT 4959 ## 3 25 F 1939-04-23 21 25 19 OWNER 4961 ## 4 31 M 1962-02-09 68 31 25 OWNER 4962 ## 5 45 M 1952-08-26 20 45 37 OWNER 4967 ## 6 46 F 1940-01-30 19 46 38 OWNER 4968 ## 7 78 F 1944-06-13 16 78 67 OWNER 4973 ## 8 116 M 1942-01-28 74 116 97 OWNER 4986 ## 9 117 F 1936-09-20 74 117 97 DISPONENT 4986 ## 10 124 M 1967-09-21 44 124 103 OWNER 4988 ## # ... with 817 more rows, and 5 more variables: date &lt;date&gt;, amount &lt;dbl&gt;, ## # duration &lt;dbl&gt;, payments &lt;dbl&gt;, status &lt;chr&gt; Na koncu preverimo e, kateri klienti, ki imajo posojilo, imajo najve transakcij. Za to bomo morali najprej izraunati tevilo transakcij na vsakem bannem raunu. Uporabimo znanje, ki smo ga pridobili na prvem predavanju: trans_count &lt;- trans %&gt;% group_by(account_id) %&gt;% summarise(n_trans = n()) trans_count ## # A tibble: 4,205 x 2 ## account_id n_trans ## &lt;dbl&gt; &lt;int&gt; ## 1 1 6 ## 2 2 10 ## 3 3 3 ## 4 4 6 ## 5 5 3 ## 6 6 8 ## 7 7 3 ## 8 8 7 ## 9 9 3 ## 10 10 1 ## # ... with 4,195 more rows left_join(client_loan, trans_count) %&gt;% arrange(desc(n_trans)) ## # A tibble: 827 x 14 ## client_id gender birth_date district_id disp_id account_id type loan_id ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 11126 F 1965-01-22 1 10818 9034 OWNER 6820 ## 2 6367 M 1970-04-28 44 6367 5270 OWNER 6077 ## 3 7291 F 1940-12-02 77 7291 6034 OWNER 6228 ## 4 7195 M 1962-09-11 50 7195 5952 OWNER 6216 ## 5 4620 F 1940-11-01 54 4620 3834 OWNER 5754 ## 6 4621 M 1946-02-10 54 4621 3834 DISPONENT 5754 ## 7 11461 M 1974-07-08 70 11153 9307 OWNER 6895 ## 8 11866 M 1937-09-02 1 11558 9640 OWNER 6960 ## 9 11867 F 1934-11-19 1 11559 9640 DISPONENT 6960 ## 10 13657 F 1963-05-12 59 13349 11111 OWNER 7259 ## # ... with 817 more rows, and 6 more variables: date &lt;date&gt;, amount &lt;dbl&gt;, ## # duration &lt;dbl&gt;, payments &lt;dbl&gt;, status &lt;chr&gt;, n_trans &lt;int&gt; 2.10 Operacije nad mnoicami V tem poglavju si bomo ogledali operacije nad mnoicami. Te delujejo nad vektorji, prav tako pa nad data.frame oziroma nad tibbli. Poznamo 3 glavne operacije: Unija. Vrne vse elemente, ki se pojavijo v eni ali drugi mnoici. Presek. Vrne vse elemente, ki se pojavijo v obeh mnoicah. Razlika. Vrne vse elemente prve mnoice, ki se ne pojavijo v drugi mnoici. Poglejmo si uporabo teh operacij nad tibbli. df1 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id2&quot;), x = c(4, 6) ) df2 &lt;- tibble( id = c(&quot;id1&quot;, &quot;id3&quot;), x = c(4, 52) ) df1 ## # A tibble: 2 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 df2 ## # A tibble: 2 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id3 52 union(df1, df2) ## # A tibble: 3 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 ## 2 id2 6 ## 3 id3 52 intersect(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id1 4 setdiff(df1, df2) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id2 6 setdiff(df2, df1) ## # A tibble: 1 x 2 ## id x ## &lt;chr&gt; &lt;dbl&gt; ## 1 id3 52 2.11 Ali elite izvedeti ve? Hadley Wickham je objavil znanstveni lanek na temo urejenih podatkov: https://vita.had.co.nz/papers/tidy-data.pdf, ki je vsekakor vreden branja. Za ve informacij o neurejenih podatkih in v katerih primerih so lahko celo bolj zaeljeni, predlagamo ta blog: https://simplystatistics.org/2016/02/17/non-tidy-data/. 2.12 Domaa naloga Spodaj imamo podatke o strokih za 4 osebe. Razpredelnica je v neurejeni obliki. Vaa naloga je, da jo pretvorite v urejeno obliko. podatki_o_stroskih &lt;- tibble( ime = c(&quot;Miha&quot;, &quot;Ana&quot;, &quot;Andrej&quot;, &quot;Maja&quot;), april_2019 = c(400, 200, 300, 350), maj_2019 = c(390, 250, 280, 400), april_2020 = c(410, 150, 500, 400), maj_2020 = c(300, 320, 550, 320) ) Reitev: ## # A tibble: 16 x 4 ## ime mesec leto strosek ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Miha april 2019 400 ## 2 Miha maj 2019 390 ## 3 Miha april 2020 410 ## 4 Miha maj 2020 300 ## 5 Ana april 2019 200 ## 6 Ana maj 2019 250 ## 7 Ana april 2020 150 ## 8 Ana maj 2020 320 ## 9 Andrej april 2019 300 ## 10 Andrej maj 2019 280 ## 11 Andrej april 2020 500 ## 12 Andrej maj 2020 550 ## 13 Maja april 2019 350 ## 14 Maja maj 2019 400 ## 15 Maja april 2020 400 ## 16 Maja maj 2020 320 V mapi data-raw se nahajajo podatki o predsednikih volitvah v ZDA. Najprej izberite samo podmnoico vrstic, kjer sta kandidata Joe Biden ali Donald Trump, in izloite stolpec party. Nato pretvorite podatke v iro obliko, tako da bo vsak izmed kandidatov imel svoj stolpec. ## # A tibble: 4,633 x 4 ## state county `Joe Biden` `Donald Trump` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Delaware Kent County 44518 40976 ## 2 Delaware New Castle County 194238 87685 ## 3 Delaware Sussex County 56657 71196 ## 4 District of Columbia District of Columbia 29509 1149 ## 5 District of Columbia Ward 2 24247 2365 ## 6 District of Columbia Ward 3 33584 2972 ## 7 District of Columbia Ward 4 35117 1467 ## 8 District of Columbia Ward 5 36585 1416 ## 9 District of Columbia Ward 6 44699 3360 ## 10 District of Columbia Ward 7 30253 885 ## # ... with 4,623 more rows Pri bannih podatkih smo zaenkrat delali samo s petimi razpredelnicami. Celotna zbirka je nekoliko veja, saj vsebuje e 3 razpredelnice. V mapi data-raw/financial-hw/ se nahajajo e preostale razpredelnice. Pri nalogi bomo uporabili razpredelnico district, ki vsebuje podatke o okrajih. Vsekakor pa se lahko za lastno vajo poigrate e s preostalima dvema. Vae naloge so: Preberite podatke o okrajih v R. Ugotovite, kaj je primarni klju te razpredelnice. Ustrezno dopolnite entitetni diagram. To lahko naredite rono, v kolikor pa se elite nauiti narediti bolj profesionalne diagrame pa predlagamo spletno orodje https://app.diagrams.net/. V mapi support-files se nahaja na diagram. Tega lahko enostavno naloite v to orodje in ga dopolnite. Poiite 3 pokrajine (A3) z najvejo povpreno vrednostjo posojil. ## # A tibble: 3 x 2 ## A3 mean_loan ## &lt;chr&gt; &lt;dbl&gt; ## 1 east Bohemia 165997. ## 2 south Bohemia 156236. ## 3 central Bohemia 155392. Teka naloga. Namestite paket nycflights13. Gre za relacijsko podatkovno zbirko o letih iz New Yorka v letu 2013. Naloite podatke z library(nycflights13). Uporabljali bomo tiri razpredelnice: flights, weather, airlines in planes. Vaa naloga je: Poizkusite najti primarni klju za razpredelnico flights. Ali gre za primarni klju lahko preverite tako, da preverite ali ta klju unikatno doloa vrstico v podatkih, torej da pretejete podatke, grupirane glede na ta klju. Klju je lahko sestavljen tudi iz veih spremenljivk. Na prvi pogled bi rekli, da je primarni klju tevilka leta, ampak temu ni tako (preverimo s tetjem). Ali je morda kakna druga kombinacija spremenljivk? Lahko da razpredelnica nima primarnega kljua. V tem primeru doloite nadomestni klju tako, da dodate stolpec ID z mutate(ID = row_number()). Ugotovite, kaj so primarni in kaj tuji kljui preostalih razpredelnic. Pri nekaterih razpredelnicah v tej zbirki bomo imeli sestavljene kljue, torej bodo kljui sestavljeni iz veih stolpcev. Namig: Pri vremenu je manja napaka v podatkih in se tudi primarni klju ponovi v zanemarljivem tevilu primerov. Vsekakor so napake v realnih podatkih priakovane in moramo na to biti pozorni! Nariite relacijski diagram. Ustvarite novo razpredelnico tako da razpredelnici flights dodate podrobnosti o lastnostih letal za vsak let. ## # A tibble: 336,776 x 28 ## ID year.x month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2013 1 1 517 515 2 830 ## 2 2 2013 1 1 533 529 4 850 ## 3 3 2013 1 1 542 540 2 923 ## 4 4 2013 1 1 544 545 -1 1004 ## 5 5 2013 1 1 554 600 -6 812 ## 6 6 2013 1 1 554 558 -4 740 ## 7 7 2013 1 1 555 600 -5 913 ## 8 8 2013 1 1 557 600 -3 709 ## 9 9 2013 1 1 557 600 -3 838 ## 10 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 20 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt;, year.y &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;, ## # model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt; Ustvarite novo razpredelnico tako da razpredelnici flights dodate podrobnosti o vremenu na letaliu vsak let. ## # A tibble: 336,776 x 30 ## ID year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2013 1 1 517 515 2 830 ## 2 2 2013 1 1 533 529 4 850 ## 3 3 2013 1 1 542 540 2 923 ## 4 4 2013 1 1 544 545 -1 1004 ## 5 5 2013 1 1 554 600 -6 812 ## 6 6 2013 1 1 554 558 -4 740 ## 7 7 2013 1 1 555 600 -5 913 ## 8 8 2013 1 1 557 600 -3 709 ## 9 9 2013 1 1 557 600 -3 838 ## 10 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 22 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour.x &lt;dttm&gt;, temp &lt;dbl&gt;, dewp &lt;dbl&gt;, humid &lt;dbl&gt;, wind_dir &lt;dbl&gt;, ## # wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;, ## # visib &lt;dbl&gt;, time_hour.y &lt;dttm&gt; Poiite vsa letala, ki so v New York priletela 5. aprila iz letalia Chicago Ohare Intl. ## # A tibble: 35 x 35 ## ID year.x month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 169022 2013 4 5 545 600 -15 710 ## 2 169051 2013 4 5 604 610 -6 739 ## 3 169062 2013 4 5 624 630 -6 755 ## 4 169086 2013 4 5 636 630 6 814 ## 5 169100 2013 4 5 653 700 -7 827 ## 6 169114 2013 4 5 659 700 -1 823 ## 7 169125 2013 4 5 720 725 -5 851 ## 8 169159 2013 4 5 752 759 -7 920 ## 9 169183 2013 4 5 810 815 -5 933 ## 10 169201 2013 4 5 823 830 -7 957 ## # ... with 25 more rows, and 27 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt;, year.y &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;, ## # model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;, ## # name &lt;chr&gt;, lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, ## # tzone &lt;chr&gt; Zelo teka naloga. V mapi data-raw se nahajajo podatki o kreditnih karticah v Tajvanu default of credit card clients.xlsx. Pridobili smo jih iz UCI Machine Learning repozitorija (Dua and Graff 2017). Podatki so bili uporabljeni v znanstveni raziskavi (Yeh and Lien 2009), kjer so napovedovali verjetnosti neplail v odvisnosti od preteklih transakcij na kartici in podatkov o lastnikih. Podatki so v xlsx datoteki. Bodite pozorni, da je prva vrstica datoteke nepomembna in se glava zane komaj v drugi vrstici. Trenutno so podatki v obliki, v kateri so zelo primerni kot vhodni podatek za kak model, na primer linearno regresijo. Vsekakor pa niso v primerni obliki za uinkotivo urejanje in hranjenje. Vaa naloga je, da podatke preberete v R in razpredelnico pretvorite v urejeno obliko. Predlagamo, da nalogo poizkusite reiti sami. Naloga zahteva precej razmisleka in tudi nekaj samostojne raziskave (na primer, kaj posamezni stolpci pomenijo  pomagate si lahko s spletno stranjo, iz katere smo prenesli podatke). V kolikor se vam zatakne, smo vam spodaj pripravili nekaj namigov: Najprej je potrebno razmisliti, kaj so spremenljivke. Na primer, ali sta PAY_1 in PAY_2 2 spremenljivki, ali predstavljata 1 spremenljivko, ki pa je razdeljena glede na neko drugo spremenljivko? Predlagamo da zanete ukaze tako, da razpredelnico spremenite v daljo obliko, kjer vse spremenljivke, ki se pojavijo v veih stolpcih, shranite v 1 stolpec. V novem stolpcu so celice sestavljene iz 2 spremenljivk. Ena od teh je ID meseca. Torej moramo ta stolpec loiti na 2 stolpca. Katero funkcijo uporabimo za to? Pri tem bo prav priel tudi argument te funkcije sep = -1, ki bo stolpec loil na zadnji znak v besedi in vse preostalo (na primer, beseda3 bo razdelil na beseda in 3). -1 predstavlja pri koliko znakih od konca proti zaetku naredimo loitev besede. V enem od teh dveh preostalih stolpcev imamo e vedno shranjene 3 spremenljivke, za katere bi bilo bolje, e so v 3 stolpcih. Ustrezno pretvorite tabelo. Na tej toki smo e skoraj pri koncu. ID mesecev al ne sovpada z zaporednimi tevili mesecev v letu. Predlagamo, da si ustvarite novo razpredelnico, ki bo mapirala ID mesecev v njihova zaporedna tevila. Potem pa to razpredelnico poveete z razpredelnico, kjer hranimo podatke. Kako naredimo to? Kadar zdruujemo razpredelnice moramo tudi biti pozorni na to, da so stolpci, ki jih zdruujemo, istega tipa. ## # A tibble: 180,000 x 10 ## ID LIMIT_BAL SEX EDUCATION MARRIAGE AGE MONTH PAY PAY_AMT BILL_AMT ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 20000 2 2 1 24 9 2 0 3913 ## 2 1 20000 2 2 1 24 8 2 689 3102 ## 3 1 20000 2 2 1 24 7 -1 0 689 ## 4 1 20000 2 2 1 24 6 -1 0 0 ## 5 1 20000 2 2 1 24 5 -2 0 0 ## 6 1 20000 2 2 1 24 4 -2 0 0 ## 7 2 120000 2 2 2 26 9 -1 0 2682 ## 8 2 120000 2 2 2 26 8 2 1000 1725 ## 9 2 120000 2 2 2 26 7 0 1000 2682 ## 10 2 120000 2 2 2 26 6 0 1000 3272 ## # ... with 179,990 more rows "],["nizi-kategori-ne-spremenljivke-in-datumi.html", "Poglavje 3 Nizi, kategorine spremenljivke in datumi 3.1 Priprava 3.2 Nizi 3.3 Kategorine spremenljivke 3.4 Datumi in ure 3.5 Shranjevanje in branje podatkov 3.6 Ali elite izvedeti ve? 3.7 Domaa naloga", " Poglavje 3 Nizi, kategorine spremenljivke in datumi Pogosto se pri delu s podatki sreamo s posebnimi podatkovnimi tipi, kot so nizi, kategorine spremenljivke in datumi. Z nizi smo e delali na prvi dveh predavanjih, ampak nad njimi nismo izvajali pretirano kompleksnih operacij. Delali smo tudi s kategorinimi spremenljivkami, eprav se tega morda nismo zavedali. S temi podatkovnimi tipi lahko torej delamo z relativno malo znanja. Seveda pa za kvalitetno delo s podatki potrebujemo tudi orodja za bolj podrobno delo s taknimi tipi. V tem predavanju bomo spoznali kako delati s taknimi spremenljivkami v okviru zbirke tidyverse ter predstavili praktine primere, dobre prakse in pasti pri delu z njimi. 3.1 Priprava V tem poglavju bomo spoznali, kako delamo z nizi, kategorinimi spremenljivkami in datumi. Na koncu se bomo tudi posvetili branju podatkov iz razlinih datotek in shranjevanju dobljenih rezultatov. Nizi Najprej si poglejmo najbolj uporabne funkcije za delo z nizi. Nize lahko zdruujemo na ve nainov: crke &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) stevilke &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) str_c(crke, stevilke) ## [1] &quot;A1&quot; &quot;B2&quot; &quot;C3&quot; &quot;D4&quot; str_c(crke, stevilke, sep = &quot;-&quot;) ## [1] &quot;A-1&quot; &quot;B-2&quot; &quot;C-3&quot; &quot;D-4&quot; str_c(crke, stevilke, collapse = &quot;-&quot;) ## [1] &quot;A1-B2-C3-D4&quot; Obratno jih lahko razlenimo na ve manjih nizov: str_split(&quot;A1-B2-C3-D4&quot;, pattern = &quot;-&quot;) ## [[1]] ## [1] &quot;A1&quot; &quot;B2&quot; &quot;C3&quot; &quot;D4&quot; Zelo uporabna je tudi funkcija za zamenjavo podnizov. str_replace(&quot;A1-B1-A2-B2&quot;, pattern = &quot;1&quot;, &quot;(ena)&quot;) ## [1] &quot;A(ena)-B1-A2-B2&quot; str_replace_all(&quot;A1-B1-A2-B2&quot;, pattern = &quot;1&quot;, &quot;(ena)&quot;) ## [1] &quot;A(ena)-B(ena)-A2-B2&quot; str_replace_all(&quot;A1-B1-A2-B2&quot;, c(&quot;1&quot; = &quot;(ena)&quot;, &quot;2&quot; = &quot;(dva)&quot;)) ## [1] &quot;A(ena)-B(ena)-A(dva)-B(dva)&quot; Poglejmo, kako bi iz zbirke sadeev v e vgrajenem nizu fruit poiskali vse jagodievje, to so tisti nizi, ki vsebujejo berry. length(fruit) ## [1] 80 str_subset(fruit, &quot;berry&quot;) ## [1] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blueberry&quot; &quot;boysenberry&quot; &quot;cloudberry&quot; ## [6] &quot;cranberry&quot; &quot;elderberry&quot; &quot;goji berry&quot; &quot;gooseberry&quot; &quot;huckleberry&quot; ## [11] &quot;mulberry&quot; &quot;raspberry&quot; &quot;salal berry&quot; &quot;strawberry&quot; Oziroma lahko vrnemo logini vektor nizov, ki vsebujejo berry. str_detect(fruit, &quot;berry&quot;) ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE TRUE TRUE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE ## [25] FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE FALSE FALSE FALSE ## [37] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [49] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [73] TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE Funkcija str_detect() je zelo uporabna pri izbiranju vrstic glede na nize. Obiajno jo uporabljamo v kombinaciji z regularnimi izrazi, ki jih bomo spoznali v jedru tega poglavja. Kategorine spremenljivke Pri pripravi na kategorine spremenljivke bomo uporabili podatke o uspehu tudentov na izpitu: tib &lt;- tibble( ime = c(&quot;Maja&quot;, &quot;Ales&quot;, &quot;Tom&quot;, &quot;Barbara&quot;, &quot;Simon&quot;, &quot;Tina&quot;), spol = c(&quot;z&quot;, &quot;m&quot;, &quot;m&quot;, &quot;z&quot;, &quot;m&quot;, &quot;z&quot;), ocena = c(10, 10, 6, 8, 8, 7), dan_izpita = c(8, 8, 16, 16, 8, 23), mesec_izpita = rep(6, 6), leto_izpita = rep(2021, 6), opravljene_vaje = c(1, 1, 1, 1, 0, 1), procenti_vaje = c(70, 65, 80, 90, 30, 75) ) tib ## # A tibble: 6 x 8 ## ime spol ocena dan_izpita mesec_izpita leto_izpita opravljene_vaje ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maja z 10 8 6 2021 1 ## 2 Ales m 10 8 6 2021 1 ## 3 Tom m 6 16 6 2021 1 ## 4 Barbara z 8 16 6 2021 1 ## 5 Simon m 8 8 6 2021 0 ## 6 Tina z 7 23 6 2021 1 ## # ... with 1 more variable: procenti_vaje &lt;dbl&gt; Spremenimo spol v nominalno spremenljivko (brez ureditve) in oceno v ordinalno spremenljivko (obstaja ureditev med vrednostmi, obiajno po velikosti): tib &lt;- tib %&gt;% mutate(spol = factor(spol), ocena = factor(ocena, ordered = TRUE)) tib$spol ## [1] z m m z m z ## Levels: m z tib$ocena ## [1] 10 10 6 8 8 7 ## Levels: 6 &lt; 7 &lt; 8 &lt; 10 Nivoje faktorja (levels) lahko tudi uredimo glede na vrednosti v nekem drugem stolpcu. To obiajno pride prav pri vizualizaciji. tib &lt;- tib %&gt;% mutate(spol = fct_reorder(spol, procenti_vaje, .desc = TRUE)) tib$spol ## [1] z m m z m z ## Levels: z m Datumi R omogoa avtomatski izpis datumov v obliki nizov. Preprosto lahko sestavimo datum s posameznimi komponentami: make_date(year = 2021, month = 6, day = 11) ## [1] &quot;2021-06-11&quot; Ali iz niza: ymd(&quot;2021-06-11&quot;) ## [1] &quot;2021-06-11&quot; Lahko dodamo tudi as: make_datetime(year = 2021, month = 6, day = 11, hour = 11, min = 30, tz = &quot;CET&quot;) ## [1] &quot;2021-06-11 11:30:00 CEST&quot; Z datumi lahko tudi raunamo: my_date &lt;- make_date(year = 2021, month = 6, day = 11) my_date ## [1] &quot;2021-06-11&quot; my_date + days(2) ## [1] &quot;2021-06-13&quot; my_date + months(3) ## [1] &quot;2021-09-11&quot; Shranjevanje podatkov v csv V pripravi na 2. predavanje smo e spoznali funkcijo rear_csv2() za branje podatkov iz tekstovnih datotek. Podatke lahko tudi shranimo v tekstovno datoteko s funkcijo write_csv2(): write_csv2(tib, &quot;./data-raw/studenti.csv&quot;) Naloga 1: Datoteko ocene.csv v mapi data-raw preberite s funkcijami paketa readr (read_csv2() in write_csv2()). Shranite jo kot ocene2.csv in to datoteko preberite nazaj. Nato narediti enako z baznimi funkcijami v R ((read.csv2() in write.csv2())). Kaj opazite? Z readr: ocene &lt;- read_csv2(&quot;./data-raw/ocene.csv&quot;) write_csv2(ocene, &quot;./data-raw/ocene2.csv&quot;) read_csv2(&quot;./data-raw/ocene2.csv&quot;) ## # A tibble: 6 x 7 ## ime spol ocena dan_izpita mesec_izpita leto_izpita opravljene_vaje ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maja z 7 8 6 2021 1 ## 2 Ales m 10 8 6 2021 1 ## 3 Tom m 6 16 6 2021 1 ## 4 Barbara z 8 16 6 2021 1 ## 5 Simon m 8 8 6 2021 0 ## 6 Tina z 7 23 6 2021 1 Z R: ocene &lt;- read.csv2(&quot;./data-raw/ocene.csv&quot;) write.csv2(ocene, &quot;./data-raw/ocene2.csv&quot;) read.csv2(&quot;./data-raw/ocene2.csv&quot;) ## X ime spol ocena dan_izpita mesec_izpita leto_izpita opravljene_vaje ## 1 1 Maja z 7 8 6 2021 1 ## 2 2 Ales m 10 8 6 2021 1 ## 3 3 Tom m 6 16 6 2021 1 ## 4 4 Barbara z 8 16 6 2021 1 ## 5 5 Simon m 8 8 6 2021 0 ## 6 6 Tina z 7 23 6 2021 1 Naloga 2: Ponovno preberite ocene.csv ter: spremenite stolpec opravljene_vaje v kategorine vrednosti, zamenjajte stolpce leto_izpita, mesec_izpita, dan_izpita z datum_izpita, ki vsebuje vse te podatke, Izberite samo imena, ki se zanejo na T in podatke shranite v datoteko oceneT.csv. ocene &lt;- read.csv2(&quot;./data-raw/ocene.csv&quot;) ocene &lt;- ocene %&gt;% mutate(opravljene_vaje = factor(opravljene_vaje)) %&gt;% mutate(datum_izpita = make_date(year = leto_izpita, month = mesec_izpita, day = dan_izpita)) %&gt;% select(-leto_izpita, -mesec_izpita, -dan_izpita) %&gt;% filter(str_detect(ime, &quot;T&quot;)) write_csv2(ocene, &quot;./data-raw/oceneT.csv&quot;) ocene ## ime spol ocena opravljene_vaje datum_izpita ## 1 Tom m 6 1 2021-06-16 ## 2 Tina z 7 1 2021-06-23 Delo s umniki Pri delu z nizi RStudio uporablja privzeto kodiranje vaega operacijskega sistema. Preprost nain, da preverite ali R uporablja pravilno kodiranje je, da napiete v konzolo ebula. Nazaj morate dobiti enak niz in ne cebula ali celo bula. &quot;ebula&quot; ## [1] &quot;ebula&quot; e R ne vrne istega niza je potrebno nastaviti privzeto kodiranje na svojem operacijskem sistemu. Da vidimoo katero kodiranje je trenutno uporabljeno, lahko napiemo: Sys.getlocale() ## [1] &quot;LC_COLLATE=Slovenian_Slovenia.1250;LC_CTYPE=Slovenian_Slovenia.1250;LC_MONETARY=Slovenian_Slovenia.1250;LC_NUMERIC=C;LC_TIME=Slovenian_Slovenia.1250&quot; Pri tem izpisu vidimo, da uporabljamo sloveski nabor znakov CP1250. e imate teave, lahko to zaasno spremenite z ukazom. Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;Slovenian_Slovenia.1250&quot;) ## [1] &quot;LC_COLLATE=Slovenian_Slovenia.1250;LC_CTYPE=Slovenian_Slovenia.1250;LC_MONETARY=Slovenian_Slovenia.1250;LC_NUMERIC=C;LC_TIME=Slovenian_Slovenia.1250&quot; Oziroma lahko na primer v Windowsih nastavite privzeto kodiranje pod Settings -&gt; Time &amp; Language -&gt; Region -&gt; Regional Format. Tukaj izberite Slovenian (Slovenia). Za slovenske Windowse: Nastavitve -&gt; Ura in Jezik -&gt; Regija -&gt; Obmone nastavitve in izberite Slovenina (Slovenija) 3.2 Nizi Zbirka paketov tidyverse vsebuje paket stringr, ki je namenjen delu z nizi. Vsi ukazi v paketu se zanejo s str_, kar v kombinaciji s funkcionalnostjo avtomatskega dopolnjevanja omogoa hitro izbiro in pregled vseh funkcij. V jeziku R lahko za definiranje niza uporabimo enojne () ali dvojne navednice (\"). R bo rezultat sicer vedno vrnil v dvojnih navednicah. niz_dvojne_navednice &lt;- &quot;urejanje podatkov&quot; niz_enojne_navednice &lt;- &#39;urejanje podatkov&#39; niz_dvojne_navednice ## [1] &quot;urejanje podatkov&quot; niz_enojne_navednice ## [1] &quot;urejanje podatkov&quot; e elimo znotraj niza uporabiti dvojne navednice lahko za definicijo uporabljamo enojne in obratno. citat1 &lt;- &quot;Jure je rekel: &#39;Citiram Janeza&#39;.&quot; citat2 &lt;- &#39;In Janez je rekel: &quot;Citiram Jureta&quot;.&#39; citat1 ## [1] &quot;Jure je rekel: &#39;Citiram Janeza&#39;.&quot; citat2 ## [1] &quot;In Janez je rekel: \\&quot;Citiram Jureta\\&quot;.&quot; Izpis v drugem primeru uporablja tako imenovan escape character (\\), ki omogoa tudi vpis tabulaterjev (\\t), znakov za novo vrstico (\\n) in podobno. Vse znake, ki jih je tako mono zapisati si lahko ogledate z ukazom ?\"'\". Niz lahko vkljuuje tudi vse posebne znake, ki jih podpira Unicode. To je standard za konsistentno kodiranje teksta, ki vsebuje preko 100000 znakov. Za vnos unicode znakov uporabite \\uxxxx, kjer je xxxx koda znaka, ki ga lahko poiete na strani https://unicode.org/charts/. normalna_porazdelitev &lt;- &quot;Gauss(\\u03BC, \\u03C3)&quot; normalna_porazdelitev ## [1] &quot;Gauss(µ, &lt;U+03C3&gt;)&quot; Dolino nizov poiemo s funkcijo str_length(). str_length(c(&quot;tri&quot;, &quot;tiri&quot;, &quot;&quot;, citat1, normalna_porazdelitev)) ## [1] 3 5 0 32 11 Za zdruevanje nizov se uporablja str_c(), ki mu lahko dodamo tudi niz sep, ki ga vrine med vse podane nize: str_c(&quot;paradinik&quot;, &quot;buke&quot;, &quot;jabolka&quot;, &quot;paprika&quot;, &quot;jagode&quot;, sep = &quot;, &quot;) ## [1] &quot;paradinik, buke, jabolka, paprika, jagode&quot; e funkciji podamo vektorje lahko zdruimo tudi ve nizov naenkrat. Pri tem bo tevilo dobljenih nizov enako najvejemu vektorju, manji pa se bodo reciklirali, kar pomeni, da se bodo njihove vrednosti ponavljale, dokler ne doseejo doline najdaljega vektorja. str_c(&quot;Podpoglavje &quot;, c(1, 2, 3, 4), &quot;: &quot;, c(&quot;Nizi&quot;, &quot;Faktorji&quot;, &quot;Datumi&quot;, &quot;Branje podatkov&quot;)) ## [1] &quot;Podpoglavje 1: Nizi&quot; &quot;Podpoglavje 2: Faktorji&quot; ## [3] &quot;Podpoglavje 3: Datumi&quot; &quot;Podpoglavje 4: Branje podatkov&quot; e elimo nize zdruiti zaporedno uporabimo collapse. Za izpis nizov brez escape znakov uporabite funkcijo cat(). poglavja &lt;- str_c(&quot;Podpoglavje &quot;, c(1, 2, 3, 4), &quot;: &quot;, c(&quot;Nizi&quot;, &quot;Faktorji&quot;, &quot;Datumi&quot;, &quot;Branje podatkov&quot;), collapse = &quot;\\n&quot;) poglavja ## [1] &quot;Podpoglavje 1: Nizi\\nPodpoglavje 2: Faktorji\\nPodpoglavje 3: Datumi\\nPodpoglavje 4: Branje podatkov&quot; cat(poglavja) ## Podpoglavje 1: Nizi ## Podpoglavje 2: Faktorji ## Podpoglavje 3: Datumi ## Podpoglavje 4: Branje podatkov Manjkajoe vrednosti lahko zamenjamo z str_replace_na(). str_replace_na(c(&quot;ena&quot;, &quot;dva&quot;, NA, &quot;tiri&quot;), replacement = &quot;tri!&quot;) ## [1] &quot;ena&quot; &quot;dva&quot; &quot;tri!&quot; &quot;tiri&quot; 3.2.1 Podnizi Velikokrat se pri delu z nizi sreamo tudi s tem, da potrebujemo le del niza ali pa elimo niz razdeliti na ve manjih nizov. Poglejmo si na primeru niza \" KUPI: paradinik, buke, jabolka, paprika, jagode. \" iz katerega elimo dobiti vektor sadja in zelenjave. listek &lt;- &quot; KUPI: paradinik, buke, jabolka, paprika, jagode. &quot; Najprej odstranimo odvene zaetne in konne presledke. To storimo s str_trim(): listek &lt;- str_trim(listek) listek ## [1] &quot;KUPI: paradinik, buke, jabolka, paprika, jagode.&quot; Funkcija str_sub() vrne podniz glede na indekse znakov: str_sub(listek, 7, 16) # Vrne znake med indeksom 7 do 16. ## [1] &quot;paradinik&quot; str_sub(listek, 7) # Vrne znake od sedmega naprej. ## [1] &quot;paradinik, buke, jabolka, paprika, jagode.&quot; str_sub(listek, -7) # Vrne zadnjih sedem znakov. ## [1] &quot;jagode.&quot; str_sub(listek, -7, -2) # Vrne predzadnjih est znakov. ## [1] &quot;jagode&quot; S tem znanjem lahko odstranimo prvih est znakov in zadnjega: listek &lt;- str_sub(listek, 7, -2) listek ## [1] &quot;paradinik, buke, jabolka, paprika, jagode&quot; Sedaj, ko imamo elemente samo natete in loene z vejico, jih lahko preprosto razdelimo s funkcijo str_split(), ki jipodamo vzorec za loevanje: str_split(listek, pattern = &quot;, &quot;) ## [[1]] ## [1] &quot;paradinik&quot; &quot;buke&quot; &quot;jabolka&quot; &quot;paprika&quot; &quot;jagode&quot; 3.2.2 Iskanje vzorcev z regularnimi izrazi Regularni izrazi so mono orodje za iskanje poljubnega vzorca v nizih. V tem poglavju bo predstavljena osnovna funkcionalnost regularnih izrazov, saj bi zaradi njihove fleksibilnosti posvetili eno ali celo dve poglavji le tem. Za prikaz delovanja bomo uporabljali funkciji str_view() in str_view_all(), ki uporabljata paket htmlwidges za prikaz rezultatov. Prva oznai samo prvo ujemanje, druga pa vsa ujemanja. Uporabljamo jih lahko v vseh funkcijah paketa stringr, ki imajo kot vhod pattern. Na koncu bomo pokazali uporabo nekaterih funkcij, ki uporabljajo vzorce. Sestavimo dva lista nad katerimi bomo iskali vzorce in za zaetek poiimo vse vejice. library(htmlwidgets) listek1 &lt;- &quot;KUPI: paradinik, buke, jabolka, paprika, jagode. Aja, pa banane.&quot; listek2 &lt;- &quot;KUPI: sok(3x), kruh, pikote, pato(2x), sol in poper.&quot; # str_view_all(c(listek1, listek2), &quot;,&quot;) 3.2.3 Uporaba regularnih izrazov Poglejmo si uporabo regularnih izrazov najprej na preprostih podatkih, nato pa e na podatkih iz e znane ankete. Poiimo vso sadje in zelenjavo, ki vsebuje umnike: seznam &lt;- c(&quot;paradinik&quot;, &quot;buke&quot;, &quot;jabolka&quot;, &quot;paprika&quot;, &quot;jagode&quot;); str_detect(seznam, &quot;[]&quot;) ## [1] TRUE TRUE FALSE FALSE FALSE e elimo namesto loginega vektorja dobiti dejanska imena elementov uporabimo str_subset(). str_subset(seznam, &quot;[]&quot;) ## [1] &quot;paradinik&quot; &quot;buke&quot; Poglejmo koliko samoglasnikov vsebuje vsaka beseda v seznamu. Pozor, funkcija str_count() ne zazna ponovitev, e se le te prekrivajo. str_count(seznam, &quot;[aeiou]&quot;) ## [1] 4 2 3 3 3 str_count(&quot;ababa&quot;, &quot;aba&quot;) # Ne zazna dveh ponovitev, ker se prekrivata. ## [1] 1 S funkcijo str_locate() vrnemo indekse lokacij najdenih vzorcev, s str_extract() pa dobimo ta vzorec oziroma podniz. S str_match() dobimo podskupine. Poiimo podnize do prvega umnika. str_locate(seznam, &quot;^.*[]&quot;) ## start end ## [1,] 1 7 ## [2,] 1 3 ## [3,] NA NA ## [4,] NA NA ## [5,] NA NA str_extract(seznam, &quot;^.*[]&quot;) ## [1] &quot;paradi&quot; &quot;bu&quot; NA NA NA str_match(seznam, &quot;(^.*)([])&quot;) ## [,1] [,2] [,3] ## [1,] &quot;paradi&quot; &quot;paradi&quot; &quot;&quot; ## [2,] &quot;bu&quot; &quot;bu&quot; &quot;&quot; ## [3,] NA NA NA ## [4,] NA NA NA ## [5,] NA NA NA V zadnjem primeru funkcija str_match() v prvem stolpcu vrne enako kot str_extract(), nato pa v naslednjih stolpcih vrne e vsako skupino posebej. Preprosta in zelo uporabna pa je funkcija str_replace() oziroma str_replace_all() s katero lahko zamenjamo dele nizov. Prekrijmo umnike z znaki x. str_replace(seznam, &quot;[]&quot;, &quot;x&quot;) ## [1] &quot;paradixnik&quot; &quot;buxke&quot; &quot;jabolka&quot; &quot;paprika&quot; &quot;jagode&quot; Podamo lahko tudi zamenjavo za ve ujemanj: str_replace_all(seznam, c(&quot;&quot; = &quot;c&quot;, &quot;&quot; = &quot;s&quot;, &quot;&quot;= &quot;z&quot;)) ## [1] &quot;paradiznik&quot; &quot;bucke&quot; &quot;jabolka&quot; &quot;paprika&quot; &quot;jagode&quot; Poglejmo si sedaj e uporabo na realnih podatkih. Najprej naloimo podatke: ds_jobs &lt;- read.csv2(&quot;./data-raw/DS-jobs.csv&quot;) ds_jobs &lt;- tibble(ds_jobs) ds_jobs ## # A tibble: 4,523 x 17 ## Gender Country Age EmploymentStatus CurrentJobTitle LanguageRecomme~ ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Female Austral~ 43 Employed full-time Business Analyst Python ## 2 Male Russia 33 Employed full-time Software Develop~ Python ## 3 Male Taiwan 26 Employed full-time Software Develop~ Python ## 4 Male United ~ 25 Employed part-time Researcher Python ## 5 Male United ~ 33 Employed full-time Scientist/Resear~ Matlab ## 6 Male Czech R~ 21 Employed part-time Other Python ## 7 Male Russia 22 Employed full-time Data Analyst Python ## 8 Male Netherl~ 51 Employed full-time Engineer R ## 9 Male Colombia 34 Employed full-time Data Scientist Python ## 10 Male Germany 41 Independent contrac~ Data Scientist Python ## # ... with 4,513 more rows, and 11 more variables: FormalEducation &lt;chr&gt;, ## # Major &lt;chr&gt;, CompensationAmount &lt;dbl&gt;, CompensationCurrency &lt;chr&gt;, ## # TimeGatheringData &lt;int&gt;, TimeModelBuilding &lt;dbl&gt;, TimeProduction &lt;dbl&gt;, ## # TimeVisualizing &lt;dbl&gt;, TimeFindingInsights &lt;dbl&gt;, TimeOtherSelect &lt;int&gt;, ## # ExchangeRate &lt;dbl&gt; Najbolj uporabna funkcija pri delu z nizi v podatkih je str_detect(), ki nam omogoa izbiro podmnoice vrstic. Pogosto jo kombiniramo z regularnimi izrazi. Poiimo tiste vrstice, kjer imajo anketiranci ve slubenih nazivov. Ti so loeni z znakom /. ds_jobs %&gt;% select(CurrentJobTitle) %&gt;% filter(str_detect(CurrentJobTitle, &quot;/&quot;)) ## # A tibble: 946 x 1 ## CurrentJobTitle ## &lt;chr&gt; ## 1 Software Developer/Software Engineer ## 2 Software Developer/Software Engineer ## 3 Scientist/Researcher ## 4 Software Developer/Software Engineer ## 5 Scientist/Researcher ## 6 Scientist/Researcher ## 7 Scientist/Researcher ## 8 Scientist/Researcher ## 9 Software Developer/Software Engineer ## 10 Scientist/Researcher ## # ... with 936 more rows Izberimo samo tiste vrstice, kjer se CurrentJobTitle zane z Data in se EmploymentStatus kona s full-time: ds_jobs %&gt;% select(EmploymentStatus, CurrentJobTitle) %&gt;% filter(str_detect(CurrentJobTitle, &quot;^Data&quot;), str_detect(EmploymentStatus, &quot;full-time$&quot;)) ## # A tibble: 1,679 x 2 ## EmploymentStatus CurrentJobTitle ## &lt;chr&gt; &lt;chr&gt; ## 1 Employed full-time Data Analyst ## 2 Employed full-time Data Scientist ## 3 Employed full-time Data Scientist ## 4 Employed full-time Data Scientist ## 5 Employed full-time Data Analyst ## 6 Employed full-time Data Scientist ## 7 Employed full-time Data Scientist ## 8 Employed full-time Data Analyst ## 9 Employed full-time Data Analyst ## 10 Employed full-time Data Scientist ## # ... with 1,669 more rows Vasih so nizi v podatkih predolgi, oziroma lahko brez kode za pomen izbriemo del niza. Najlaje to naredimo tako, da ga zamenjamo s praznim nizom. Izbriimo podnize Employed: ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = str_replace(EmploymentStatus, &quot;Employed &quot;, &quot;&quot;)) ds_jobs %&gt;% select(EmploymentStatus, CurrentJobTitle) ## # A tibble: 4,523 x 2 ## EmploymentStatus CurrentJobTitle ## &lt;chr&gt; &lt;chr&gt; ## 1 full-time Business Analyst ## 2 full-time Software Developer/Software En~ ## 3 full-time Software Developer/Software En~ ## 4 part-time Researcher ## 5 full-time Scientist/Researcher ## 6 part-time Other ## 7 full-time Data Analyst ## 8 full-time Engineer ## 9 full-time Data Scientist ## 10 Independent contractor, freelancer, or self-~ Data Scientist ## # ... with 4,513 more rows Sedaj imamo eno manjo nekonsistentnost v podatkih, namre nekateri nizi se zanejo z veliko zaetnico, nekateri pa z malo. Spremenimo vse na malo zaetnico: ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = str_to_lower(EmploymentStatus)) ds_jobs %&gt;% select(EmploymentStatus, CurrentJobTitle) ## # A tibble: 4,523 x 2 ## EmploymentStatus CurrentJobTitle ## &lt;chr&gt; &lt;chr&gt; ## 1 full-time Business Analyst ## 2 full-time Software Developer/Software En~ ## 3 full-time Software Developer/Software En~ ## 4 part-time Researcher ## 5 full-time Scientist/Researcher ## 6 part-time Other ## 7 full-time Data Analyst ## 8 full-time Engineer ## 9 full-time Data Scientist ## 10 independent contractor, freelancer, or self-~ Data Scientist ## # ... with 4,513 more rows S funkcijo str_count() lahko uporabimo, da anketirancem dodamo stolpec s tevilom slubenih nazivov: ds_jobs %&gt;% select(CurrentJobTitle) %&gt;% mutate(NumberOfJobTitles = str_count(CurrentJobTitle, &quot;/&quot;) + 1) ## # A tibble: 4,523 x 2 ## CurrentJobTitle NumberOfJobTitles ## &lt;chr&gt; &lt;dbl&gt; ## 1 Business Analyst 1 ## 2 Software Developer/Software Engineer 2 ## 3 Software Developer/Software Engineer 2 ## 4 Researcher 1 ## 5 Scientist/Researcher 2 ## 6 Other 1 ## 7 Data Analyst 1 ## 8 Engineer 1 ## 9 Data Scientist 1 ## 10 Data Scientist 1 ## # ... with 4,513 more rows Poskuajmo razdeliti CurrentJobTitle na FirstTitle in SecondTitle, pri tem naj se naziva ponovita, e ima anketiranec samo enega. ds_jobs %&gt;% select(CurrentJobTitle) %&gt;% mutate(FirstTitle = str_extract(CurrentJobTitle, &quot;^[^/]*&quot;), SecondTitle = str_extract(CurrentJobTitle, &quot;[^/]*$&quot;)) ## # A tibble: 4,523 x 3 ## CurrentJobTitle FirstTitle SecondTitle ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Business Analyst Business Analyst Business Analyst ## 2 Software Developer/Software Engineer Software Developer Software Engineer ## 3 Software Developer/Software Engineer Software Developer Software Engineer ## 4 Researcher Researcher Researcher ## 5 Scientist/Researcher Scientist Researcher ## 6 Other Other Other ## 7 Data Analyst Data Analyst Data Analyst ## 8 Engineer Engineer Engineer ## 9 Data Scientist Data Scientist Data Scientist ## 10 Data Scientist Data Scientist Data Scientist ## # ... with 4,513 more rows 3.3 Kategorine spremenljivke Kategorine spremenljivke so spremenljivke, ki lahko zavzamejo samo vnaprej doloene vrednosti. Delimo jih na: Nominalne spremenljivke. To so spremenljivke brez ureditve. Na primer, spol ali vrsta avtomobila. Ordinalne spremenljivke. To so spremenljivke, ki imajo smiselno ureditev. Na primer, stopnja izobrazbe ali olski uspeh. V R uporabljamo za delo s kategorinimi spremenljivkami t. i. faktorje (ang. factor). Ti se od spremenljivk tipa niz razlikujejo v tem, da se v spremenljivki hrani informacija o vseh monih vrednostih. Prav tako ni mogoe faktorju dodati vrednosti, ki je ni v mnoici monih vrednosti, kar slui kot varovalka pred napakami pri vnosu podatkov. Poglejmo si uporabo faktorja na dveh preprostih primerih, kjer bomo sami ustvarili spremenljivki. Kasneje si bomo ogledali e delo s faktorji na primeru realnih podatkov, kjer bomo ponovno uporabili podatke o zaposlitvah na podroju podatkovnih ved. Kot primer nominalne spremenljivke si oglejmo krvne skupine. Obstajajo 4 mone vrednosti. Ustvarimo sedaj vektor krvnih skupin: krvne_skupine &lt;- c(&quot;B&quot;, &quot;B&quot;, &quot;O&quot;, &quot;AB&quot;, &quot;BA&quot;) Sedaj je ta vektor shranjen kot niz. Kaj so slabosti taknega shranjevanja kategorinih podatkov? Prvi, nimamo nobenega varovala pred tipkarskimi napakami  R je zadnji vnos prebral kot BA in ga tako tudi shranil, eprav ta krvna skupina ne obstaja: krvne_skupine ## [1] &quot;B&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;BA&quot; Pri ronem vnosu podatkoh hitro pride do tipkarskih napak in naeloma ne vemo, ali je avtor podatkov v tme primeru elel vnesti A, B ali AB. Drugi, e elimo urediti to spremenljivko, se bodo vrednosti razvrstile po abecedi: sort(krvne_skupine) ## [1] &quot;AB&quot; &quot;B&quot; &quot;B&quot; &quot;BA&quot; &quot;O&quot; Morda pa bi bilo bolj smiselno urediti po standardni ureditvi, torej A, B, AB, O. Da se izognemo tem teavam je bolje, e spremenljiko za katero vemo, da bo zasedla eno od vnaprej doloenih vrednosti, shranimo kot faktor. V R za to uporabimo funkcijo factor(). Poizkusimo sedaj narediti faktor iz spremenljivke dan_v_tednu. krvne_skupine_fac &lt;- factor(krvne_skupine) krvne_skupine_fac ## [1] B B O AB BA ## Levels: AB B BA O Opazimo, da je sedaj spremenljivka druganega tipa, saj hrani tudi informacijo o monih vrednostih oziroma ravneh (ang. levels). Ampak v tem primeru so te ravni napane (ne zajame vseh 4 krvnih skupin, poleg tega pa vsebuje tudi eno napano vrednost). Funkcija factor() privzeto kot ravni nastavi vse vrednosti v podani spremenljivki. e elimo, ji lahko podamo dodaten argument levels, kjer rono doloimo, katere ravni bodo v spremenljivki. V kolikor to vemo vnaprej, je dobra praksa da podamo tudi ta argument. krvne_skupine_fac &lt;- factor(krvne_skupine, levels = c(&quot;A&quot;, &quot;B&quot;, &quot;AB&quot;, &quot;O&quot;)) krvne_skupine_fac ## [1] B B O AB &lt;NA&gt; ## Levels: A B AB O sort(krvne_skupine_fac) ## [1] B B AB O ## Levels: A B AB O Opazimo dvoje: sedaj lahko spremenljivko uredimo glede na standardno notacijo in nesmiselne vrednosti se spremenijo v NA. Faktorju torej ne moremo prirediti vrednosti, ki ni enaka eni izmed vrednosti v ravneh. Da dostopamo do vseh ravni faktorja, uporabimo funkcijo levels(): levels(krvne_skupine_fac) ## [1] &quot;A&quot; &quot;B&quot; &quot;AB&quot; &quot;O&quot; Vasih imajo kategorine spremenljivke tudi smiselno razvrstitev po velikosti, ki pa se obiajno ne da numerino izmeriti. Kot primer si poglejmo olski uspeh, ki lahko zavzame 5 vrednosti. V kolikor elimo, da faktor hrani tudi informacijo o tem, da obstaja smiselna razvrstitev po velikosti, dodamo argument ordered = TRUE. uspeh &lt;- factor(c(&quot;odlino&quot;, &quot;dobro&quot;, &quot;dobro&quot;, &quot;prav dobro&quot;), levels = c(&quot;nezadostno&quot;, &quot;zadostno&quot;, &quot;dobro&quot;, &quot;prav dobro&quot;, &quot;odlino&quot;), ordered = TRUE) uspeh ## [1] odlino dobro dobro prav dobro ## Levels: nezadostno &lt; zadostno &lt; dobro &lt; prav dobro &lt; odlino Opazimo, da imamo sedaj pri izpisu nivojev dodatno informacijo o razvrstitvi uspeha. V praksi nam to omogoa primerjamo, medtem ko tega pri faktorjih, ki nimajo razvrstitve po velikosti, ne moremo narediti. uspeh[2] &gt; uspeh[1] ## [1] FALSE krvne_skupine_fac[2] &gt; krvne_skupine_fac[1] ## Warning in Ops.factor(krvne_skupine_fac[2], krvne_skupine_fac[1]): &#39;&gt;&#39; not ## meaningful for factors ## [1] NA Poleg prednosti, ki smo jih e omenili (varovanje pred napakami in smiselna razvrstitev nivojev) imajo faktorji tudi posebno vlogo pri raznih statistinih modelih in modelih strojnega uenja. Nekatere metode eksplicitno zahtevajo faktorje. Prav tako razlikujejo med nominalnimi in ordinalnimi faktorji, kar se pozna na rezultatih. Relativno preprost primer tega je linearna regresija, ki pa je izven obsega te delavnice. Vsekakor pa si je to vredno zapomniti, v kolikor se boste kdaj ukvajrali s podobnimi modeli in boste eleli uporabiti kategorine spremenljivke. Poglejmo si uporabo faktorjev na realni podatkovni mnoici. Ponovno bomo delali s podatki o zaposlitvah na podroju podatkovnih ved. Preberimo podatke in ponovimo nekaj operacij, ki smo jih spoznali na prvem predavanju. Prav tako bomo izbrali samo podmnoico stolpcev za bolj jasen prikaz. library(tidyverse) ds_jobs &lt;- read_csv2(&quot;./data-raw/DS-jobs.csv&quot;) %&gt;% select(Country, Age, EmploymentStatus, FormalEducation, CompensationAmount, ExchangeRate) %&gt;% filter(!is.na(ExchangeRate)) %&gt;% mutate(CompensationUSD = CompensationAmount * ExchangeRate) %&gt;% filter(CompensationUSD &lt;= 2500000, CompensationUSD &gt;= 10000) ds_jobs ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; Imamo 3 spremenljivke, ki bi jih bilo smiselno shraniti kot faktorje  Country, EmploymentStatus in FormalEducation. Pretvorimo sedaj ti spremenljivki v faktorje. Pri tem pustimo kar privzeto nastavitev, da se kot nivoji uporabijo vse vrednosti v stolpcih. library(tidyverse) ds_jobs &lt;- ds_jobs %&gt;% mutate(Country = factor(Country), EmploymentStatus = factor(EmploymentStatus), FormalEducation = factor(FormalEducation)) ds_jobs ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; levels(ds_jobs$Country) ## [1] &quot;Argentina&quot; &quot;Australia&quot; ## [3] &quot;Belarus&quot; &quot;Belgium&quot; ## [5] &quot;Brazil&quot; &quot;Canada&quot; ## [7] &quot;Chile&quot; &quot;Colombia&quot; ## [9] &quot;Czech Republic&quot; &quot;Denmark&quot; ## [11] &quot;Egypt&quot; &quot;Finland&quot; ## [13] &quot;France&quot; &quot;Germany&quot; ## [15] &quot;Greece&quot; &quot;Hong Kong&quot; ## [17] &quot;Hungary&quot; &quot;India&quot; ## [19] &quot;Indonesia&quot; &quot;Iran&quot; ## [21] &quot;Ireland&quot; &quot;Israel&quot; ## [23] &quot;Italy&quot; &quot;Japan&quot; ## [25] &quot;Kenya&quot; &quot;Malaysia&quot; ## [27] &quot;Mexico&quot; &quot;Netherlands&quot; ## [29] &quot;New Zealand&quot; &quot;Nigeria&quot; ## [31] &quot;Norway&quot; &quot;Other&quot; ## [33] &quot;Pakistan&quot; &quot;People &#39;s Republic of China&quot; ## [35] &quot;Philippines&quot; &quot;Poland&quot; ## [37] &quot;Portugal&quot; &quot;Republic of China&quot; ## [39] &quot;Romania&quot; &quot;Russia&quot; ## [41] &quot;Singapore&quot; &quot;South Africa&quot; ## [43] &quot;South Korea&quot; &quot;Spain&quot; ## [45] &quot;Sweden&quot; &quot;Switzerland&quot; ## [47] &quot;Taiwan&quot; &quot;Turkey&quot; ## [49] &quot;Ukraine&quot; &quot;United Kingdom&quot; ## [51] &quot;United States&quot; &quot;Vietnam&quot; levels(ds_jobs$EmploymentStatus) ## [1] &quot;Employed full-time&quot; ## [2] &quot;Employed part-time&quot; ## [3] &quot;Independent contractor, freelancer, or self-employed&quot; levels(ds_jobs$FormalEducation) ## [1] &quot;Bachelor&#39;s degree&quot; ## [2] &quot;Doctoral degree&quot; ## [3] &quot;I did not complete any formal education past high school&quot; ## [4] &quot;I prefer not to answer&quot; ## [5] &quot;Master&#39;s degree&quot; ## [6] &quot;Professional degree&quot; ## [7] &quot;Some college/university study without earning a bachelor&#39;s degree&quot; Kaj se zgodi, e elimo v tibblu spremeniti vrednost faktorja, v neko vrednost, ki je ni v tem faktorju? Recimo, da elimo v 2. vrstici spremeniti dravo v Narnia: ds_jobs2 &lt;- ds_jobs ds_jobs2$Country[2] &lt;- &quot;Narnia&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 2, value = structure(c(2L, NA, 47L, 51L, : ## invalid factor level, NA generated ds_jobs2 ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 &lt;NA&gt; 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; Ker Narnia ni nivo v faktorju, se nadomesti z NA. e elimo dodati nov nivo temu faktorju, uporabimo fct_expand(): ds_jobs2 &lt;- ds_jobs %&gt;% mutate(Country = fct_expand(Country, &quot;Narnia&quot;)) ds_jobs2$Country[2] &lt;- &quot;Narnia&quot; ds_jobs2 ## # A tibble: 3,186 x 7 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 Employed full-t~ Bachelor&#39;s deg~ 80000 0.802 ## 2 Narnia 33 Employed full-t~ Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 Employed full-t~ Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 Employed part-t~ Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 Employed full-t~ Doctoral degree 100000 1 ## 6 Russia 22 Employed full-t~ Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 Employed full-t~ Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 Independent con~ I did not comp~ 150000 1.20 ## 9 Poland 29 Employed full-t~ Master&#39;s degree 126000 0.281 ## 10 United ~ 35 Employed full-t~ Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 1 more variable: CompensationUSD &lt;dbl&gt; 3.3.1 Sprememba razvrstitve faktorja Kot smo omenili e pri krvnih skupinah imajo velikokrat tudi faktorji, ki niso razvreni po velikosti, neko ustaljeno razvrstitev. Razvrstitev pa lahko tudi kasneje spremenimo. Ta operacija je obiajno uporabna pri vizualizaciji. Poglejmo si, na primer, kako so plae povezane z izobrazbo. Za vizualizacijo rezultatov bomo uporabili razsevni diagram: ds_jobs_agg &lt;- ds_jobs %&gt;% group_by(FormalEducation) %&gt;% summarise(MeanCompensationUSD = mean(CompensationUSD)) ds_jobs_agg ## # A tibble: 8 x 2 ## FormalEducation MeanCompensationU~ ## &lt;fct&gt; &lt;dbl&gt; ## 1 Bachelor&#39;s degree 71665. ## 2 Doctoral degree 90856. ## 3 I did not complete any formal education past high school 78470. ## 4 I prefer not to answer 90023. ## 5 Master&#39;s degree 78411. ## 6 Professional degree 64614. ## 7 Some college/university study without earning a bachelor&#39;s~ 105675. ## 8 &lt;NA&gt; 47833. ggplot(ds_jobs_agg, aes(x = FormalEducation, y = MeanCompensationUSD)) + geom_point() + coord_flip() Ta graf je sicer zelo informativen, ampak bi s teavo hitro ugotovili, kako so nivoji faktorja razvreni glede na plao. ggplot razvrsti vrednosti glede na to, kako so razvrene v faktorju: levels(ds_jobs$FormalEducation) ## [1] &quot;Bachelor&#39;s degree&quot; ## [2] &quot;Doctoral degree&quot; ## [3] &quot;I did not complete any formal education past high school&quot; ## [4] &quot;I prefer not to answer&quot; ## [5] &quot;Master&#39;s degree&quot; ## [6] &quot;Professional degree&quot; ## [7] &quot;Some college/university study without earning a bachelor&#39;s degree&quot; Morda bi bilo bolje tak graf urediti glede na vrednosti spremenljivke MeanCompensationUSD. Za to moramo doloiti novo razvrstitev te spremenljivke. Za to obstaja v paketu forcats, ki je del tidyverse, funkcija fct_reorder(). ggplot(ds_jobs_agg, aes(x = fct_reorder(FormalEducation, MeanCompensationUSD), y = MeanCompensationUSD)) + geom_point() + coord_flip() Razvrstitev lahko uredimo tudi rono s funkicjo fct_relevel(), ki ohrani privzeto razvrstitev s tem, da podane nivoje premakne na zaetek, oziroma lahko podamo arguemnt after. ggplot(ds_jobs_agg, aes(x = fct_relevel(FormalEducation, &quot;I prefer not to answer&quot;, &quot;I did not complete any formal education past high school&quot;, after = 0), y = MeanCompensationUSD)) + geom_point() + coord_flip() 3.3.2 Preimenivanje obstojeih in doloanje novih nivojev Nivoje faktorjev lahko preimenujemo s funkcijo fct_recode(). ds_jobs &lt;- ds_jobs %&gt;% mutate(EmploymentStatus = fct_recode(EmploymentStatus, &quot;full-time&quot; = &quot;Employed full-time&quot;, &quot;part-time&quot; = &quot;Employed part-time&quot;, &quot;other&quot; = &quot;Independent contractor, freelancer, or self-employed&quot;)) head(ds_jobs$EmploymentStatus) ## [1] full-time full-time full-time part-time full-time full-time ## Levels: full-time part-time other Sorodno lahko zgornjo funkcijo zamenjamo z fct_collapse(), ki lahko zdrui ve nivojev v enega. 3.3.3 Razbitje numerine spremenljivke na intervale Pogosto elimo kakno numerino spremenljivko segmentirati na doloene intervale. Na primer, pri doloanju avtomobilskih zavarovalnih premij lahko zavarovance segmentiramo glede na starost. V R za to uporabimo funkcijo cut(). Razdelimo spremenljivko Age na intervale, kjer bodo osebe razdeljene do 25 let, nad 25 in to 35 let, nad 35 do 50 let, in nad 50 let. ds_jobs &lt;- ds_jobs %&gt;% mutate(AgeInterval = cut(Age, breaks = c(0, 25, 35, 50, 100))) ds_jobs_agg &lt;- ds_jobs %&gt;% group_by(AgeInterval) %&gt;% summarise(CompensationByAge = mean(CompensationUSD)) ggplot(ds_jobs_agg, aes(x = AgeInterval, y = CompensationByAge)) + geom_point() 3.4 Datumi in ure Delo z datumi in urami morda na prvi pogled deluje precej enostavno. Vendar pa zaradi razlinih fizikalnih zakonitosti ali lovekih konstruktov lahko pride do teav. Na primer, vsako leto nima 365 dni. Prav tako v nekaterih asovnih conah 3. ura zjutraj ne sledi vedno 2. uri, saj pride do premika ure. Za delo z datumi bomo uporabljali paket lubridate. Glavni komponenti v tem paketu sta datum (date) in as (time), ter zdruena komponenta datum in as (datetime). S tem paketom lahko datume ustvarimo na 2 naina: Z nizom: library(lubridate) ymd(&quot;2021-04-02&quot;) ## [1] &quot;2021-04-02&quot; ymd(&quot;2021/04/02&quot;) ## [1] &quot;2021-04-02&quot; ymd(20210402) ## [1] &quot;2021-04-02&quot; dmy(&quot;02.04.2021&quot;) ## [1] &quot;2021-04-02&quot; ymd_hms(&quot;2021-04-02 12:01:00&quot;) # Tipa datetime. ## [1] &quot;2021-04-02 12:01:00 UTC&quot; ymd(20210402, 20210403) ## [1] &quot;2021-04-02&quot; &quot;2021-04-03&quot; mdy(&quot;April 2nd, 2021&quot;) # Deluje za angleka imena mesecev ## [1] &quot;2021-04-02&quot; S posameznimi komponentami: make_date(2021, 4, 2) ## [1] &quot;2021-04-02&quot; make_datetime(2021, 4, 2, 12, 1, 0) ## [1] &quot;2021-04-02 12:01:00 UTC&quot; Opazimo, da pri datumu in asu spremenljivka hrani tudi informacijo o asovnem pasu. Privzeto lubridate dela s asovnim pasom UTC (Coordinated Universal Time), ki je naslednik GMT (Greenwich Mean Time). Prednost tega asovnega pasu je predvsem v tem, da se ne prilagaja spremembi ure v pomladnih in jesenskih mesecih. Te spremembe lahko privedejo do napak pri raunanju z datumi in asi, tako da je raunanje v UTC bolj varno. Seveda pa lahko rono nastavimo drugi asovni pas z argumentom tz. Paket lubridate uporablja IANA asovne pasove (https://www.iana.org/time-zones), kateri so definirani s kombinacijo celine in drave. Na primer, za Ljubljano bi asovni pas nastavili tako: ymd_hms(&quot;2021-04-02 12:01:00&quot;, tz = &quot;Europe/Ljubljana&quot;) ## [1] &quot;2021-04-02 12:01:00 CEST&quot; Pomembno je torej, da vemo, v katerem asovnem pasu so bile opravljene meritve v naih podatkih, da lahko potem ustrezno pretvorimo spremenljivko v asovno. Seveda pa lahko tudi pretvarjamo asovne spremenljivke med asovnimi pasovi. Za to uporabimo funkcijo with_tz(). Vsakemu asu v doloenem asovnem pasu lahko priredimo nek as v drugem asovnem pasu. V kolikor elimo bolj robustno raunati z datumi in urami, potem lahko vedno datume pretvorimo v UTC as, naredimo izraune in potem pretvorimo nazaj v lokalni asovni pas. my_datetime &lt;- ymd_hms(&quot;2021-04-02 12:01:00&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime ## [1] &quot;2021-04-02 12:01:00 CEST&quot; my_datetime_UTC &lt;- with_tz(my_datetime, tz = &quot;UTC&quot;) my_datetime_UTC ## [1] &quot;2021-04-02 10:01:00 UTC&quot; Hranita pa spremenljivki v ozadju isti as. To lahko preverimo z: my_datetime == my_datetime_UTC ## [1] TRUE V R je asovni pas namenjen samo izpisu datumov in asov. Sama vrednost spremenljivke ostane nespremenjena. To lahko preverimo tako, da odtejemo en datum od drugega, kar nam vrne razliko v asu: my_datetime - my_datetime_UTC ## Time difference of 0 secs V kolikor smo narobe prebrali datum v zaetku (na primer, v podatkih je bil datum v UTC, prebrali pa smo v lokalnem asu) zgornja pretvorba med asovnimi pasovi ni ustrezna, saj bomo s tem zajeli napaen as. V tem primeru moramo uporabiti funkcijo force_tz(). Predlagamo, da udeleenci sami poizkusijo, kaj naredi ta funkcija, tako da z njo pretvorijo my_datetime v UTC in potem izraunajo razliko, podobno kot smo to naredili zgoraj. Kadar delamo sekvence datumov in asov te upotevajo premik ure in prehodov v naslednje dni. Poglejmo si prehod na poletni as v letu 2021: datetime_dst &lt;- seq(ymd_hms(&quot;2021-03-28 00:00:00&quot;, tz = &quot;Europe/Ljubljana&quot;), ymd_hms(&quot;2021-03-28 04:00:00&quot;, tz = &quot;Europe/Ljubljana&quot;), by = &quot;30 min&quot;) datetime_dst ## [1] &quot;2021-03-28 00:00:00 CET&quot; &quot;2021-03-28 00:30:00 CET&quot; ## [3] &quot;2021-03-28 01:00:00 CET&quot; &quot;2021-03-28 01:30:00 CET&quot; ## [5] &quot;2021-03-28 03:00:00 CEST&quot; &quot;2021-03-28 03:30:00 CEST&quot; ## [7] &quot;2021-03-28 04:00:00 CEST&quot; with_tz(datetime_dst, tz = &quot;UTC&quot;) ## [1] &quot;2021-03-27 23:00:00 UTC&quot; &quot;2021-03-27 23:30:00 UTC&quot; ## [3] &quot;2021-03-28 00:00:00 UTC&quot; &quot;2021-03-28 00:30:00 UTC&quot; ## [5] &quot;2021-03-28 01:00:00 UTC&quot; &quot;2021-03-28 01:30:00 UTC&quot; ## [7] &quot;2021-03-28 02:00:00 UTC&quot; Pozorni moramo biti tudi na kombiniranje datumov. V kolikor uporabimo funkcijo c(), vedno preverimo, v katerem asovnem pasu je rezultat. 3.4.1 Raunanje z datumi in asi Vsaka asovna spremenljivka, ki vsebuje datum in as, je sestavljena iz komponent. Te so leto, mesec, dan, ura, minuta in sekunda. Za dostop do posameznih komponent imamo na voljo ve funkcij: year() month() mday(). Dan v mesecu. wday(). Dan v tednu. Privzeto se zane z nedeljo. To lahko spremenimo z argumentom week_start. hour() minute() second() Poglejmo sedaj kaj vraajo te funkcije: x &lt;- now() x ## [1] &quot;2021-06-11 17:25:15 CEST&quot; year(x) ## [1] 2021 month(x) ## [1] 6 mday(x) ## [1] 11 wday(x) ## [1] 6 wday(x, week_start = 1) ## [1] 5 hour(x) ## [1] 17 minute(x) ## [1] 25 second(x) ## [1] 15.71094 S komponentami lahko tudi spreminjamo dele asovne spremenljivke: mday(x) &lt;- 5 x ## [1] &quot;2021-06-05 17:25:15 CEST&quot; Pri raunanju s asovnimi enotami v lubridate poznamo tri razrede: trajanja (ang. duration). as v sekundah. Funkcije dseconds(), dminutes(), ddays(), dweeks() in dyears(). Pri trajanjih se vedno uporabi pretvorba, da ima vsak dan 24 ur in vsako leto 365.25 dni. Slednje predstavlja povpreno teilo dni v letu. Tako da bo funkcija dyears(4) vedno vrnila tevilo sekund, ki ustreza 4x365.25 dnem, ki imajo vsak po 24 ur. periode (ang. period). as v lovekih enotah kot je na primer teden. Funkcije seconds(), minutes(), days(), weeks(), months() in years(). intervali (ang. interval). asovni interval med dvema tokama. Pozoren bralec je morda opazil, da pri trajanjih nismo navedli funkcije za mesece. To je zaradi tega, ker imajo meseci lahko 28, 29, 30 ali 31 dni. Vsekakor bi pri izbiri osnovne enote za trajanja prilo do neke arbitrarne odloitve, koliko dni vzamemo privzeto. 30 ali 31? V vsakem primeru bo vsaj polovica mesecev imela napano trajanje. Pri dnevih in letih si laje privoimo posploitev. ddays(1) ## [1] &quot;86400s (~1 days)&quot; days(1) ## [1] &quot;1d 0H 0M 0S&quot; Poglejmo si preprost primer, kako dodati my_datetime &lt;- ymd_hms(&quot;2021/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + dminutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + minutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + months(2) ## [1] &quot;2021-08-08 11:05:30 CEST&quot; Trajanja in periode so si oitno zelo podobni ampak imajo eno veliko razliko, kadar raunamo z dnevi, tedni in leti. Prvi, kadar bomo uporabljali dyears() lahko hitro pride do teave, saj bomo priteli 0.25 dneva. Poglejmo si to na primeru: my_datetime + years(1) ## [1] &quot;2022-06-08 11:05:30 CEST&quot; my_datetime + dyears(1) ## [1] &quot;2022-06-08 17:05:30 CEST&quot; Opazimo, da smo priteli 6 dodatnih ur. Drugi, kaj se zgodi, kadar pritejemo teden ali dan v asu, ko pride do premika ure. Premik ure se je po lokalnem asu zgodil 28. 3. 2021 ob 2 zjutraj. my_datetime &lt;- ymd_hms(&quot;2021/03/27 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-03-28 12:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-03-28 11:05:30 CEST&quot; my_datetime + dweeks(1) ## [1] &quot;2021-04-03 12:05:30 CEST&quot; my_datetime + weeks(1) ## [1] &quot;2021-04-03 11:05:30 CEST&quot; Funkcija years() deluje kot bi priakovali tudi na prestopnem letu: my_datetime &lt;- ymd_hms(&quot;2020/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + years(1) ## [1] &quot;2021-06-08 11:05:30 CEST&quot; S funkcijami trajanja in period lahko tudi raunamo, na primer: dyears(2) + ddays(4) + dseconds(20) ## [1] &quot;63460820s (~2.01 years)&quot; days(2) + minutes(20) + seconds(120) ## [1] &quot;2d 0H 20M 120S&quot; 5 * dminutes(20) ## [1] &quot;6000s (~1.67 hours)&quot; 5 * minutes(20) ## [1] &quot;100M 0S&quot; Najbolje, da jo prikaemo na dveh primerih  premik ure in prestopno leto. Periode so bolj naraven prikaz za loveka. my_datetime &lt;- ymd_hms(&quot;2021/06/08 11:05:30&quot;, tz = &quot;Europe/Ljubljana&quot;) my_datetime + ddays(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + days(1) ## [1] &quot;2021-06-09 11:05:30 CEST&quot; my_datetime + dminutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + minutes(120) ## [1] &quot;2021-06-08 13:05:30 CEST&quot; my_datetime + dyears(1) ## [1] &quot;2022-06-08 17:05:30 CEST&quot; my_datetime + years(1) ## [1] &quot;2022-06-08 11:05:30 CEST&quot; my_datetime + months(2) ## [1] &quot;2021-08-08 11:05:30 CEST&quot; V bazi letalskih letov posodobimo podatke, tako da izraunamo niz, ki predstavlja toen odhod letala. library(nycflights13) head(flights) ## # A tibble: 6 x 20 ## ID year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 2013 1 1 517 515 2 830 ## 2 2 2013 1 1 533 529 4 850 ## 3 3 2013 1 1 542 540 2 923 ## 4 4 2013 1 1 544 545 -1 1004 ## 5 5 2013 1 1 554 600 -6 812 ## 6 6 2013 1 1 554 558 -4 740 ## # ... with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flights_datetime &lt;- flights %&gt;% select(year, month, day, hour, minute) %&gt;% mutate(DepartureTime = make_datetime(year, month, day, hour, minute)) flights_datetime ## # A tibble: 336,776 x 6 ## year month day hour minute DepartureTime ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 2013 1 1 5 15 2013-01-01 05:15:00 ## 2 2013 1 1 5 29 2013-01-01 05:29:00 ## 3 2013 1 1 5 40 2013-01-01 05:40:00 ## 4 2013 1 1 5 45 2013-01-01 05:45:00 ## 5 2013 1 1 6 0 2013-01-01 06:00:00 ## 6 2013 1 1 5 58 2013-01-01 05:58:00 ## 7 2013 1 1 6 0 2013-01-01 06:00:00 ## 8 2013 1 1 6 0 2013-01-01 06:00:00 ## 9 2013 1 1 6 0 2013-01-01 06:00:00 ## 10 2013 1 1 6 0 2013-01-01 06:00:00 ## # ... with 336,766 more rows head(flights_datetime$DepartureTime) ## [1] &quot;2013-01-01 05:15:00 UTC&quot; &quot;2013-01-01 05:29:00 UTC&quot; ## [3] &quot;2013-01-01 05:40:00 UTC&quot; &quot;2013-01-01 05:45:00 UTC&quot; ## [5] &quot;2013-01-01 06:00:00 UTC&quot; &quot;2013-01-01 05:58:00 UTC&quot; Ali opazimo kakno teavo? datume smo prebrali v asovni coni UTC, so pa podani v lokalni asovni coni. Podatkov torej nismo pretvorili pravilno! Poizkusimo e enkrat: flights_datetime &lt;- flights %&gt;% select(year, month, day, hour, minute) %&gt;% mutate(DepartureTime = make_datetime(year, month, day, hour, minute, tz = &quot;America/New_York&quot;)) flights_datetime ## # A tibble: 336,776 x 6 ## year month day hour minute DepartureTime ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 2013 1 1 5 15 2013-01-01 05:15:00 ## 2 2013 1 1 5 29 2013-01-01 05:29:00 ## 3 2013 1 1 5 40 2013-01-01 05:40:00 ## 4 2013 1 1 5 45 2013-01-01 05:45:00 ## 5 2013 1 1 6 0 2013-01-01 06:00:00 ## 6 2013 1 1 5 58 2013-01-01 05:58:00 ## 7 2013 1 1 6 0 2013-01-01 06:00:00 ## 8 2013 1 1 6 0 2013-01-01 06:00:00 ## 9 2013 1 1 6 0 2013-01-01 06:00:00 ## 10 2013 1 1 6 0 2013-01-01 06:00:00 ## # ... with 336,766 more rows head(flights_datetime$DepartureTime) ## [1] &quot;2013-01-01 05:15:00 EST&quot; &quot;2013-01-01 05:29:00 EST&quot; ## [3] &quot;2013-01-01 05:40:00 EST&quot; &quot;2013-01-01 05:45:00 EST&quot; ## [5] &quot;2013-01-01 06:00:00 EST&quot; &quot;2013-01-01 05:58:00 EST&quot; 3.5 Shranjevanje in branje podatkov 3.5.1 Delo z binarnimi datotekami V programskem jeziku R lahko shranjujemo in nalagamo (v trenutno sejo R) spremenljivke kot binarne objekte na dva prevladujoa naina: S kombinacijo funkcij save() in load(). S kombinacijo funkcij saveRDS() in readRDS(). Pomembna razlika med prvim in drugim pristopom je, da lahko s prvim shranimo ve spremenljivk naenkrat, z drugim pa samo eno. Na prvi pogled bi torej priakovali, da je prvi pristop bolji, oziroma bolj zaelen. Ampak ima eno pomembno slabost, zaradi katere predlagamo uporabo drugega pristopa. Funkcija save() shrani spremenljivke v trenutni seji R v datoteko s konnico rda ali RData. To naredi tako, da shrani tako vrednost spremenljivke kot tudi ime spremenljivke. To pomeni, da ko bomo takno datoteko prebrali v novo sejo R, bomo ustvarili spremenljivke z enakimi imeni, kot smo jih shranili. Pri tem pa lahko pride do teav. Recimo, da imamo v trenutni seji R e nek nabor spremenljivk nato pa elimo vanjo prenesti e neke druge spremenljivke, ki smo jih pred asom shranili s funkcijo save() v datoteko saved-data.rda. Kaj se bo zgodilo, e bo katera od spremenljivk v nai trenutni seji imela enako ime kot ena od spremenljivk shranjenih v saved-data.rda? R bo enostavno to spremenljivko prepisal s spremenljivko, ki se je nahajala v tej rda datoteki. Taken postopek dela je lahko torej nevaren, saj lahko nevede izbriemo obstojee spremenljivke. Predlagamo torej uporabo druge kombinacije, torej funkcij saveRDS() in readRDS(). Funkcija saveRDS() shrani samo vrednost spremenljivke, ne pa tudi njenega imena, tako da ne pride do podobnih teav kot pri prvem pristopu. Konnica tako shranjenih datotek je rds. Poglejmo si uporabo teh funkcij. x &lt;- c(3, 6, 3, 7) x ## [1] 3 6 3 7 saveRDS(x, &quot;./my-saved-files/my-x.rds&quot;) x2 &lt;- readRDS(&quot;./my-saved-files/my-x.rds&quot;) x2 ## [1] 3 6 3 7 Vedno ko preberemo podatke v sejo R s funkcijo readRDS() ji moramo prirediti ime, saj je v rds datoteki shrnajena samo njena vrednost. S tem se tudi izognemo podobnim teavam kot pri funkcijah save() in load(). Pomanjkljivost shranjevanja rds datotek pa je v tem, da lahko naenkrat shranimo samo 1 spremenljivko. Ampak to pomanjkljivost lahko zaobidemo, tako da ve spremenljivk enostavno shranimov v seznam (list()). Poglejmo si sedaj na primer, kako bi shranili ve spremenljivk. tmp_list &lt;- list( &quot;x&quot; = x, &quot;some_datetime&quot; = my_datetime, &quot;ds_jobs&quot; = ds_jobs ) saveRDS(tmp_list, &quot;./my-saved-files/my-list.rds&quot;) read_list &lt;- readRDS(&quot;./my-saved-files/my-list.rds&quot;) names(read_list) ## [1] &quot;x&quot; &quot;some_datetime&quot; &quot;ds_jobs&quot; x2 &lt;- read_list[[&quot;x&quot;]] x2 ## [1] 3 6 3 7 my_datetime2 &lt;- read_list[[&quot;some_datetime&quot;]] my_datetime2 ## [1] &quot;2021-06-08 11:05:30 CEST&quot; ds_jobs2 &lt;- read_list[[&quot;ds_jobs&quot;]] ds_jobs2 ## # A tibble: 3,186 x 8 ## Country Age EmploymentStatus FormalEducation CompensationAmo~ ExchangeRate ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral~ 43 full-time Bachelor&#39;s deg~ 80000 0.802 ## 2 Russia 33 full-time Bachelor&#39;s deg~ 1200000 0.0174 ## 3 Taiwan 26 full-time Master&#39;s degree 1100000 0.0333 ## 4 United ~ 25 part-time Bachelor&#39;s deg~ 20000 1 ## 5 United ~ 33 full-time Doctoral degree 100000 1 ## 6 Russia 22 full-time Bachelor&#39;s deg~ 624000 0.0174 ## 7 Colombia 34 full-time Master&#39;s degree 156000000 0.000342 ## 8 Germany 41 other I did not comp~ 150000 1.20 ## 9 Poland 29 full-time Master&#39;s degree 126000 0.281 ## 10 United ~ 35 full-time Doctoral degree 133000 1 ## # ... with 3,176 more rows, and 2 more variables: CompensationUSD &lt;dbl&gt;, ## # AgeInterval &lt;fct&gt; 3.5.2 Branje in shranjevanje z ostalimi datotekami 3.5.2.1 Excel Paket openxlsx omogoa delo z exelovimi razpredelnicami. Poglejmo si preproste a uporabne ukaze. Za branje podatkov s tem paketom uprabljamo read.xlsx(), za shranjevanje datotek pa write.xlsx(). Preberimo podatke ocen, ki smo jih imeli tudi v testni skripti in jo pretvorimo v tibble: library(openxlsx) ocene &lt;- tibble(openxlsx::read.xlsx(&quot;./test-script/data-raw/student-performance.xlsx&quot;)) ocene ## # A tibble: 649 x 12 ## school sex famsize Pstatus traveltime studytime internet absences G1 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP F GT3 A 2 2 no 4 0 ## 2 GP F GT3 T 1 2 yes 2 9 ## 3 GP F LE3 T 1 2 yes 6 12 ## 4 GP F GT3 T 1 3 yes 0 14 ## 5 GP F GT3 T 1 2 no 0 11 ## 6 GP M LE3 T 1 2 yes 6 12 ## 7 GP M LE3 T 1 2 yes 0 13 ## 8 GP F GT3 A 2 2 no 2 10 ## 9 GP M LE3 A 1 2 yes 0 15 ## 10 GP M GT3 T 1 2 yes 0 12 ## # ... with 639 more rows, and 3 more variables: G2 &lt;dbl&gt;, G3 &lt;dbl&gt;, ## # averageScore &lt;dbl&gt; Privzeto funkcija read.xlsx() odpre prvi list v datoteki in poie glavo razpredelnice, e elimo druge liste moramo podati ime lista ali tevilko lista s parametrom sheet. library(openxlsx) ocene_portugalscina &lt;- tibble(read.xlsx(&quot;./test-script/data-raw/student-performance.xlsx&quot;, sheet = 1)) ocene_matematika &lt;- tibble(read.xlsx(&quot;./test-script/data-raw/student-performance.xlsx&quot;, sheet = &quot;Math scores&quot;)) ocene_portugalscina %&gt;% select(school, G1, G2, G3, averageScore) ## # A tibble: 649 x 5 ## school G1 G2 G3 averageScore ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP 0 11 11 7.33 ## 2 GP 9 11 11 10.3 ## 3 GP 12 13 12 12.3 ## 4 GP 14 14 14 14 ## 5 GP 11 13 13 12.3 ## 6 GP 12 12 13 12.3 ## 7 GP 13 12 13 12.7 ## 8 GP 10 13 13 12 ## 9 GP 15 16 17 16 ## 10 GP 12 12 13 12.3 ## # ... with 639 more rows ocene_matematika %&gt;% select(school, G1, G2, G3, averageScore) ## # A tibble: 395 x 5 ## school G1 G2 G3 averageScore ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP 5 6 6 5.67 ## 2 GP 5 5 6 5.33 ## 3 GP 7 8 10 8.33 ## 4 GP 15 14 15 14.7 ## 5 GP 6 10 10 8.67 ## 6 GP 15 15 15 15 ## 7 GP 12 12 11 11.7 ## 8 GP 6 5 6 5.67 ## 9 GP 16 18 19 17.7 ## 10 GP 14 15 15 14.7 ## # ... with 385 more rows e ima datoteka veliko tevilo listov jih lahko shranite v R-jev seznam (list). library(openxlsx) path &lt;- &quot;./test-script/data-raw/student-performance.xlsx&quot; imenaListov &lt;- getSheetNames(path) ocene_s &lt;- list() for(i in 1:length(imenaListov)) { ocene_s[[i]] &lt;- tibble(read.xlsx(path)) } ocene_s ## [[1]] ## # A tibble: 649 x 12 ## school sex famsize Pstatus traveltime studytime internet absences G1 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP F GT3 A 2 2 no 4 0 ## 2 GP F GT3 T 1 2 yes 2 9 ## 3 GP F LE3 T 1 2 yes 6 12 ## 4 GP F GT3 T 1 3 yes 0 14 ## 5 GP F GT3 T 1 2 no 0 11 ## 6 GP M LE3 T 1 2 yes 6 12 ## 7 GP M LE3 T 1 2 yes 0 13 ## 8 GP F GT3 A 2 2 no 2 10 ## 9 GP M LE3 A 1 2 yes 0 15 ## 10 GP M GT3 T 1 2 yes 0 12 ## # ... with 639 more rows, and 3 more variables: G2 &lt;dbl&gt;, G3 &lt;dbl&gt;, ## # averageScore &lt;dbl&gt; ## ## [[2]] ## # A tibble: 649 x 12 ## school sex famsize Pstatus traveltime studytime internet absences G1 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GP F GT3 A 2 2 no 4 0 ## 2 GP F GT3 T 1 2 yes 2 9 ## 3 GP F LE3 T 1 2 yes 6 12 ## 4 GP F GT3 T 1 3 yes 0 14 ## 5 GP F GT3 T 1 2 no 0 11 ## 6 GP M LE3 T 1 2 yes 6 12 ## 7 GP M LE3 T 1 2 yes 0 13 ## 8 GP F GT3 A 2 2 no 2 10 ## 9 GP M LE3 A 1 2 yes 0 15 ## 10 GP M GT3 T 1 2 yes 0 12 ## # ... with 639 more rows, and 3 more variables: G2 &lt;dbl&gt;, G3 &lt;dbl&gt;, ## # averageScore &lt;dbl&gt; V primeru, da je razpredelnica v excelovem listu premaknjena ali pa elimo prebrati le del podatkov, lahko uporabimo parametra startRow in cols. Preberimo samo ocene za matematiko brez ostalih vrednosti. path &lt;- &quot;./test-script/data-raw/student-performance.xlsx&quot; ocene_math &lt;- tibble(read.xlsx(path, sheet = &quot;Math scores&quot;, startRow = 1, cols = 9:12)) ocene_math ## # A tibble: 395 x 4 ## G1 G2 G3 averageScore ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5 6 6 5.67 ## 2 5 5 6 5.33 ## 3 7 8 10 8.33 ## 4 15 14 15 14.7 ## 5 6 10 10 8.67 ## 6 15 15 15 15 ## 7 12 12 11 11.7 ## 8 6 5 6 5.67 ## 9 16 18 19 17.7 ## 10 14 15 15 14.7 ## # ... with 385 more rows Da podatke shranimo na disk uporabimo write.xlsx(). path &lt;- &quot;./test-script/data-raw/samo-ocene-math.xlsx&quot; write.xlsx(ocene_math, path) 3.5.2.2 SPSS SPSS je program za statistino analizo. Datoteke povezane z SPSS imajo obiajno konnico .sav. Za branje iz in uvaanje v SPSS lahko uporabimo paket haven. V mapi data_raw imamo podatke o osebah osebe.sav. Za uvoz teh podatkov v R uporabimo funkcijo read_sav. library(haven) podatki &lt;- read_sav(&quot;./data-raw/osebe.sav&quot;) podatki ## # A tibble: 5 x 5 ## Ime Visina Teza Spol Starost ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Alen 171 70 m 41 ## 2 Bojan 185 78 m 35 ## 3 Cvetka 165 64 z 28 ## 4 Dejan 190 95 m 52 ## 5 Eva 152 67 z 22 Da shranimo data frame v sav datoteko, uporabimo funkcijo write_sav(). Shranimo sedaj data frame iris v sav datoteko: write_sav(iris, &quot;./data-clean/iris.sav&quot;) ## Error: Failed to open &#39;C:\\Users\\Gregor\\Documents\\shared_files\\workshops\\urejanje-podatkov\\data-clean\\iris.sav&#39; for writing Paket haven ima tudi funkcijo read_por() ki podpira stareje verzije datotek iz SPSS. 3.6 Ali elite izvedeti ve? V tem poglavju smo si ogledali operacije treh paketov tidyversa. e elite hiter in dokaj celovit pregled nad vsemi ukazi priporoamo, da si za vsak paket ogledate tako imenovan cheat sheet: stringr: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf forcats: http://www.flutterbys.com.au/stats/downloads/slides/figure/factors.pdf lubridate: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_lubridate.pdf Paket stringr uporablja paket stringi, ki ima na voljo 5x ve operacij, ki pa niso tako pogosto uporabljene. e se boste pri svojem delu sreali z zahtevnejimi nalogami lahko uporabite ta paket. Za razumevanje regularnih izrazov in tudi avtomatsko razlago priporoamo stran https://regex101.com/. 3.7 Domaa naloga Odprite prvi list ocen v student-performance.xlsx v mapi test-script/data-raw/. Odprite le stolpce school, absences, G1, G2, G3 in averageScore. Dodajte stolpec toke, ki ima vrednosti med 0 in 100, tako da ima najvija pripadajoa vrednost v averageScore vrednost 100. Dodajte stolpec ocena, kjer so vrednosti za toke med 0 in 10 enake 1, 10 in 20 enake 2 itd. Dodajte stolpec besedna_ocena tipa faktor, ki bo imel vrednosti glede na oceno in sicer ocene &lt;6 = nezadostno, 6 = zadostno, 7 in 8 = dobro, 9 = zelo dobro in 10 = odlino. ## # A tibble: 649 x 9 ## school absences G1 G2 G3 averageScore toke ocena besedna_ocena ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 GP 4 0 11 11 7.33 39.3 4 nezadostno ## 2 GP 2 9 11 11 10.3 55.4 6 zadostno ## 3 GP 6 12 13 12 12.3 66.1 7 dobro ## 4 GP 0 14 14 14 14 75 8 dobro ## 5 GP 0 11 13 13 12.3 66.1 7 dobro ## 6 GP 6 12 12 13 12.3 66.1 7 dobro ## 7 GP 0 13 12 13 12.7 67.9 7 dobro ## 8 GP 2 10 13 13 12 64.3 7 dobro ## 9 GP 0 15 16 17 16 85.7 9 zelo dobro ## 10 GP 0 12 12 13 12.3 66.1 7 dobro ## # ... with 639 more rows Naloite paket nycflights13 s podatki letov. V tej bazi je ve razpredelnic in sicer flights, airlines, planes, airports in weather. Za razumevanje si pomagajte z ?flights. Izpiite vsa letalia, ki imajo 3 ali ve besed v svojem imenu. ## # A tibble: 837 x 8 ## faa name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 06A Moton Field Municipal Ai~ 32.5 -85.7 264 -6 A America/Chica~ ## 2 09J Jekyll Island Airport 31.1 -81.4 11 -5 A America/New_Y~ ## 3 0A9 Elizabethton Municipal A~ 36.4 -82.2 1593 -5 A America/New_Y~ ## 4 0G6 Williams County Airport 41.5 -84.5 730 -5 A America/New_Y~ ## 5 0G7 Finger Lakes Regional Ai~ 42.9 -76.8 492 -5 A America/New_Y~ ## 6 0P2 Shoestring Aviation Airf~ 39.8 -76.6 1000 -5 U America/New_Y~ ## 7 0S9 Jefferson County Intl 48.1 -123. 108 -8 A America/Los_A~ ## 8 0W3 Harford County Airport 39.6 -76.2 409 -5 A America/New_Y~ ## 9 10C Galt Field Airport 42.4 -88.4 875 -6 U America/Chica~ ## 10 17G Port Bucyrus-Crawford Co~ 40.8 -83.0 1003 -5 A America/New_Y~ ## # ... with 827 more rows Teja Spremenite imena letali tako, da odstranite besedi Airport ali Airfield iz konca imena. ## # A tibble: 1,458 x 8 ## faa name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 04G &quot;Lansdowne &quot; 41.1 -80.6 1044 -5 A America/New_York ## 2 06A &quot;Moton Field Municipal~ 32.5 -85.7 264 -6 A America/Chicago ## 3 06C &quot;Schaumburg Regional&quot; 42.0 -88.1 801 -6 A America/Chicago ## 4 06N &quot;Randall &quot; 41.4 -74.4 523 -5 A America/New_York ## 5 09J &quot;Jekyll Island &quot; 31.1 -81.4 11 -5 A America/New_York ## 6 0A9 &quot;Elizabethton Municipa~ 36.4 -82.2 1593 -5 A America/New_York ## 7 0G6 &quot;Williams County &quot; 41.5 -84.5 730 -5 A America/New_York ## 8 0G7 &quot;Finger Lakes Regional~ 42.9 -76.8 492 -5 A America/New_York ## 9 0P2 &quot;Shoestring Aviation &quot; 39.8 -76.6 1000 -5 U America/New_York ## 10 0S9 &quot;Jefferson County Intl&quot; 48.1 -123. 108 -8 A America/Los_Ang~ ## # ... with 1,448 more rows Dalja Za vsak let sestavite besedno poroilo spodnje oblike, ki ga shranite v stolpec Poroilo leta. Besedilo naj se glasi: Let iz letalisca Newark Liberty Intl dne 22.01.13 ob 11:00 v letalisce George Bush Intercontinental je imel 2 minut zamude v odhodu in 11 v prihodu. Minute so lahko tudi negativne. ## # A tibble: 336,776 x 2 ## `Poroilo leta` dep_string ## &lt;chr&gt; &lt;dttm&gt; ## 1 Let iz letalisca Newark Liberty Intl, dne 22.01.13, ob 1~ 2013-01-22 11:00:00 ## 2 Let iz letalisca La Guardia, dne 23.01.13, ob 01:00 v le~ 2013-01-23 01:00:00 ## 3 Let iz letalisca John F Kennedy Intl, dne 23.01.13, ob 1~ 2013-01-23 12:00:00 ## 4 &lt;NA&gt; 2013-01-23 17:00:00 ## 5 Let iz letalisca La Guardia, dne 26.01.13, ob 00:00 v le~ 2013-01-26 00:00:00 ## 6 Let iz letalisca Newark Liberty Intl, dne 24.01.13, ob 0~ 2013-01-24 06:00:00 ## 7 Let iz letalisca Newark Liberty Intl, dne 26.01.13, ob 0~ 2013-01-26 00:00:00 ## 8 Let iz letalisca La Guardia, dne 26.01.13, ob 00:00 v le~ 2013-01-26 00:00:00 ## 9 Let iz letalisca John F Kennedy Intl, dne 26.01.13, ob 0~ 2013-01-26 00:00:00 ## 10 Let iz letalisca La Guardia, dne 26.01.13, ob 00:00 v le~ 2013-01-26 00:00:00 ## # ... with 336,766 more rows "],["reference.html", "Reference", " Reference "]]
