---
output:
  html_document: default
  pdf_document: default
---
```{r, echo = FALSE}
knitr::opts_chunk$set(
  error = TRUE, # do not interrupt in case of errors
  warnings = FALSE,
  message = FALSE
)
library(tidyverse) 
library(nycflights13) #paket s podatki, ki ga bomo sproti uporabljali
library(webshot)
library(htmlwidgets)
library(lubridate)
```


# Nizi, kategorične spremenljivke in datumi 
Pogosto se pri delu s podatki srečamo s posebnimi podatkovnimi tipi, kot so nizi, kategorične spremenljivke in datumi. Z nizi smo že delali na prvi dveh predavanjih, ampak nad njimi nismo izvajali pretirano kompleksnih operacij. Delali smo tudi s kategoričnimi spremenljivkami, čeprav se tega morda nismo zavedali. S temi podatkovnimi tipi lahko torej delamo z relativno malo znanja. Seveda pa za kvalitetno delo s podatki potrebujemo tudi orodja za bolj podrobno delo s takšnimi tipi. V tem predavanju bomo spoznali kako delati s takšnimi spremenljivkami v okviru zbirke tidyverse ter predstavili praktične primere, dobre prakse in pasti pri delu z njimi.

## Priprava

V tem poglavju bomo spoznali, kako delamo z nizi, kategoričnimi spremenljivkami in datumi. Na koncu se bomo tudi posvetili branju podatkov iz različnih datotek in shranjevanju dobljenih rezultatov.

#### Nizi {-}

Najprej si poglejmo najbolj uporabne funkcije za delo z nizi.

Nize lahko združujemo na več načinov:
```{r}
crke      <- c("A", "B", "C", "D")
stevilke  <- c("1", "2", "3", "4")
str_c(crke, stevilke)
str_c(crke, stevilke, sep = "-")
str_c(crke, stevilke, collapse = "-")
```

Obratno jih lahko razčlenimo na več manjših nizov:

```{r}
str_split("A1-B2-C3-D4", pattern = "-")
```

Zelo uporabna je tudi funkcija za zamenjavo podnizov.

```{r}
str_replace("A1-B1-A2-B2", pattern = "1", "(ena)")
str_replace_all("A1-B1-A2-B2", pattern = "1", "(ena)")
str_replace_all("A1-B1-A2-B2", c("1" = "(ena)", "2" = "(dva)"))
```

Poglejmo, kako bi iz zbirke sadežev v že vgrajenem nizu `fruit` poiskali vse jagodičevje, to so tisti nizi, ki vsebujejo `berry`.

```{r}
length(fruit)
str_subset(fruit, "berry")
```
Oziroma lahko vrnemo logični vektor nizov, ki vsebujejo `berry`.

```{r}
str_detect(fruit, "berry")
```

Funkcija `str_detect()` je zelo uporabna pri izbiranju vrstic glede na nize. Običajno jo uporabljamo v kombinaciji z regularnimi izrazi, ki jih bomo spoznali v jedru tega poglavja.

#### Kategorične spremenljivke {-}
Pri pripravi na kategorične spremenljivke bomo uporabili podatke o uspehu študentov na izpitu:
``` {r}
tib <- tibble(
  ime             = c("Maja", "Ales", "Tom", "Barbara", "Simon", "Tina"),
  spol            = c("z", "m", "m", "z", "m", "z"),
  ocena           = c(10, 10, 6, 8, 8, 7),
  dan_izpita      = c(8, 8, 16, 16, 8, 23),
  mesec_izpita    = rep(6, 6),
  leto_izpita     = rep(2021, 6),
  opravljene_vaje = c(1, 1, 1, 1, 0, 1),
  procenti_vaje   = c(70, 65, 80, 90, 30, 75)
)
tib
```

Spremenimo **spol** v nominalno spremenljivko (brez ureditve) in **oceno** v ordinalno spremenljivko (obstaja ureditev med vrednostmi, običajno po velikosti):

``` {r}
tib <- tib %>% mutate(spol  = factor(spol),
                      ocena = factor(ocena, ordered = TRUE))
tib$spol
tib$ocena
```

Nivoje faktorja (levels) lahko tudi uredimo glede na vrednosti v nekem drugem stolpcu. To običajno pride prav pri vizualizaciji.

``` {r}
tib <- tib %>%
  mutate(spol = fct_reorder(spol, procenti_vaje, .desc = TRUE))
tib$spol
```



#### Datumi {-}

R omogoča avtomatski izpis datumov v obliki nizov. Preprosto lahko sestavimo datum s posameznimi komponentami:

``` {r}
make_date(year = 2021, month = 6, day = 11)
```
Ali iz niza:

``` {r}
ymd("2021-06-11")
```


Lahko dodamo tudi čas:
``` {r}
make_datetime(year = 2021, month = 6, day = 11, hour = 11, min = 30, tz = "CET")
```

Z datumi lahko tudi računamo:

``` {r}
my_date <- make_date(year = 2021, month = 6, day = 11)
my_date
my_date + days(2)
my_date + months(3)
```


#### Shranjevanje podatkov v csv {-}
V pripravi na 2. predavanje smo že spoznali funkcijo `rear_csv2()` za branje podatkov iz tekstovnih datotek. Podatke lahko tudi shranimo v tekstovno datoteko s funkcijo `write_csv2()`:

```{r}
write_csv2(tib, "./data-raw/studenti.csv")
```

**Naloga 1**: Datoteko *ocene.csv* v mapi *data-raw* preberite s funkcijami paketa **readr** (`read_csv2()` in `write_csv2()`). Shranite jo kot *ocene2.csv* in to datoteko preberite nazaj. Nato narediti enako z baznimi funkcijami v R ((`read.csv2()` in `write.csv2()`)). Kaj opazite?

Z **readr**:
```{r}
ocene <- read_csv2("./data-raw/ocene.csv")
write_csv2(ocene, "./data-raw/ocene2.csv")
read_csv2("./data-raw/ocene2.csv")
```

Z R:
```{r}
ocene <- read.csv2("./data-raw/ocene.csv")
write.csv2(ocene, "./data-raw/ocene2.csv")
read.csv2("./data-raw/ocene2.csv")
```


**Naloga 2**: Ponovno preberite *ocene.csv* ter:

- spremenite stolpec `opravljene_vaje` v kategorične vrednosti,
- zamenjajte stolpce `leto_izpita`, `mesec_izpita`, `dan_izpita` z `datum_izpita`, ki vsebuje vse te podatke,
- Izberite samo imena, ki se začnejo na 'T' in podatke shranite v datoteko oceneT.csv.


```{r}
ocene <- read.csv2("./data-raw/ocene.csv")
ocene <- ocene %>% 
  mutate(opravljene_vaje = factor(opravljene_vaje)) %>%
  mutate(datum_izpita = make_date(year = leto_izpita, 
                                  month = mesec_izpita, 
                                  day = dan_izpita)) %>%
  select(-leto_izpita, -mesec_izpita, -dan_izpita) %>%
  filter(str_detect(ime, "T"))
write_csv2(ocene, "./data-raw/oceneT.csv")
ocene
```

### Delo s šumniki {-}

Pri delu z nizi RStudio uporablja privzeto kodiranje vašega operacijskega sistema. Preprost način, da preverite ali R uporablja pravilno kodiranje je, da napišete v konzolo "čebula". Nazaj morate dobiti enak niz in ne "cebula" ali celo "პbula".

```{r}
"čebula"
```
Če R ne vrne istega niza je potrebno nastaviti privzeto kodiranje na svojem operacijskem sistemu. Da vidimoo katero kodiranje je trenutno uporabljeno, lahko napišemo:

```{r}
Sys.getlocale()
```

Pri tem izpisu vidimo, da uporabljamo sloveski nabor znakov CP1250. Če imate težave, lahko to začasno spremenite z ukazom. 

```{r}
Sys.setlocale(category = "LC_ALL", locale = "Slovenian_Slovenia.1250")
```

Oziroma lahko na primer v Windowsih nastavite privzeto kodiranje pod "Settings -> Time & Language -> Region -> Regional Format". Tukaj izberite "Slovenian (Slovenia)".

Za slovenske Windowse: "Nastavitve -> Ura in Jezik -> Regija -> Območne nastavitve" in izberite "Slovenščina (Slovenija)".


## Nizi
Zbirka paketov tidyverse vsebuje paket **stringr**, ki je namenjen delu z nizi. Vsi ukazi v paketu se začnejo s `str_`, kar v kombinaciji s funkcionalnostjo avtomatskega dopolnjevanja omogoča hitro izbiro in pregled vseh funkcij.

V jeziku R lahko za definiranje niza uporabimo enojne (') ali dvojne navednice ("). R bo rezultat sicer vedno vrnil v dvojnih navednicah. 

```{r}
niz_dvojne_navednice <- "urejanje podatkov"
niz_enojne_navednice <- 'urejanje podatkov'
niz_dvojne_navednice
niz_enojne_navednice
```

Če želimo znotraj niza uporabiti dvojne navednice lahko za definicijo uporabljamo enojne in obratno.

```{r}
citat1 <- "Jure je rekel: 'Citiram Janeza'."
citat2 <- 'In Janez je rekel: "Citiram Jureta".'
citat1
citat2
```

Izpis v drugem primeru uporablja tako imenovan **escape character** (\\), ki omogoča tudi vpis tabulaterjev (\\t), znakov za novo vrstico (\\n) in podobno. Vse znake, ki jih je tako možno zapisati si lahko ogledate z ukazom `?"'"`. 

Niz lahko vključuje tudi vse posebne znake, ki jih podpira Unicode. To je standard za konsistentno kodiranje teksta, ki vsebuje preko 100000 znakov. Za vnos unicode znakov uporabite **\\uxxxx**, kjer je **xxxx** koda znaka, ki ga lahko poiščete na strani https://unicode.org/charts/.

```{r}
normalna_porazdelitev <- "Normal(\u03BC, 1)"
normalna_porazdelitev
```

Dolžino nizov poiščemo s funkcijo `str_length()`.

```{r}
str_length(c("tri", "štiri", "", citat1, normalna_porazdelitev))
```

Za združevanje nizov se uporablja `str_c()`, ki mu lahko dodamo tudi niz `sep`, ki ga vrine med vse podane nize:

```{r}
str_c("paradižnik", "bučke", "jabolka", "paprika", "jagode", sep = ", ")
```

Če funkciji podamo vektorje lahko združimo tudi več nizov naenkrat. Pri tem bo število dobljenih nizov enako največjemu vektorju, manjši pa se bodo reciklirali, kar pomeni, da se bodo njihove vrednosti ponavljale, dokler ne dosežejo dolžine najdaljšega vektorja.

```{r}
str_c("Podpoglavje ", c(1, 2, 3, 4), ": ", 
      c("Nizi", "Faktorji", "Datumi", "Branje podatkov"))
```

Če želimo nize združiti zaporedno uporabimo `collapse`. Za izpis nizov brez escape znakov uporabite funkcijo `cat()`.

```{r}
poglavja <- str_c("Podpoglavje ", c(1, 2, 3, 4), ": ", 
      c("Nizi", "Faktorji", "Datumi", "Branje podatkov"), collapse = "\n")
poglavja
cat(poglavja)
```

Manjkajoče vrednosti lahko zamenjamo z `str_replace_na()`.

```{r}
str_replace_na(c("ena", "dva", NA, "štiri"), replacement = "tri!")
```

### Podnizi

Velikokrat se pri delu z nizi srečamo tudi s tem, da potrebujemo le del niza ali pa želimo niz razdeliti na več manjših nizov. Poglejmo si na primeru niza `"    KUPI: paradižnik, bučke, jabolka, paprika, jagode.  "` iz katerega želimo dobiti vektor sadja in zelenjave.

```{r}
listek <- "    KUPI: paradižnik, bučke, jabolka, paprika, jagode.  "
```

Najprej odstranimo odvečne začetne in končne presledke. To storimo s `str_trim()`:

``` {r}
listek <- str_trim(listek)
listek
```

Funkcija `str_sub()` vrne podniz glede na indekse znakov:

``` {r}
str_sub(listek, 7, 16) # Vrne znake med indeksom 7 do 16.
str_sub(listek, 7) # Vrne znake od sedmega naprej.
str_sub(listek, -7) # Vrne zadnjih sedem znakov.
str_sub(listek, -7, -2) # Vrne predzadnjih šest znakov.
```

S tem znanjem lahko odstranimo prvih šest znakov in zadnjega:
```{r}
listek <- str_sub(listek, 7, -2)
listek
```

Sedaj, ko imamo elemente samo naštete in ločene z vejico, jih lahko preprosto razdelimo s funkcijo `str_split()`, ki jipodamo vzorec za ločevanje:

```{r}
str_split(listek, pattern = ", ")
```

### Iskanje vzorcev z regularnimi izrazi

Regularni izrazi so močno orodje za iskanje poljubnega vzorca v nizih. V tem poglavju bo predstavljena le osnovna funkcionalnost regularnih izrazov, saj gre za zelo obširno orodje. Za prikaz delovanja bomo uporabljali funkciji `str_view()` in `str_view_all()`, ki uporabljata paket **htmlwidges** za prikaz rezultatov. Prva označi samo prvo ujemanje, druga pa vsa ujemanja.

Regularni izrazi so nizi, ki določijo iskalni vzorec. Z njimi lahko, na primer, iščemo nize, ki se začnejo na določen podniz, končajo na določen podniz, vsebujejo posebne simbole in podobno. Uporabljamo jih lahko v vseh funkcijah paketa **stringr**, ki imajo kot vhod `pattern`.

Sestavimo dva seznama v katerih bomo iskali vzorce. Za začetek poiščimo vse vejice.

```{r}
library(htmlwidgets)
listek1 <- "KUPI: paradižnik, bučke, jabolka, paprika, jagode. Aja, pa banane."
listek2 <- "KUPI: sok(3x), kruh, piškote, pašto(2x), sol in poper."
str_view_all(c(listek1, listek2), ",")
```

Kaj pa pike?

```{r}
str_view_all(c(listek1, listek2), ".")
```

Pika je poseben znak pri regularnih izrazih, ki predstavlja poljuben znak. Zato smo dobili ujemanja z vsemi črkami. Da lahko dejansko poiščemo pike in druge posebne znake moramo uporabiti znak escape `\`, s katerim programu sporočimo, naj simbola za tem ne prebere kot regularni izraz. Tukaj se nam nekoliko zaplete, ker je znak `\` že znak escape v R za tabulatorje (`\t`), nove vrstice (`\n`) itd. Zato, da vzorcu dejansko podamo `\.` moramo zapisati `\\.`. Tukaj si ponovno lahko pomagamo s funkcijo `cat()`, ki nam bo pokazala dejanski niz podan funkciji.


```{r}
cat("\\.") # Poglejmo kakšen niz bo dejansko sprejela funkcija str_view_all().
str_view_all(c(listek1, listek2), "\\.")
```

Regularni izrazi uporabljajo tudi dva posebna znaka, ki označujeta začetek `^` in konec `$` niza. Poiščimo samo pike, ki zaključujejo nize.

```{r}
str_view_all(c(listek1, listek2), "\\.$")
```
V regularnih izrazih so zelo uporabne tudi naslednje sekvence.

- `\d`: Ujemanje s poljubno števko;
- `\s`: Ujemanje s poljubnim presledkom (presledek, tabulator, nova vrstica);
- `[xyz]`: Ujemanje z x, y ali z;
- `[^xyz]`: Ujemanje z vsem razen x, y in z. Strešica znotraj oglatih oklepajev pomeni negacijo;
- `[[:digit:]]`: Ujemanje s poljubnim številom;
- `[[:alpha:]]`: Ujemanje s poljubno črko, uporabite lahko tudi `[[a-z]]` in `[[:lower:]]` za vse male črke ali `[[A-Z]]` in `[[:upper:]]` za vse velike črke;
- `[[:punct:]]`: Ujemanje z ločili.

Poglejmo si uporabo nekaterih:
```{r}
str_view_all(c(listek1, listek2), "\\dx") # Poiščemo vse številke, ki jim sledi x.
str_view_all(c(listek1, listek2), "[čžš]") # Vse šumnike.
str_view_all(c(listek1, listek2), "[aA].[aA]") # Dva a-ja s poljubnim znakom vmes.
str_view_all(c(listek1, listek2), ".[\\s,.]") # Vse konce besed.
str_view_all(c(listek1, listek2), "[a-f]") # Vse črke od a do f.
str_view_all(c(listek1, listek2), "[[:punct:]]") # Vsa ločila.
```

Znotraj oglatih oklepajev je pomen pike dobeseden znak pika. Tako, da ga ni potrebno zapisati kot `\\.` Priporočamo, da sami preizkušate še druge sekvence.

Navpična črta `|` pomeni ali:

```{r}
str_view_all(c(listek1, listek2), "sol|sok") 
```

### Ponovitve 
Zelo uporabni so tudi ukazi za ponovitve znakov ali sekvenc, ki nam omogočajo iskanje nizov določenih dolžin. Ukazi za delo s ponovitvami so:

- `?`: ponovi 0 ali 1 krat,
- `*`: ponovi 0 ali več krat,
- `+`: ponovi 1 ali več krat,
- `{n}`: ponovi natanko n krat,
- `{n,}`: ponovi n ali več krat,
- `{,m}`: ponovi m ali manj krat,
- `{n,m}`: ponovi med n in m krat.

Če znak za ponovitev uporabimo za enim znakom pomeni to ponovitev prejšnjega znaka. Lahko pa ga uporabimo tudi za oglatimi ali navadnimi oklepaji. Navadni oklepaji določajo skupino (več o skupinah v nadalje), ki se mora ponoviti. Oglati oklepaji pa izbiro, se pravi ponoviti se mora vsaj en od naštetih znakov.

Ko začnemo uporabljati ponovitve se pojavijo prve večje težave. 

Poiščimo vse besede dolžine 3. Besede sledijo presledku, torej začnemo regularni izraz z `\\s` (pri tem ignoriramo prvo besedo v odstavku). Nato morajo slediti 3 črke, torej `[:alpha:]{3}`. Temu mora slediti nov presledek ali ločilo, `[[:punct:]]|\\s`:

```{r}
str_view_all(c(listek1, listek2), "\\s[[:alpha:]]{3}([[:punct:]]|\\s)")
```

Poskušajmo poiskati besede, ki se začnejo na p in končajo na k ali e. 

```{r}
str_view_all(c(listek1, listek2), "p.*[ke]")
```
Opazimo, da je ujemanje požrešno. To pomeni, da je ujemanje najdaljše možno, ki ustreza ponovitvam. Če želimo najkrajšega lahko uporabimo še dodaten `?` za znakom za ponovitve.

```{r}
str_view_all(c(listek1, listek2), "p.*?[ke]")
```

Še vedno ni OK. V dobljenih nizih ne želimo presledkov in ne želimo, da se ujemanje konča prehitro, kot pri besedi 'piškote'. Poskusimo tako, da vzamemo ponovitve, ki ne vsebujejo presledkov.

```{r}
str_view_all(c(listek1, listek2), "p[^\\s]*[ke]")
```

Da zagotovimo zajem konca besede, določimo še, da naj bo na koncu vejica ali presledek.

```{r}
str_view_all(c(listek1, listek2), "p[[:alpha:]]*[ke]([, ])")
```
### Skupine

Kot smo že videli lahko uporabimo tudi oklepaje, da ločimo del regularnega izraza od ostalih simbolov. Oklepaji pa definirajo tudi skupino, na katero se lahko sklicujemo z `\x`, kjer je x zaporedna številka skupine.

Poglejmo si uporabo le tega na že vgrajenem vektorju sadja. Parameter `match = TRUE` nam vrne le nize, pri katerih je prišlo do ujemanja.

```{r}
str_view(fruit, "(..)\\1", match = TRUE)
```

Zgornji regularni izraz z `..` poišče dva poljubna znaka. Z `(..)` definiramo skupino. Z `\1` oziroma `\\1`, pa zahtevamo, da se na tem mestu še enkrat nahaja točno to kar je bilo med oklepaji.

Poiščimo imena sadežev, ki imajo vsaj dve (lahko različni) ponavljajoči si črki.

```{r}
str_view(fruit, "(.)\\1.*(.)\\2", match = TRUE)
```


### Uporaba regularnih izrazov
Poglejmo si uporabo regularnih izrazov najprej na preprostih podatkih, nato pa še na podatkih iz že znane ankete.

Poiščimo vso sadje in zelenjavo, ki vsebuje šumnike:
```{r}
seznam <- c("paradižnik", "bučke", "jabolka", "paprika", "jagode");
str_detect(seznam, "[čšž]")
```

Če želimo namesto logičnega vektorja dobiti dejanska imena elementov uporabimo `str_subset()`.

```{r}
str_subset(seznam, "[čšž]")
```

Poglejmo koliko samoglasnikov vsebuje vsaka beseda v seznamu. Pozor, funkcija `str_count()` ne zazna ponovitev, če se le te prekrivajo.

```{r}
str_count(seznam, "[aeiou]")
str_count("ababa", "aba") # Ne zazna dveh ponovitev, ker se prekrivata.
```

S funkcijo `str_locate()` vrnemo indekse lokacij najdenih vzorcev, s `str_extract()` pa dobimo ta vzorec oziroma podniz. S `str_match()` dobimo podskupine.

Poiščimo podnize do prvega šumnika.

```{r}
str_locate(seznam, "^.*[čšž]")
str_extract(seznam, "^.*[čšž]")
str_match(seznam, "(^.*)([čšž])")
```
V zadnjem primeru funkcija `str_match()` v prvem stolpcu vrne enako kot `str_extract()`, nato pa v naslednjih stolpcih vrne še vsako skupino posebej.

Preprosta in zelo uporabna pa je funkcija `str_replace()` oziroma `str_replace_all()` s katero lahko zamenjamo dele nizov.

Prekrijmo šumnike z znaki "x".

```{r}
str_replace(seznam, "[čšž]", "x")
```

Podamo lahko tudi zamenjavo za več ujemanj:

```{r}
str_replace_all(seznam, c("č" = "c", "š" = "s", "ž"= "z"))
```


Poglejmo si sedaj še uporabo na realnih podatkih. Najprej naložimo podatke:
``` {r}
ds_jobs <- read.csv2("./data-raw/DS-jobs.csv")
ds_jobs <- tibble(ds_jobs)
ds_jobs
```

Najbolj uporabna funkcija pri delu z nizi v podatkih je `str_detect()`, ki nam omogoča izbiro podmnožice vrstic. Pogosto jo kombiniramo z regularnimi izrazi. Poiščimo tiste vrstice, kjer imajo anketiranci več službenih nazivov. Ti so ločeni z znakom /.

```{r}
ds_jobs %>% 
  select(CurrentJobTitle) %>% 
  filter(str_detect(CurrentJobTitle, "/"))
```

Izberimo samo tiste vrstice, kjer se `CurrentJobTitle` začne z "Data" in se `EmploymentStatus` konča s "full-time":

```{r}
ds_jobs %>% 
  select(EmploymentStatus, CurrentJobTitle) %>% 
  filter(str_detect(CurrentJobTitle, "^Data"),
         str_detect(EmploymentStatus, "full-time$"))
```

Včasih so nizi v podatkih predolgi, oziroma lahko brez škode za pomen izbrišemo del niza. Najlažje to naredimo tako, da ga zamenjamo s praznim nizom. Izbrišimo podnize "Employed":

```{r}
ds_jobs <- ds_jobs %>% 
  mutate(EmploymentStatus = str_replace(EmploymentStatus, "Employed ", ""))
ds_jobs %>%
  select(EmploymentStatus, CurrentJobTitle)
```

Sedaj imamo eno manjšo nekonsistentnost v podatkih, namreč nekateri nizi se začnejo z veliko začetnico, nekateri pa z malo. Spremenimo vse na malo začetnico:

```{r}
ds_jobs <- ds_jobs %>% 
  mutate(EmploymentStatus = str_to_lower(EmploymentStatus))
ds_jobs %>%
  select(EmploymentStatus, CurrentJobTitle)
```


S funkcijo `str_count()` lahko uporabimo, da anketirancem dodamo stolpec s številom službenih nazivov:

```{r}
ds_jobs %>% 
  select(CurrentJobTitle) %>% 
  mutate(NumberOfJobTitles = str_count(CurrentJobTitle, "/") + 1)
```

Poskušajmo razdeliti CurrentJobTitle na FirstTitle in SecondTitle, pri tem naj se naziva ponovita, če ima anketiranec samo enega.

```{r}
ds_jobs %>% 
  select(CurrentJobTitle) %>% 
  mutate(FirstTitle  = str_extract(CurrentJobTitle, "^[^/]*"),
         SecondTitle = str_extract(CurrentJobTitle, "[^/]*$"))
```


## Kategorične spremenljivke
Kategorične spremenljivke so spremenljivke, ki lahko zavzamejo samo vnaprej določene vrednosti. Delimo jih na:

- **Nominalne spremenljivke**. To so spremenljivke brez ureditve. Na primer, spol ali vrsta avtomobila.
- **Ordinalne spremenljivke**. To so spremenljivke, ki imajo smiselno ureditev. Na primer, stopnja izobrazbe ali šolski uspeh.

V R uporabljamo za delo s kategoričnimi spremenljivkami t. i. **faktorje** (ang. **factor**). Ti se od spremenljivk tipa niz razlikujejo v tem, da se v spremenljivki hrani informacija o vseh možnih vrednostih. Prav tako ni mogoče faktorju dodati vrednosti, ki je ni v množici možnih vrednosti, kar služi kot varovalka pred napakami pri vnosu podatkov.

Poglejmo si uporabo faktorja na dveh preprostih primerih, kjer bomo sami ustvarili spremenljivki. Kasneje si bomo ogledali še delo s faktorji na primeru realnih podatkov, kjer bomo ponovno uporabili podatke o zaposlitvah na področju podatkovnih ved.

Kot primer nominalne spremenljivke si oglejmo krvne skupine. Obstajajo 4 možne vrednosti. Ustvarimo sedaj vektor krvnih skupin:
```{r}
krvne_skupine <- c("B", "B", "O", "AB", "BA")
```

Sedaj je ta vektor shranjen kot niz. Kaj so slabosti takšnega shranjevanja kategoričnih podatkov? Prvič, nimamo nobenega varovala pred tipkarskimi napakami -- R je zadnji vnos prebral kot *BA* in ga tako tudi shranil, čeprav ta krvna skupina ne obstaja:

```{r}
krvne_skupine
```

Pri ročnem vnosu podatkoh hitro pride do tipkarskih napak in načeloma ne vemo, ali je avtor podatkov v tme primeru želel vnesti A, B ali AB.

Drugič, če želimo urediti to spremenljivko, se bodo vrednosti razvrstile po abecedi:

```{r}
sort(krvne_skupine)
```

Morda pa bi bilo bolj smiselno urediti po standardni ureditvi, torej A, B, AB, O.

Da se izognemo tem težavam je bolje, če spremenljiko za katero vemo, da bo zasedla eno od vnaprej določenih vrednosti, shranimo kot faktor. V R za to uporabimo funkcijo `factor()`. Poizkusimo sedaj narediti faktor iz spremenljivke `dan_v_tednu`.

```{r}
krvne_skupine_fac <- factor(krvne_skupine)
krvne_skupine_fac
```

Opazimo, da je sedaj spremenljivka drugačnega tipa, saj hrani tudi informacijo o možnih vrednostih oziroma ravneh (ang. levels). Ampak v tem primeru so te ravni napačne (ne zajame vseh 4 krvnih skupin, poleg tega pa vsebuje tudi eno napačno vrednost). Funkcija `factor()` privzeto kot ravni nastavi vse vrednosti v podani spremenljivki. Če želimo, ji lahko podamo dodaten argument `levels`, kjer ročno določimo, katere ravni bodo v spremenljivki. V kolikor to vemo vnaprej, je dobra praksa da podamo tudi ta argument.

```{r}
krvne_skupine_fac <- factor(krvne_skupine, levels = c("A", "B", "AB", "O"))
krvne_skupine_fac
sort(krvne_skupine_fac)
```

Opazimo dvoje: sedaj lahko spremenljivko uredimo glede na standardno notacijo in nesmiselne vrednosti se spremenijo v `NA`. Faktorju torej ne moremo prirediti vrednosti, ki ni enaka eni izmed vrednosti v ravneh. Da dostopamo do vseh ravni faktorja, uporabimo funkcijo `levels()`:

```{r}
levels(krvne_skupine_fac)
```

Včasih imajo kategorične spremenljivke tudi smiselno razvrstitev po velikosti, ki pa se običajno ne da numerično izmeriti. Kot primer si poglejmo šolski uspeh, ki lahko zavzame 5 vrednosti. V kolikor želimo, da faktor hrani tudi informacijo o tem, da obstaja smiselna razvrstitev po velikosti, dodamo argument `ordered = TRUE`.


```{r}
uspeh <- factor(c("odlično", "dobro", "dobro", "prav dobro"),
                levels = c("nezadostno", "zadostno", "dobro", "prav dobro", "odlično"),
                ordered = TRUE)
uspeh
```

Opazimo, da imamo sedaj pri izpisu nivojev dodatno informacijo o razvrstitvi uspeha. V praksi nam to omogoča primerjamo, medtem ko tega pri faktorjih, ki nimajo razvrstitve po velikosti, ne moremo narediti.

```{r}
uspeh[2] > uspeh[1]
krvne_skupine_fac[2] > krvne_skupine_fac[1]
```

Poleg prednosti, ki smo jih že omenili (varovanje pred napakami in smiselna razvrstitev nivojev) imajo faktorji tudi posebno vlogo pri raznih statističnih modelih in modelih strojnega učenja. Nekatere metode eksplicitno zahtevajo faktorje. Prav tako razlikujejo med nominalnimi in ordinalnimi faktorji, kar se pozna na rezultatih. Relativno preprost primer tega je linearna regresija, ki pa je izven obsega te delavnice. Vsekakor pa si je to vredno zapomniti, v kolikor se boste kdaj ukvajrali s podobnimi modeli in boste želeli uporabiti kategorične spremenljivke.

Poglejmo si uporabo faktorjev na realni podatkovni množici. Ponovno bomo delali s podatki o zaposlitvah na področju podatkovnih ved. Preberimo podatke in ponovimo nekaj operacij, ki smo jih spoznali na prvem predavanju. Prav tako bomo izbrali samo podmnožico stolpcev za bolj jasen prikaz.

```{r}
library(tidyverse)
ds_jobs <- read_csv2("./data-raw/DS-jobs.csv") %>%
  select(Country, Age, EmploymentStatus,
         FormalEducation, CompensationAmount, ExchangeRate) %>%
  filter(!is.na(ExchangeRate)) %>%
  mutate(CompensationUSD = CompensationAmount * ExchangeRate) %>%
  filter(CompensationUSD <= 2500000, CompensationUSD >= 10000)
ds_jobs
```

Imamo 3 spremenljivke, ki bi jih bilo smiselno shraniti kot faktorje -- `Country`, `EmploymentStatus` in `FormalEducation`. Pretvorimo sedaj ti spremenljivki v faktorje. Pri tem pustimo kar privzeto nastavitev, da se kot nivoji uporabijo vse vrednosti v stolpcih.

```{r}
library(tidyverse)
ds_jobs <- ds_jobs %>%
  mutate(Country          = factor(Country),
         EmploymentStatus = factor(EmploymentStatus),
         FormalEducation  = factor(FormalEducation))
ds_jobs
levels(ds_jobs$Country)
levels(ds_jobs$EmploymentStatus)
levels(ds_jobs$FormalEducation)
```
Kaj se zgodi, če želimo v tibblu spremeniti vrednost faktorja, v neko vrednost, ki je ni v tem faktorju? Recimo, da želimo v 2. vrstici spremeniti državo v Narnia:

```{r}
ds_jobs2 <- ds_jobs
ds_jobs2$Country[2] <- "Narnia"
ds_jobs2
```
Ker Narnia ni nivo v faktorju, se nadomesti z `NA`. Če želimo dodati nov nivo temu faktorju, uporabimo `fct_expand()`:

```{r}
ds_jobs2 <- ds_jobs %>%
  mutate(Country = fct_expand(Country, "Narnia"))
ds_jobs2$Country[2] <- "Narnia"
ds_jobs2
```


### Sprememba razvrstitve faktorja
Kot smo omenili že pri krvnih skupinah imajo velikokrat tudi faktorji, ki niso razvrščeni po velikosti, neko ustaljeno razvrstitev. Razvrstitev pa lahko tudi kasneje spremenimo. Ta operacija je običajno uporabna pri vizualizaciji. Poglejmo si, na primer, kako so plače povezane z izobrazbo. Za vizualizacijo rezultatov bomo uporabili razsevni diagram:

```{r}
ds_jobs_agg <- ds_jobs %>%
  group_by(FormalEducation) %>%
  summarise(MeanCompensationUSD = mean(CompensationUSD))
ds_jobs_agg
ggplot(ds_jobs_agg, aes(x = FormalEducation, y = MeanCompensationUSD)) +
  geom_point() +
  coord_flip() +
  xlab("")
```

Ta graf je sicer zelo informativen, ampak bi s težavo hitro ugotovili, kako so nivoji faktorja razvrščeni glede na plačo. ggplot razvrsti vrednosti glede na to, kako so razvrščene v faktorju:

```{r}
levels(ds_jobs$FormalEducation)
```

Morda bi bilo bolje tak graf urediti glede na vrednosti spremenljivke `MeanCompensationUSD`. Za to moramo določiti novo razvrstitev te spremenljivke. Za to obstaja v paketu **forcats**, ki je del tidyverse, funkcija `fct_reorder()`.

```{r}
ggplot(ds_jobs_agg, aes(x = fct_reorder(FormalEducation, MeanCompensationUSD), y = MeanCompensationUSD)) +
  geom_point() +
  coord_flip() +
  xlab("")
```

Razvrstitev lahko uredimo tudi ročno s funkicjo `fct_relevel()`, ki ohrani privzeto razvrstitev s tem, da podane nivoje premakne na začetek, oziroma lahko podamo arguemnt after.

```{r}
ggplot(ds_jobs_agg, aes(x = fct_relevel(FormalEducation, "I prefer not to answer", "I did not complete any formal education past high school", after = 0), y = MeanCompensationUSD)) +
  geom_point() +
  coord_flip() +
  xlab("")
```

### Preimenivanje obstoječih in določanje novih nivojev
Nivoje faktorjev lahko preimenujemo s funkcijo `fct_recode()`.

```{r}
ds_jobs <- ds_jobs %>%
  mutate(EmploymentStatus = fct_recode(EmploymentStatus,
                                        "full-time" = "Employed full-time",
                                        "part-time" = "Employed part-time",
                                        "other" = "Independent contractor, freelancer, or self-employed"))
head(ds_jobs$EmploymentStatus)
```

Sorodno lahko zgornjo funkcijo zamenjamo z `fct_collapse()`, ki lahko združi več nivojev v enega.


### Razbitje numerične spremenljivke na intervale
Pogosto želimo kakšno numerično spremenljivko segmentirati na določene intervale. Na primer, pri določanju avtomobilskih zavarovalnih premij lahko zavarovance segmentiramo glede na starost. V R za to uporabimo funkcijo `cut()`. Razdelimo spremenljivko `Age` na intervale, kjer bodo osebe razdeljene do 25 let, nad 25 in to 35 let, nad 35 do 50 let, in nad 50 let.

```{r}
ds_jobs <- ds_jobs %>%
  mutate(AgeInterval = cut(Age, breaks = c(0, 25, 35, 50, 100)))
ds_jobs_agg <- ds_jobs %>%
  group_by(AgeInterval) %>%
  summarise(CompensationByAge = mean(CompensationUSD))
ggplot(ds_jobs_agg, aes(x = AgeInterval, y = CompensationByAge)) + geom_point()
```

## Datumi in ure
Delo z datumi in urami morda na prvi pogled deluje precej enostavno. Vendar pa zaradi različnih fizikalnih zakonitosti ali človeških konstruktov lahko pride do težav. Na primer, vsako leto nima 365 dni. Prav tako v nekaterih časovnih conah 3. ura zjutraj ne sledi vedno 2. uri, saj pride do premika ure.

Za delo z datumi bomo uporabljali paket **lubridate**. Glavni komponenti v tem paketu sta **datum** (date) in **čas** (time), ter združena komponenta **datum in čas** (datetime). S tem paketom lahko datume ustvarimo na 2 načina:

1) Z nizom:
    ```{r}
    library(lubridate)
    ymd("2021-04-02")
    ymd("2021/04/02")
    ymd(20210402)
    dmy("02.04.2021")
    ymd_hms("2021-04-02 12:01:00") # Tipa datetime.
    ymd(20210402, 20210403)
    mdy("April 2nd, 2021") # Deluje za angleška imena mesecev
    ```
2) S posameznimi komponentami:
    ```{r}
    make_date(2021, 4, 2)
    make_datetime(2021, 4, 2, 12, 1, 0)
    ```

Opazimo, da pri datumu in času spremenljivka hrani tudi informacijo o časovnem pasu. Privzeto lubridate dela s časovnim pasom UTC (Coordinated Universal Time), ki je naslednik GMT (Greenwich Mean Time). Prednost tega časovnega pasu je predvsem v tem, da se ne prilagaja spremembi ure v pomladnih in jesenskih mesecih. Te spremembe lahko privedejo do napak pri računanju z datumi in časi, tako da je računanje v UTC bolj varno. Seveda pa lahko ročno nastavimo drugi časovni pas z argumentom `tz`. Paket lubridate uporablja IANA časovne pasove (https://www.iana.org/time-zones), kateri so definirani s kombinacijo celine in države. Na primer, za Ljubljano bi časovni pas nastavili tako:

```{r}
ymd_hms("2021-04-02 12:01:00", tz = "Europe/Ljubljana")
```

Pomembno je torej, da vemo, v katerem časovnem pasu so bile opravljene meritve v naših podatkih, da lahko potem ustrezno pretvorimo spremenljivko v časovno. Seveda pa lahko tudi pretvarjamo časovne spremenljivke med časovnimi pasovi. Za to uporabimo funkcijo `with_tz()`. Vsakemu času v določenem časovnem pasu lahko priredimo nek čas v drugem časovnem pasu. V kolikor želimo bolj robustno računati z datumi in urami, potem lahko vedno datume pretvorimo v UTC čas, naredimo izračune in potem pretvorimo nazaj v lokalni časovni pas.


```{r}
my_datetime <- ymd_hms("2021-04-02 12:01:00", tz = "Europe/Ljubljana")
my_datetime
my_datetime_UTC <- with_tz(my_datetime, tz = "UTC")
my_datetime_UTC
```

Hranita pa spremenljivki v ozadju isti čas. To lahko preverimo z:

```{r}
my_datetime == my_datetime_UTC
```

V R je časovni pas namenjen samo izpisu datumov in časov. Sama vrednost spremenljivke ostane nespremenjena. To lahko preverimo tako, da odštejemo en datum od drugega, kar nam vrne razliko v času:

```{r}
my_datetime - my_datetime_UTC
```
V kolikor smo narobe prebrali datum v začetku (na primer, v podatkih je bil datum v UTC, prebrali pa smo v lokalnem času) zgornja pretvorba med časovnimi pasovi ni ustrezna, saj bomo s tem zajeli napačen čas. V tem primeru moramo uporabiti funkcijo `force_tz()`. Predlagamo, da udeleženci sami poizkusijo, kaj naredi ta funkcija, tako da z njo pretvorijo `my_datetime` v UTC in potem izračunajo razliko, podobno kot smo to naredili zgoraj.

Kadar delamo sekvence datumov in časov te upoštevajo premik ure in prehodov v naslednje dni. Poglejmo si prehod na poletni čas v letu 2021:

```{r}
datetime_dst <- seq(ymd_hms("2021-03-28 00:00:00", tz = "Europe/Ljubljana"), 
                    ymd_hms("2021-03-28 04:00:00", tz = "Europe/Ljubljana"), 
                    by = "30 min")
datetime_dst
with_tz(datetime_dst, tz = "UTC")
```

Pozorni moramo biti tudi na kombiniranje datumov. V kolikor uporabimo funkcijo `c()`, vedno preverimo, v katerem časovnem pasu je rezultat.


### Računanje z datumi in časi
Vsaka časovna spremenljivka, ki vsebuje datum in čas, je sestavljena iz komponent. Te so leto, mesec, dan, ura, minuta in sekunda. Za dostop do posameznih komponent imamo na voljo več funkcij:

- `year()`
- `month()`
- `mday()`. Dan v mesecu.
- `wday()`. Dan v tednu. Privzeto se začne z nedeljo. To lahko spremenimo z argumentom `week_start`.
- `hour()`
- `minute()`
- `second()`

Poglejmo sedaj kaj vračajo te funkcije:

```{r}
x <- now()
x
year(x)
month(x)
mday(x)
wday(x)
wday(x, week_start = 1)
hour(x)
minute(x)
second(x)
```

S komponentami lahko tudi spreminjamo dele časovne spremenljivke:

```{r}
mday(x) <- 5
x
```

Pri računanju s časovnimi enotami v lubridate poznamo tri razrede:

- **trajanja** (ang. duration). Čas v sekundah. Funkcije `dseconds()`, `dminutes()`, `ddays()`, `dweeks()` in `dyears()`. Pri trajanjih se vedno uporabi pretvorba, da ima vsak dan 24 ur in vsako leto 365.25 dni. Slednje predstavlja povprečno šteilo dni v letu. Tako da bo funkcija `dyears(4)` vedno vrnila število sekund, ki ustreza 4x365.25 dnem, ki imajo vsak po 24 ur.
- **periode** (ang. period). Čas v človeških enotah kot je na primer teden. Funkcije `seconds()`, `minutes()`, `days()`, `weeks()`, `months()` in `years()`.
- **intervali** (ang. interval). Časovni interval med dvema točkama.

Pozoren bralec je morda opazil, da pri trajanjih nismo navedli funkcije za mesece. To je zaradi tega, ker imajo meseci lahko 28, 29, 30 ali 31 dni. Vsekakor bi pri izbiri osnovne enote za trajanja prišlo do neke arbitrarne odločitve, koliko dni vzamemo privzeto. 30 ali 31? V vsakem primeru bo vsaj polovica mesecev imela napačno trajanje. Pri dnevih in letih si lažje privoščimo posplošitev.

```{r}
ddays(1)
days(1)
```

Poglejmo si preprost primer, kako dodati

```{r}
my_datetime <- ymd_hms("2021/06/08 11:05:30", tz = "Europe/Ljubljana")
my_datetime + ddays(1)
my_datetime + days(1)
my_datetime + dminutes(120)
my_datetime + minutes(120)
my_datetime + months(2)
```

Trajanja in periode so si očitno zelo podobni ampak imajo eno veliko razliko, kadar računamo z dnevi, tedni in leti. Prvič, kadar bomo uporabljali `dyears()` lahko hitro pride do težave, saj bomo prišteli 0.25 dneva. Poglejmo si to na primeru:

```{r}
my_datetime + years(1)
my_datetime + dyears(1)
```

Opazimo, da smo prišteli 6 dodatnih ur. Drugič, kaj se zgodi, kadar prištejemo teden ali dan v času, ko pride do premika ure. Premik ure se je po lokalnem času zgodil 28. 3. 2021 ob 2 zjutraj.

```{r}
my_datetime <- ymd_hms("2021/03/27 11:05:30", tz = "Europe/Ljubljana")
my_datetime + ddays(1)
my_datetime + days(1)
my_datetime + dweeks(1)
my_datetime + weeks(1)
```
Funkcija `years()` deluje kot bi pričakovali tudi na prestopnem letu:

```{r}
my_datetime <- ymd_hms("2020/06/08 11:05:30", tz = "Europe/Ljubljana")
my_datetime + years(1)
```

S funkcijami trajanja in period lahko tudi računamo, na primer:

```{r}
dyears(2) + ddays(4) + dseconds(20)
days(2) + minutes(20) + seconds(120)
5 * dminutes(20)
5 * minutes(20)
```

Najbolje, da jo prikažemo na dveh primerih -- premik ure in prestopno leto. Periode so bolj naraven prikaz za človeka.

```{r}
my_datetime <- ymd_hms("2021/06/08 11:05:30", tz = "Europe/Ljubljana")
my_datetime + ddays(1)
my_datetime + days(1)
my_datetime + dminutes(120)
my_datetime + minutes(120)
my_datetime + dyears(1)
my_datetime + years(1)
my_datetime + months(2)
```

V bazi letalskih letov posodobimo podatke, tako da izračunamo niz, ki predstavlja točen odhod letala.

```{r}
library(nycflights13)
head(flights)
```


``` {r}
flights_datetime <- flights %>% select(year, month, day, hour, minute) %>%
  mutate(DepartureTime = make_datetime(year, month, day, hour, minute))
flights_datetime
head(flights_datetime$DepartureTime)
```

Ali opazimo kakšno težavo? datume smo prebrali v časovni coni UTC, so pa podani v lokalni časovni coni. Podatkov torej nismo pretvorili pravilno! Poizkusimo še enkrat:

``` {r}
flights_datetime <- flights %>% select(year, month, day, hour, minute) %>%
  mutate(DepartureTime = make_datetime(year, month, day, hour, minute,
                                       tz = "America/New_York"))
flights_datetime
head(flights_datetime$DepartureTime)
```


## Shranjevanje in branje podatkov

### Delo z binarnimi datotekami
V programskem jeziku R lahko shranjujemo in nalagamo (v trenutno sejo R) spremenljivke kot binarne objekte na dva prevladujoča načina:

1) S kombinacijo funkcij `save()` in `load()`.
2) S kombinacijo funkcij `saveRDS()` in `readRDS()`.

Pomembna razlika med prvim in drugim pristopom je, da lahko s prvim shranimo več spremenljivk naenkrat, z drugim pa samo eno. Na prvi pogled bi torej pričakovali, da je prvi pristop boljši, oziroma bolj zaželen. Ampak ima eno pomembno slabost, zaradi katere predlagamo uporabo drugega pristopa.

Funkcija `save()` shrani spremenljivke v trenutni seji R v datoteko s končnico *rda* ali *RData*. To naredi tako, da shrani tako vrednost spremenljivke kot tudi ime spremenljivke. To pomeni, da ko bomo takšno datoteko prebrali v novo sejo R, bomo ustvarili spremenljivke z enakimi imeni, kot smo jih shranili. Pri tem pa lahko pride do težav. Recimo, da imamo v trenutni seji R že nek nabor spremenljivk nato pa želimo vanjo prenesti še neke druge spremenljivke, ki smo jih pred časom shranili s funkcijo `save()` v datoteko saved-data.rda. Kaj se bo zgodilo, če bo katera od spremenljivk v naši trenutni seji imela enako ime kot ena od spremenljivk shranjenih v saved-data.rda? R bo enostavno to spremenljivko prepisal s spremenljivko, ki se je nahajala v tej rda datoteki. Takšen postopek dela je lahko torej nevaren, saj lahko *nevede* izbrišemo obstoječe spremenljivke.

Predlagamo torej uporabo druge kombinacije, torej funkcij `saveRDS()` in `readRDS()`. Funkcija `saveRDS()` shrani samo vrednost spremenljivke, ne pa tudi njenega imena, tako da ne pride do podobnih težav kot pri prvem pristopu. Končnica tako shranjenih datotek je *rds*. Poglejmo si uporabo teh funkcij.

```{r}
x <- c(3, 6, 3, 7)
x
saveRDS(x, "./my-saved-files/my-x.rds")

x2 <- readRDS("./my-saved-files/my-x.rds")
x2
```

Vedno ko preberemo podatke v sejo R s funkcijo `readRDS()` ji moramo prirediti ime, saj je v rds datoteki shrnajena samo njena vrednost. S tem se tudi izognemo podobnim težavam kot pri funkcijah `save()` in `load()`.

Pomanjkljivost shranjevanja rds datotek pa je v tem, da lahko naenkrat shranimo samo 1 spremenljivko. Ampak to pomanjkljivost lahko zaobidemo, tako da več spremenljivk enostavno shranimov v seznam (`list()`). Poglejmo si sedaj na primer, kako bi shranili več spremenljivk.

```{r}
tmp_list <- list(
  "x" = x,
  "some_datetime" = my_datetime,
  "ds_jobs" = ds_jobs
)

saveRDS(tmp_list, "./my-saved-files/my-list.rds")
read_list <- readRDS("./my-saved-files/my-list.rds")
names(read_list)
x2 <- read_list[["x"]]
x2
my_datetime2 <- read_list[["some_datetime"]]
my_datetime2
ds_jobs2 <- read_list[["ds_jobs"]]
ds_jobs2
```


### Branje in shranjevanje z ostalimi datotekami

#### Excel

Paket **openxlsx** omogoča delo z exelovimi razpredelnicami. Poglejmo si preproste a uporabne ukaze. Za branje podatkov s tem paketom uprabljamo `read.xlsx()`, za shranjevanje datotek pa `write.xlsx()`.

Preberimo podatke ocen, ki smo jih imeli tudi v testni skripti in jo pretvorimo v tibble:

```{r}
library(openxlsx)
ocene <- tibble(openxlsx::read.xlsx("./test-script/data-raw/student-performance.xlsx"))
ocene
```

Privzeto funkcija `read.xlsx()` odpre prvi list v datoteki in poišče glavo razpredelnice, če želimo druge liste moramo podati ime lista ali številko lista s parametrom `sheet`.

```{r}
library(openxlsx)
ocene_portugalscina <- tibble(read.xlsx("./test-script/data-raw/student-performance.xlsx", sheet = 1))
ocene_matematika <- tibble(read.xlsx("./test-script/data-raw/student-performance.xlsx", sheet = "Math scores"))
ocene_portugalscina %>% 
  select(school, G1, G2, G3, averageScore)
ocene_matematika %>%
  select(school, G1, G2, G3, averageScore)
```

Če ima datoteka veliko število listov jih lahko shranite v R-jev seznam (list).

```{r}
library(openxlsx)
path <- "./test-script/data-raw/student-performance.xlsx"
imenaListov <- getSheetNames(path)
ocene_s <- list()
for(i in 1:length(imenaListov)) {
  ocene_s[[i]] <- tibble(read.xlsx(path))
}
ocene_s
```

V primeru, da je razpredelnica v excelovem listu premaknjena ali pa želimo prebrati le del podatkov, lahko uporabimo parametra `startRow` in `cols`. Preberimo samo ocene za matematiko brez ostalih vrednosti.

```{r}
path <- "./test-script/data-raw/student-performance.xlsx"
ocene_math <- tibble(read.xlsx(path, sheet = "Math scores", startRow = 1, 
                               cols = 9:12))
ocene_math
```
Da podatke shranimo na disk uporabimo `write.xlsx()`.

```{r}
path <- "./test-script/data-raw/samo-ocene-math.xlsx"
write.xlsx(ocene_math, path)
```

#### SPSS

SPSS je program za statistično analizo. Datoteke povezane z SPSS imajo običajno končnico *.sav*. Za branje iz in uvažanje v SPSS lahko uporabimo paket **haven**. V mapi *data_raw* imamo podatke o osebah *osebe.sav*. Za uvoz teh podatkov v R uporabimo funkcijo `read_sav`.

```{r}
library(haven)
podatki <- read_sav("./data-raw/osebe.sav")
podatki
```

Da shranimo data frame v sav datoteko, uporabimo funkcijo `write_sav()`. Shranimo sedaj data frame `iris` v sav datoteko:

```{r}
write_sav(iris, "./data-clean/iris.sav")
```

Paket haven ima tudi funkcijo `read_por()` ki podpira starejše verzije datotek iz SPSS.


## Ali želite izvedeti več?
V tem poglavju smo si ogledali operacije treh paketov tidyversa. Če želite hiter in dokaj celovit pregled nad vsemi ukazi priporočamo, da si za vsak paket ogledate tako imenovan **cheat sheet**:

- **stringr**: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf
- **forcats**: http://www.flutterbys.com.au/stats/downloads/slides/figure/factors.pdf
- **lubridate**: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_lubridate.pdf

Paket **stringr** uporablja paket **stringi**, ki ima na voljo 5x več operacij, ki pa niso tako pogosto uporabljene. Če se boste pri svojem delu srečali z zahtevnejšimi nalogami lahko uporabite ta paket.

Za razumevanje regularnih izrazov in tudi avtomatsko razlago priporočamo stran https://regex101.com/.


## Domača naloga

1) Odprite prvi list ocen v `student-performance.xlsx` v mapi `test-script/data-raw/`. 

    - Odprite le stolpce school, absences, G1, G2, G3 in averageScore. 
    - Dodajte stolpec *točke*, ki ima vrednosti med 0 in 100, tako da ima najvišja pripadajoča vrednost v averageScore vrednost 100.
    - Dodajte stolpec *ocena*, kjer so vrednosti za *točke* med 0 in 10 enake 1, 10 in 20 enake 2 itd.
    - Dodajte stolpec *besedna_ocena* tipa faktor, ki bo imel vrednosti glede na *oceno* in sicer ocene <6 = "nezadostno", 6 = "zadostno", 7 in 8 = "dobro", 9 = "zelo dobro" in 10 = "odlično".


    ```{r, echo = FALSE, message = FALSE}
library(openxlsx)
path <- "./test-script/data-raw/student-performance.xlsx"
ocene <- tibble(read.xlsx(path, cols = c(1, 8:12)))
ocene %>% mutate(točke = averageScore/max(averageScore)*100,
                 ocena = ceiling(točke/10),
                 besedna_ocena = cut(ocena, breaks = c(-Inf, 5, 6, 8, 9, 10), 
                                     labels = c("nezadostno", "zadostno", 
                                                "dobro", "zelo dobro", 
                                                "odlično")))
```

2) Naložite paket `nycflights13` s podatki letov. V tej bazi je več razpredelnic in sicer **flights**, **airlines**, **planes**, **airports** in **weather**. Za razumevanje si pomagajte z `?flights`.

    a) Izpišite vsa letališča, ki imajo 3 ali več besed v svojem imenu.

    ```{r, echo = FALSE, message = FALSE}
airports %>% filter(str_detect(name, "^.+\\s.+\\s.+$"))
```

    b) **Težja** Spremenite imena letališč tako, da odstranite besedi "Airport" ali "Airfield" iz konca imena.

    ```{r, echo = FALSE, message = FALSE}
regex <- "^(.*)(Airport|Airfield)$"
airports %>% 
  mutate(name = ifelse(str_detect(.data$name, regex), # Pogoj.
                       str_match(.data$name, regex)[,2], # Spremenjeno ime.
                       name)) # Isto ime.
```

    c) **Daljša.** Za vsak let sestavite besedno poročilo spodnje oblike, ki ga shranite v stolpec *Poročilo leta*.

        Besedilo naj se glasi: "Let iz letalisca Newark Liberty Intl dne 22.01.13 ob 11:00 v letalisce George Bush Intercontinental je imel 2 minut zamude v odhodu in 11 v prihodu."

        Minute so lahko tudi negativne.

    ```{r, echo = FALSE, message = FALSE}
podatki <- left_join(flights, airports, by = c("origin" = "faa")) %>% 
  mutate(name_origin = name) %>%
  select(year, month, day, sched_dep_time, 
         origin, dest, dep_delay, arr_delay, name_origin)
podatki <- left_join(podatki, airports, by = c("dest" = "faa")) %>%
  mutate(name_dest = name) %>%
  select(year, month, day, sched_dep_time, 
         origin, dest, dep_delay, arr_delay, name_origin, name_dest)
podatki %>% mutate(dep_string = make_datetime(year, month, day, sched_dep_time,
                                              tz = "America/New_York")) %>%
  mutate("Poročilo leta" = str_c("Let iz letalisca ", 
                                 name_origin,
                                 ", dne ", format(dep_string, "%d.%m.%y"),
                                 ", ob ", format(dep_string, "%H:%M"),
                                 " v letalisce ", name_dest,
                                 " je imelo ", dep_delay, 
                                 " minut zamude v odhodu in ",
                                 arr_delay, " v prihodu."
                                 )) %>% 
  select("Poročilo leta", dep_string)
```



